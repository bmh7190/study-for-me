
## **Background**
---
![](../images/Pasted%20image%2020250528095311.png)

프로그램이 실행되기 위해서는 디스크에 저장된 내용을 메인 메모리로 불러와야 한다. 메인 메모리와 레지스터는 오직 CPU에서만 직접 접근할 수 있으며, 메모리 유닛은 주소와 함께 read 요청 또는 주소와 데이터와 함께 write 요청만 처리한다.

레지스터는 CPU가 한 clock 내에 접근할 수 있지만, 메모리는 여러 clock 사이클이 걸리기 때문에 메인 메모리에 접근하면 stall이 발생할 수 있다. 이러한 성능 저하를 줄이기 위해 CPU 레지스터와 메인 메모리 사이에 Cache가 존재한다.

또한, 메모리 공간에 대한 protection이 보장되어야 프로그램이 정확하게 동작할 수 있다.

---
## **Base and Limit Registers**

![](../images/Pasted%20image%2020250528095722.png)
운영체제(OS)에 대한 기본적인 정보는 메모리에 상주하며, 각 프로세스가 생성될 때마다 해당 프로세스는 일정한 메모리 공간을 점유하게 된다. 이때 프로세스가 사용하는 메모리의 시작 주소를 **base**라고 하며, 프로세스가 할당받은 메모리 공간의 크기를 **limit**이라고 한다.  

어떤 프로세스가 특정 주소에 접근하려고 할 때, **그 주소가 해당 프로세스가 할당받은 메모리 범위(base ~ base + limit) 안에 있는지만 확인**하면 된다.  이렇게 확인함으로써 프로세스가 자신에게 허용되지 않은 메모리 영역에 접근하지 않도록 보호할 수 있다.

---
## **Hardware Address Protection**


![](../images/Pasted%20image%2020250528100153.png)

허용된 메모리에서 접근하는 방법은 간단하다! 단순히 base보다 크고 base + limit보다 작은지 확인하면 된다. 이 범위 안에 없으면 OS에 Trap을 한다. 

이런 시스템이 프로세스마다 돌아가기 위해서는 프로세스마다 base와 limit 값을 따로 저장해야 할 것이다.

---
## **Address Binding**

우리가 소스 코드를 사용할 때는 메모리 주소를 직접 표현하지 않고 변수로 대신 사용한다. 실제 주소가 드러나는 시점은 컴파일 시점이지만, 이때도 절대 주소로 변환되는 것이 아니라 상대적인 주소로 표현된다. 컴파일된 결과물은 보통 심볼 영역, 코드 영역, 데이터 영역 등으로 구성되며, 각 모듈이 메모리의 어디에 위치할지를 알려주는 정보가 포함된다. 이러한 여러 모듈을 하나로 합치는 과정을 링킹(linking)이라 하고, 실제로 메모리에 적재하는 과정을 로딩(loading)이라고 한다. 이 과정에서 주소 재배치가 이루어지며, 비로소 절대 주소가 할당되어 실제 주소가 결정된다.


![](../images/Pasted%20image%2020250528101012.png)

---
## **Logical VS Physical Address**

##### Logical address
CPU에 의해 만들어지는 주소로 프로그램에 명시된 주소다. 모든 프로세스는 각자 주소를 0번 부터 시작하겠다!

##### Physical address
실제 메인 메모리에 올라갈 때는 logical address를 physical adrress로 바꿔서 넣어주겠다. 




---
## **Memory - Management Unit (MMU)**

---
## **Contiguous Allocation**

메인 메모리는 OS 와 USER 프로세스들 모두를 지원한다. 

하지만 메인 메모리는 한정되어 있기 때문에, 효율적으로 분배되어야 한다.

Contiguous 할당은 가장 먼저 고안된 방법이다. 

메인 메모리는 보통 2개로 나눌 수 있는데, interrupt vector에 의해 낮은 메모리에서 있는 OS의 잔여물 high 메모리를 점유하는 USER 프로세스들이 있다. 각 프로세스는 메모리의 contiguous