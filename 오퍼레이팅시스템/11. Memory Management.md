
## **Background**
---
![](../images/Pasted%20image%2020250528095311.png)

프로그램이 실행되기 위해서는 디스크에 저장된 내용을 메인 메모리로 불러와야 한다. 메인 메모리와 레지스터는 오직 CPU에서만 직접 접근할 수 있으며, 메모리 유닛은 주소와 함께 read 요청 또는 주소와 데이터와 함께 write 요청만 처리한다.

레지스터는 CPU가 한 clock 내에 접근할 수 있지만, 메모리는 여러 clock 사이클이 걸리기 때문에 메인 메모리에 접근하면 stall이 발생할 수 있다. 이러한 성능 저하를 줄이기 위해 CPU 레지스터와 메인 메모리 사이에 Cache가 존재한다.

또한, 메모리 공간에 대한 protection이 보장되어야 프로그램이 정확하게 동작할 수 있다.

---
## **Base and Limit Registers**

![](../images/Pasted%20image%2020250528095722.png)
운영체제(OS)에 대한 기본적인 정보는 메모리에 상주하며, 각 프로세스가 생성될 때마다 해당 프로세스는 일정한 메모리 공간을 점유하게 된다. 이때 프로세스가 사용하는 메모리의 시작 주소를 **base**라고 하며, 프로세스가 할당받은 메모리 공간의 크기를 **limit**이라고 한다.  

어떤 프로세스가 특정 주소에 접근하려고 할 때, **그 주소가 해당 프로세스가 할당받은 메모리 범위(base ~ base + limit) 안에 있는지만 확인**하면 된다.  이렇게 확인함으로써 프로세스가 자신에게 허용되지 않은 메모리 영역에 접근하지 않도록 보호할 수 있다.

---
## **Hardware Address Protection**


![](../images/Pasted%20image%2020250528100153.png)

허용된 메모리에서 접근하는 방법은 간단하다! 단순히 base보다 크고 base + limit보다 작은지 확인하면 된다. 이 범위 안에 없으면 OS에 Trap을 한다. 

이런 시스템이 프로세스마다 돌아가기 위해서는 프로세스마다 base와 limit 값을 따로 저장해야 할 것이다.

---
## **Address Binding**

우리가 소스 코드를 사용할 때는 메모리 주소를 직접 표현하지 않고 변수로 대신 사용한다. 실제 주소가 드러나는 시점은 컴파일 시점이지만, 이때도 절대 주소로 변환되는 것이 아니라 상대적인 주소로 표현된다. 컴파일된 결과물은 보통 심볼 영역, 코드 영역, 데이터 영역 등으로 구성되며, 각 모듈이 메모리의 어디에 위치할지를 알려주는 정보가 포함된다. 이러한 여러 모듈을 하나로 합치는 과정을 링킹(linking)이라 하고, 실제로 메모리에 적재하는 과정을 로딩(loading)이라고 한다. 이 과정에서 주소 재배치가 이루어지며, 비로소 절대 주소가 할당되어 실제 주소가 결정된다.


![](../images/Pasted%20image%2020250528101012.png)

---
## **Logical VS Physical Address**

##### Logical address

CPU에 의해 생성되는 주소로, 프로그램 내에서 명시된 주소를 의미한다. 모든 프로세스는 자신의 주소 공간을 0번부터 시작한다고 가정한다.

##### Physical address

프로세스가 실제로 메인 메모리에 올라갈 때는, 해당 logical address를 physical address로 변환하여 메모리에 적재하게 된다.


---
## **Memory - Management Unit (MMU)**

logical address를 받아서 physical address로 변환하는 유닛을 Memory Management Unit(MMU)라고 한다. 이는 소프트웨어가 아니라 하드웨어(HW) 구성 요소이다.

![](../images/Pasted%20image%2020250528101435.png)

위의 그림에서 예를 들면, logical address가 346일 때 MMU에서 relocation register의 값이 14000이므로, 이 둘을 더한 값인 14346이 실제 메인 메모리에서 사용되는 physical address가 된다.

---
## **Contiguous Allocation**


메인 메모리는 운영체제(OS)와 사용자(USER) 프로세스 모두를 지원해야 한다. 하지만 메인 메모리는 용량이 제한되어 있기 때문에, 효율적으로 분배되어야 한다.

Contiguous 할당은 가장 먼저 고안된 메모리 할당 방식으로, 모든 프로세스가 하나의 연속된 메모리 공간을 할당받는 방식을 의미한다.

이때 메인 메모리는 일반적으로 두 부분으로 나뉘는데, OS는 컴퓨터가 켜지는 순간부터 꺼질 때까지 항상 존재해야 하므로 메모리의 낮은 주소 공간에 고정되어 할당된다. 반면, 메모리의 높은 주소 공간은 사용자 프로세스들이 점유하며, 각 프로세스는 하나의 연속된 메모리 블록을 할당받는다.

![](../images/Pasted%20image%2020250528102355.png)

앞서 언급한 것처럼, logical address를 physical address로 변환하기 위해서는 limit register와 relocation register(base)만 있으면 된다.

예를 들어, 어떤 load 명령을 통해 주소에서 데이터를 불러오려 할 때, 이 주소는 사실 logical 주소이다. 먼저 해당 logical 주소가 limit register보다 작은지를 확인하여, 프로세스가 할당받은 메모리 공간 내의 주소인지 검증한다. 그다음, relocation register를 이용해 실제 physical address를 계산하고, 해당 주소에서 데이터를 메모리로부터 가져오게 된다.

---

메모리 공간 안에 얼마나 많은 partition을 배치하느냐에 따라 동시에 실행될 수 있는 프로그램의 수가 결정된다. 그리고 당연히 각 프로세스마다 사용하는 메모리 공간의 크기는 다르기 때문에, 프로세스마다 서로 다른 크기의 메모리 공간을 할당하는 것이 더 적절하다. 그러나 이렇게 프로세스마다 메모리를 개별적으로 할당하고, 이후에 해제를 반복하는 과정에서 메모리 내에는 사용되지 않는 빈 공간(구멍, hole)이 생기게 된다.

![](../images/Pasted%20image%2020250528102641.png)

새로운 프로그램이 실행되면, 이 프로그램은 메모리 내 충분한 크기의 hole에 할당된다. 만약 인접한 빈 공간들이 있다면 이를 하나로 합쳐 더 큰 공간을 만들기도 한다. 이 메모리 할당의 주체는 CPU이며, CPU는 효율적인 할당을 위해 어느 프로세스가 어떤 메모리 영역을 점유하고 있는지, 그리고 어떤 부분이 비어 있어 사용 가능한지를 정확히 파악하고 있어야 한다.

---
## **Contiguous Allocation Problem**


#### Fragmentation

연속적인 공간을 할당하는 방식에서는, 할당과 해제가 반복될수록 프로세스에게 딱 맞는 크기의 공간을 확보하기가 점점 어려워진다.

예를 들어, 어떤 프로세스가 18,264Byte의 메모리를 필요로 하는데, 가장 근접한 hole의 크기가 18,300Byte라면 이 공간에 할당할 수밖에 없다. 이 경우 36Byte의 남는 공간이 발생하게 되는데, 이렇게 아주 작은 단위의 공간은 실제로 사용되기 어렵다. 이처럼 할당 외부에 남는 사용 불가능한 공간을 external fragmentation이라고 한다.

이론적으로 전체 빈 공간을 모두 합치면 하나의 프로세스를 수용할 수 있는 충분한 메모리가 되지만, 물리적으로 연속되어 있지 않기 때문에 사용할 수 없게 된다.

이러한 파편화를 줄이기 위한 방법 중 하나는 메모리를 2의 제곱 크기 단위로 할당하는 것이다. 그러나 이 방식은 항상 프로세스가 실제로 필요한 메모리보다 큰 공간을 할당받게 되므로, 할당된 블록 내에서도 사용되지 않고 낭비되는 부분이 생긴다. 이렇게 블록 내부에서 낭비되는 공간을 internal fragmentation이라고 한다.

---

#### Compaction

이렇게 파편화된 공간을 해결하는 간단한 아이디어는, 이미 메모리를 점유하고 있는 프로세스들을 한쪽으로 밀어 정렬하는 것이다. 한쪽으로 모아 배치하면 중간에 흩어져 있던 작은 hole들이 하나로 합쳐져 큰 연속된 공간이 생기게 된다.

하지만 이 방법은 실제로 구현하기가 쉽지 않다. 메모리에 있는 데이터를 하나하나 읽고 이동시킨 뒤, 해당 프로세스가 사용하는 주소들을 모두 수정해줘야 하기 때문이다. 특히 이 작업은 많은 I/O 작업을 수반하게 되고, 이 동안에는 다른 작업들이 일시적으로 중단되거나 대기 상태가 되므로 전체 시스템 성능에 영향을 줄 수 있다.

---
## **Swapping**

스토리지 내부에 backing store라는 거대한 공간을 할당해서