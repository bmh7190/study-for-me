
## **Background**
---
![](../images/Pasted%20image%2020250528095311.png)

프로그램이 실행되기 위해서는 디스크에 저장된 내용을 메인 메모리로 불러와야 한다. 메인 메모리와 레지스터는 오직 CPU에서만 직접 접근할 수 있으며, 메모리 유닛은 주소와 함께 read 요청 또는 주소와 데이터와 함께 write 요청만 처리한다.

레지스터는 CPU가 한 clock 내에 접근할 수 있지만, 메모리는 여러 clock 사이클이 걸리기 때문에 메인 메모리에 접근하면 stall이 발생할 수 있다. 이러한 성능 저하를 줄이기 위해 CPU 레지스터와 메인 메모리 사이에 Cache가 존재한다.

또한, 메모리 공간에 대한 protection이 보장되어야 프로그램이 정확하게 동작할 수 있다.

---
## **Base and Limit Registers**

![](../images/Pasted%20image%2020250528095722.png)
운영체제(OS)에 대한 기본적인 정보는 메모리에 상주하며, 각 프로세스가 생성될 때마다 해당 프로세스는 일정한 메모리 공간을 점유하게 된다. 이때 프로세스가 사용하는 메모리의 시작 주소를 **base**라고 하며, 프로세스가 할당받은 메모리 공간의 크기를 **limit**이라고 한다.  

즉, 각 프로세스는 base와 limit 정보를 통해 자신이 사용할 수 있는 메모리 범위를 결정하며, 이를 통해 다른 프로세스의 메모리 공간에 접근하지 못하도록 보호할 수 있다

어떤 프로세스가 주소를 통해 요청하면 그 주소가 메모리에서 프로세스가 할당받은 공간 안에 있는지 확인만 하면 된다.

---
## **Hardware Address Protection**


![](../images/Pasted%20image%2020250528100153.png)

허용된 메모리에서 접근하는 방법은 간단하다! 단순히 base 보다 크고 base +limit 보다 작은지 확인해야 한다. 만약 ㄷ 


---
## **Memory - Management Unit (MMU)**

---
## **Contiguous Allocation**

메인 메모리는 OS 와 USER 프로세스들 모두를 지원한다. 

하지만 메인 메모리는 한정되어 있기 때문에, 효율적으로 분배되어야 한다.

Contiguous 할당은 가장 먼저 고안된 방법이다. 

메인 메모리는 보통 2개로 나눌 수 있는데, interrupt vector에 의해 낮은 메모리에서 있는 OS의 잔여물 high 메모리를 점유하는 USER 프로세스들이 있다. 각 프로세스는 메모리의 contiguous