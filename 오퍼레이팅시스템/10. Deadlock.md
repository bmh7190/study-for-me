어떤 시스템에 m 개의 resource(R<sub>1</sub>, R<sub>2</sub>, ..., R<sub>m</sub> ) 가 있다고 생각해보자. 각각 resource는 CPU 코어가 될 수도 있고, 메모리 공간이 될 수도 있고, I/O devices가 될 수도 있다.

서로 다른 리소스기 때문에 리소스마다 가지고 있는 instance( W<sub>i</sub> )도 다르다. 각각의 프로세스들은 request use release한다고 생각하자.

---

어떤 프로세스들이 **서로 다른 프로세스가 가진 자원을 기다리는 상태에 놓여 있고**,  이 대기 상태가 **영원히 해결되지 않는 상황**을 **Deadlock(교착 상태)** 이라고 한다.

따라서 Deadlock은 **가장 단순한 경우, 두 개의 프로세스 사이에서도 발생**할 수 있다. 

![](../images/Pasted%20image%2020250521152756.png)


Process 0과 Process 1이 각각 `sem_X`와 `sem_Y`라는 자원을 필요로 하는 상황을 가정하자.  
이때 **Process 0이 먼저 `sem_X`를 획득하고**,  **Process 1이 먼저 `sem_Y`를 획득**했다면, 이후 두 프로세스는 **서로가 가지고 있는 세마포어를 추가로 요구하게 된다.**

즉, **Process 0은 `sem_Y`를 기다리고 있고**,  **Process 1은 `sem_X`를 기다리는 상태**가 되며,  **서로가 서로의 자원을 점유한 채 대기하기 때문에,  이 상태는 해소되지 않고 무한 대기 상태**, 즉 **Deadlock**에 빠지게 된다.

---
## **Deadlock Characterization**

Deadlock은 다음의 **4가지 조건이 모두 만족될 때에만 발생할 수 있다.**

- **Mutual exclusion (상호 배제)**  
    하나의 리소스 인스턴스는 **동시에 하나의 프로세스만 사용할 수 있다.**
    
- **No preemption (비선점)**  
    **한 번 할당된 리소스는** 해당 프로세스가 **자발적으로 반납하기 전까지** 다른 프로세스가 강제로 가져갈 수 없다.
    
- **Hold and wait (보유하며 대기)**  
    **최소 하나의 리소스를 보유한 상태에서**,  **추가적인 리소스를 요청하며 대기**하는 프로세스가 존재해야 한다.
    
- **Circular wait (순환 대기)**  
    각 프로세스가 **다음 프로세스가 점유한 리소스를 기다리는 형태로**,  **원형(고리) 형태의 대기 관계**가 형성되어야 한다.

---
## **Resource-Allocation Graph**


![](../images/Pasted%20image%2020250521153754.png)
프로세스

![](../images/Pasted%20image%2020250521153817.png)
큰 직사각형은 리소스를 나타내며, 큰 직사각형 안에 작은 직사각형들은 인스턴스를 나타낸다.

![](../images/Pasted%20image%2020250521153920.png)
**프로세스 P가 어떤 리소스를 요청할 때는, 프로세스에서 리소스 방향으로 화살표를 그려 표현한다.**

![](../images/Pasted%20image%2020250521154008.png)

프로세스 P가 요청한 리소스의 인스턴스를 실제로 할당받은 경우에는,  해당 인스턴스에서 프로세스 방향으로 화살표를 그려 표현한다.

---
![](../images/Pasted%20image%2020250521154221.png)

왼쪽 그림에서는 **P1, P2, P3가 서로의 자원을 기다리고 있기 때문에**, **Deadlock이 발생한다.**

오른쪽 그림도 겉보기에는 **Deadlock이 발생한 것처럼 보일 수 있지만**,  **P2와 P4는 더 이상 다른 자원을 요청하지 않기 때문에**,  **언젠가는 자신이 점유한 R1과 R2를 반납하게 된다.**

이로 인해 **P1과 P3는 필요한 자원을 얻게 되고**,  결국 **모든 프로세스가 정상적으로 종료될 수 있다.**  따라서 **오른쪽 그림은 Deadlock 상태가 아니다.**

---
## **Deadlock Handling**

Deadlock을 해결하는 방법은 **두 가지 관점**으로 나눌 수 있다.

첫 번째 방법은 **Deadlock을 예방하거나 피하는 것**이다.  하지만 이 방법은 **Deadlock을 완전히 막을 수 있는 보장은 없으며**,  **조금이라도 Deadlock이 발생할 가능성이 있다면 이를 모두 차단해야 하므로**,  **리소스 활용(resource utilization) 측면에서 매우 비효율적일 수 있다.**

두 번째 방법은 **Deadlock이 실제로 발생하는지를 주기적으로 감시하고**,  **발생했을 경우 이를 해결하는 방식**이다. Deadlock을 **탐지하는 과정은 상대적으로 단순**하지만,  **탐지 이후 복구하는 과정은 매우 복잡하고 어려울 수 있다.**

---
## **Deadlock Prevention**

Deadlock이 일어나기 위해서는 반드시 **4가지 조건이 모두 만족**해야 한다.  따라서 이 중 **하나라도 만족되지 않도록 만들면**, Deadlock은 발생하지 않는다.

> **Mutual Exclusion을 없애보면 어떨까?**  

→ 사실 이건 **현실적으로 불가능하다.**  공유 자원이라는 건 **동시에 여러 프로세스가 접근하면 문제가 생기기 때문에**,  상호 배제를 하지 않는 건 **비합리적이다.**

> **Preemption(비선점 조건)을 깨보자!**  

→ 만약 어떤 프로세스가 **하나의 리소스를 보유한 채 다른 리소스를 요청했는데**,  그 요청한 리소스를 **즉시 획득할 수 없다면**,  **현재 보유 중인 리소스들을 모두 반납하도록 강제**한다.  그렇게 반납된 자원은 **다른 대기 중인 프로세스에게 할당**되고,  그 프로세스들이 작업을 마친 후, **원래 프로세스는 자원을 다시 획득하여 재시작**한다.


> **Hold and Wait을 방지해보자!**  

→ **자원을 반드시 한꺼번에 요청**하게 하여,  하나를 보유한 상태에서 **다른 자원을 추가로 요청하지 못하도록** 한다.  즉, 자원을 얻으려면 **모든 자원을 동시에 얻거나**,  
**아예 하나도 얻지 못하고 기다리게** 만드는 것이다.

→ 하지만 이 방식도 **현실성이 떨어진다.**  실제로는 자원이 **순차적으로 필요**한 경우가 많고,  모든 자원을 **사전에 예측해서 요청하는 건 매우 비효율적이다.**  결국 이는 **자원 활용도를 낮추고**, **Starvation(기아 현상)** 을 발생시킬 수 있다.


> **Circular Wait을 깨보자!** 

→ 모든 자원에 **번호를 부여하고**,  프로세스가 자원을 요청할 때는 반드시 **번호 순서대로 요청**하게 한다.  
즉, **낮은 번호 → 높은 번호 순서로만 요청**하도록 제한하는 것이다.  이렇게 하면 **사이클이 형성되지 않기 때문에 Deadlock이 발생하지 않는다.**

→ 하지만 이 방식도 **제약이 많다.**  모든 자원에 **일관된 번호를 부여하는 것 자체도 어려울 뿐더러**,  자원의 번호에 따라 **프로세스 흐름을 제어하는 것도 현실적이지 않다.**

---
## **Deadlock Example**

```c
/* thread one runs in this function */ 
void *do_work_one(void *param){ 
	pthread_mutex_lock(&first_mutex); 
	pthread_mutex_lock(&second_mutex); 
	/** * Do some work */
	pthread_mutex_unlock(&second_mutex); 
	pthread_mutex_unlock(&first_mutex); 
	pthread_exit(0); 
} 
/* thread two runs in this function */ 
void *do_work_two(void *param){ 
	pthread_mutex_lock(&second_mutex); 
	pthread_mutex_lock(&first_mutex); 
	/** * Do some work */
	pthread_mutex_unlock(&first_mutex); 
	pthread_mutex_unlock(&second_mutex); 
	pthread_exit(0); 
} 
```

---
## **Deadlock Avoidance**

그나마 가장 현실성 있는 방법은 Circular wait이 발생하지 않도록 방지하는 것이다. 하지만 아무런 정보 없이 Circular wait을 예방하는 것은 어렵기 때문에, 몇 가지 사전 정보를 기반으로 해야 한다. 

가장 간단하고 활용 가능한 정보는 각 프로세스가 필요한 **각 리소스의 최대 수량**을 미리 알고 있다고 가정하는 것이다. 

Deadlock-avoidance 알고리즘은 현재의 **자원 할당 상태(resource-allocation state)** 를 동적으로 검사하여, **순환 대기(Circular wait)** 조건이 절대 발생하지 않도록 한다. 여기서 자원 할당 상태란, **사용 가능한 자원 수, 이미 할당된 자원 수, 각 프로세스의 최대 자원 요구량**을 모두 포함한 상태 정보를 말한다.

---
## **Banker's Algorithm**

n개의 프로세스가 있다고 가정하고, 리소스의 종류가 m개라고 할 때, 각 리소스 R_i마다 i번째 리소스에 R_i개의 인스턴스가 존재한다고 가정한다. 

현재 상태에서 어떤 순서로 자원을 각 프로세스에 최대값까지 할당했을 때, 모든 프로세스가 자원을 획득하고 실행한 후 자원을 반납하여 전체 자원을 회수할 수 있는 순서가 존재하는지를 확인하는 것이 핵심이다. 이러한 자원 할당 순서를 **safe sequence**라고 하며, 이는 Deadlock 없이 자원을 안전하게 회수할 수 있도록 보장해준다. 

만약 j < i일 때, 프로세스 P<sub>i</sub> 가 원하는 자원을 즉시 획득할 수 없다면 P<sub>i</sub> 는 먼저 실행되는 프로세스 P<sub>j</sub> 가 종료될 때까지 기다린다. 이후 P<sub>j</sub> 가 종료되어 자원을 반환하면, P<sub>i</sub>는 자원을 획득하고 실행한 후 자원을 다시 반환한다. 그리고 P<sub>i</sub>가 종료되면, 다음 프로세스도 동일한 방식으로 자원을 획득하고 실행하며, 이러한 방식으로 모든 프로세스가 안전하게 실행될 수 있다.

safe sequence가 하나라도 있으면 safe state에 있다고 하고, 하나라도 없으면 unsafe state에 있다고 한다. deadlock을 이어질 수도 잇는거지..

![](../images/Pasted%20image%2020250521224321.png)

모든 프로세스가 자신의 **최대 자원 사용량을 사전에 알려준다고 가정**하고, 각각의 프로세스는 자원을 요청하거나 wait할 수 있다고 가정한다. 이때 시스템은 현재 상태가 **unsafe state로 진입할 가능성이 있다면**, 해당 요청을 거부하고 프로세스를 **대기 상태로 전환시킬 수 있다.** 또한 각 프로세스가 **필요한 자원을 모두 할당받은 경우에는**, 해당 프로세스는 반드시 **한정된 시간 내에 실행을 완료하고 자원을 반환해야 한다.** 

---
> [!note] Notation
> n은 프로세스의 수, m은 자원 타입의 수라고 가정
> 
> `Available[1:m]` : 각 자원 타입별로 **현재 사용 가능한 자원의 수**
> 
> `Max[1:n, 1:m]` : 각 프로세스가 **최대 얼마까지 자원을 요구할 수 있는지**를 나타내는 행렬
> 
> `Allocation[1:n, 1:m]` : **현재 각 프로세스에 할당된 자원의 수**
> 
> `Need[1:n, 1:m]` : 각 프로세스가 앞으로 **얼마나 더 자원이 필요한지를 나타내는 값**으로, 각 항목은 `Need[i, j] = Max[i, j] - Allocation[i, j]`로 계산  
> 즉, `Max[i, j] = Allocation[i, j] + Need[i, j]` 관계가 항상 성립

