어떤 시스템에 m 개의 resource(R<sub>1</sub>, R<sub>2</sub>, ..., R<sub>m</sub> ) 가 있다고 생각해보자. 각각 resource는 CPU 코어가 될 수도 있고, 메모리 공간이 될 수도 있고, I/O devices가 될 수도 있다.

서로 다른 리소스기 때문에 리소스마다 가지고 있는 instance( W<sub>i</sub> )도 다르다. 각각의 프로세스들은 request use release한다고 생각하자.

---

어떤 프로세스들이 **서로 다른 프로세스가 가진 자원을 기다리는 상태에 놓여 있고**,  이 대기 상태가 **영원히 해결되지 않는 상황**을 **Deadlock(교착 상태)** 이라고 한다.

따라서 Deadlock은 **가장 단순한 경우, 두 개의 프로세스 사이에서도 발생**할 수 있다. 

![](../images/Pasted%20image%2020250521152756.png)


Process 0과 Process 1이 각각 `sem_X`와 `sem_Y`라는 자원을 필요로 하는 상황을 가정하자.  
이때 **Process 0이 먼저 `sem_X`를 획득하고**,  **Process 1이 먼저 `sem_Y`를 획득**했다면, 이후 두 프로세스는 **서로가 가지고 있는 세마포어를 추가로 요구하게 된다.**

즉, **Process 0은 `sem_Y`를 기다리고 있고**,  **Process 1은 `sem_X`를 기다리는 상태**가 되며,  **서로가 서로의 자원을 점유한 채 대기하기 때문에,  이 상태는 해소되지 않고 무한 대기 상태**, 즉 **Deadlock**에 빠지게 된다.

---
## **Deadlock Characterization**

Deadlock은 다음의 **4가지 조건이 모두 만족될 때에만 발생할 수 있다.**

- **Mutual exclusion (상호 배제)**  
    하나의 리소스 인스턴스는 **동시에 하나의 프로세스만 사용할 수 있다.**
    
- **No preemption (비선점)**  
    **한 번 할당된 리소스는** 해당 프로세스가 **자발적으로 반납하기 전까지** 다른 프로세스가 강제로 가져갈 수 없다.
    
- **Hold and wait (보유하며 대기)**  
    **최소 하나의 리소스를 보유한 상태에서**,  **추가적인 리소스를 요청하며 대기**하는 프로세스가 존재해야 한다.
    
- **Circular wait (순환 대기)**  
    각 프로세스가 **다음 프로세스가 점유한 리소스를 기다리는 형태로**,  **원형(고리) 형태의 대기 관계**가 형성되어야 한다.

---
## **Resource-Allocation Graph**


![](../images/Pasted%20image%2020250521153754.png)
프로세스

![](../images/Pasted%20image%2020250521153817.png)
큰 직사각형은 리소스를 나타내며, 큰 직사각형 안에 작은 직사각형들은 인스턴스를 나타낸다.

![](../images/Pasted%20image%2020250521153920.png)
**프로세스 P가 어떤 리소스를 요청할 때는, 프로세스에서 리소스 방향으로 화살표를 그려 표현한다.**

![](../images/Pasted%20image%2020250521154008.png)

프로세스 P가 요청한 리소스의 인스턴스를 실제로 할당받은 경우에는,  해당 인스턴스에서 프로세스 방향으로 화살표를 그려 표현한다.

---
![](../images/Pasted%20image%2020250521154221.png)

