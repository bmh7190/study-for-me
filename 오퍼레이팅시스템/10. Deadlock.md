어떤 시스템에 m 개의 resource(R<sub>1</sub>, R<sub>2</sub>, ..., R<sub>m</sub> ) 가 있다고 생각해보자. 각각 resource는 CPU 코어가 될 수도 있고, 메모리 공간이 될 수도 있고, I/O devices가 될 수도 있다.

서로 다른 리소스기 때문에 리소스마다 가지고 있는 instance( W<sub>i</sub> )도 다르다. 각각의 프로세스들은 request use release한다고 생각하자.

---

어떤 프로세스들이 **서로 다른 프로세스가 가진 자원을 기다리는 상태에 놓여 있고**,  이 대기 상태가 **영원히 해결되지 않는 상황**을 **Deadlock(교착 상태)** 이라고 한다.

따라서 Deadlock은 **가장 단순한 경우, 두 개의 프로세스 사이에서도 발생**할 수 있다. 

![](../images/Pasted%20image%2020250521152756.png)


Process 0과 Process 1이 각각 `sem_X`와 `sem_Y`라는 자원을 필요로 하는 상황을 가정하자.  
이때 **Process 0이 먼저 `sem_X`를 획득하고**,  **Process 1이 먼저 `sem_Y`를 획득**했다면, 이후 두 프로세스는 **서로가 가지고 있는 세마포어를 추가로 요구하게 된다.**

즉, **Process 0은 `sem_Y`를 기다리고 있고**,  **Process 1은 `sem_X`를 기다리는 상태**가 되며,  **서로가 서로의 자원을 점유한 채 대기하기 때문에,  이 상태는 해소되지 않고 무한 대기 상태**, 즉 **Deadlock**에 빠지게 된다.

---
## **Deadlock Characterization**

Deadlock은 다음의 **4가지 조건이 모두 만족될 때에만 발생할 수 있다.**

- **Mutual exclusion (상호 배제)**  
    하나의 리소스 인스턴스는 **동시에 하나의 프로세스만 사용할 수 있다.**
    
- **No preemption (비선점)**  
    **한 번 할당된 리소스는** 해당 프로세스가 **자발적으로 반납하기 전까지** 다른 프로세스가 강제로 가져갈 수 없다.
    
- **Hold and wait (보유하며 대기)**  
    **최소 하나의 리소스를 보유한 상태에서**,  **추가적인 리소스를 요청하며 대기**하는 프로세스가 존재해야 한다.
    
- **Circular wait (순환 대기)**  
    각 프로세스가 **다음 프로세스가 점유한 리소스를 기다리는 형태로**,  **원형(고리) 형태의 대기 관계**가 형성되어야 한다.

---
## **Resource-Allocation Graph**


![](../images/Pasted%20image%2020250521153754.png)
프로세스

![](../images/Pasted%20image%2020250521153817.png)
큰 직사각형은 리소스를 나타내며, 큰 직사각형 안에 작은 직사각형들은 인스턴스를 나타낸다.

![](../images/Pasted%20image%2020250521153920.png)
**프로세스 P가 어떤 리소스를 요청할 때는, 프로세스에서 리소스 방향으로 화살표를 그려 표현한다.**

![](../images/Pasted%20image%2020250521154008.png)

프로세스 P가 요청한 리소스의 인스턴스를 실제로 할당받은 경우에는,  해당 인스턴스에서 프로세스 방향으로 화살표를 그려 표현한다.

---
![](../images/Pasted%20image%2020250521154221.png)

왼쪽 그림에서는 **P1, P2, P3가 서로의 자원을 기다리고 있기 때문에**, **Deadlock이 발생한다.**

오른쪽 그림도 겉보기에는 **Deadlock이 발생한 것처럼 보일 수 있지만**,  **P2와 P4는 더 이상 다른 자원을 요청하지 않기 때문에**,  **언젠가는 자신이 점유한 R1과 R2를 반납하게 된다.**

이로 인해 **P1과 P3는 필요한 자원을 얻게 되고**,  결국 **모든 프로세스가 정상적으로 종료될 수 있다.**  따라서 **오른쪽 그림은 Deadlock 상태가 아니다.**

---
## **Deadlock Handling**

Deadlock을 해결하는 방법은 **두 가지 관점**으로 나눌 수 있다.

첫 번째 방법은 **Deadlock을 예방하거나 피하는 것**이다.  하지만 이 방법은 **Deadlock을 완전히 막을 수 있는 보장은 없으며**,  **조금이라도 Deadlock이 발생할 가능성이 있다면 이를 모두 차단해야 하므로**,  **리소스 활용(resource utilization) 측면에서 매우 비효율적일 수 있다.**

두 번째 방법은 **Deadlock이 실제로 발생하는지를 주기적으로 감시하고**,  **발생했을 경우 이를 해결하는 방식**이다. Deadlock을 **탐지하는 과정은 상대적으로 단순**하지만,  **탐지 이후 복구하는 과정은 매우 복잡하고 어려울 수 있다.**

---
## **Deadlock Prevention**

Deadlock이 일어나려면 지켜야할 4조건 중 하나만 안 지켜지게 한다면 Deadlock이 안 일어나게 할 수 있따.

mutual exclusion을 안 해보면 어떨까?
이건 사실 말이 안됩니다. 자원 공유를 할 때 안된다면 뭔가 합리적이지 않다.

Preemtion 하게 하자!
만약에 어떤 프로세스가 어떤 리소스를 가진 체로 다른 리소스를 요청할 때, 이게 바로 할당되지 않을 때, 모든 리소스들을 풀어준다. 양보된 리소스들은 기다리고 있는 프로세스들에게 제공된다.  프로세스들은 양보된 리소스들을 가지고 일을 하다가 언젠가 끝이 나고, 원래 프로세스는 양보된 리소스들을 다시 얻어 재 시작을 한다.

hold and wait 을 하지 않게 하자!
자원을 반드시 한꺼번에 요청하도록 하여, 하나를 가진 상태에서 다른걸 요청하지 않도록 한다. 한꺼번에 얻거나 기다리거나 둘 중 하나의 상태로 되도록 하게 한다. 근데 사실 이것도 말이 안돼! 리소스들을 동시에 필요하지 않고, A를 요청하여 사용하다가 B 가 필요한 경우 한꺼번에 요청하기 위해서 예측 하는 것은 말이 안됨 이렇게 모든 것을 예측하려고 하면 당연히 resource utilization이 떨어지고, starvation이 발생할 수 있다.

Circular wait이 없도록 하자!
모든 프로세스가 같은 순서로 리소스를 얻도록 한다. 쉽게 말하면 모든 자원들에 번호를 부여해서 번호가 낮은 순서에서 높은 순서대로 얻도록 하는 것이다.