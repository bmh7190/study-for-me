어떤 시스템에 m 개의 resource(R<sub>1</sub>, R<sub>2</sub>, ..., R<sub>m</sub> ) 가 있다고 생각해보자. 각각 resource는 CPU 코어가 될 수도 있고, 메모리 공간이 될 수도 있고, I/O devices가 될 수도 있다.

서로 다른 리소스기 때문에 리소스마다 가지고 있는 instance( W<sub>i</sub> )도 다르다. 각각의 프로세스들은 request use release한다고 생각하자.

---

어떤 프로세스들이 **서로 다른 프로세스가 가진 자원을 기다리는 상태에 놓여 있고**,  이 대기 상태가 **영원히 해결되지 않는 상황**을 **Deadlock(교착 상태)** 이라고 한다.

따라서 Deadlock은 **가장 단순한 경우, 두 개의 프로세스 사이에서도 발생**할 수 있다. 

![](../images/Pasted%20image%2020250521152756.png)


Process 0과 Process 1이 각각 `sem_X`와 `sem_Y`라는 자원을 필요로 하는 상황을 가정하자.  
이때 **Process 0이 먼저 `sem_X`를 획득하고**,  **Process 1이 먼저 `sem_Y`를 획득**했다면, 이후 두 프로세스는 **서로가 가지고 있는 세마포어를 추가로 요구하게 된다.**

즉, **Process 0은 `sem_Y`를 기다리고 있고**,  **Process 1은 `sem_X`를 기다리는 상태**가 되며,  **서로가 서로의 자원을 점유한 채 대기하기 때문에,  이 상태는 해소되지 않고 무한 대기 상태**, 즉 **Deadlock**에 빠지게 된다.

---
## **Deadlock Characterization**

Deadlock은 다음의 **4가지 조건이 모두 만족될 때에만 발생할 수 있다.**

- **Mutual exclusion (상호 배제)**  
    하나의 리소스 인스턴스는 **동시에 하나의 프로세스만 사용할 수 있다.**
    
- **No preemption (비선점)**  
    **한 번 할당된 리소스는** 해당 프로세스가 **자발적으로 반납하기 전까지** 다른 프로세스가 강제로 가져갈 수 없다.
    
- **Hold and wait (보유하며 대기)**  
    **최소 하나의 리소스를 보유한 상태에서**,  **추가적인 리소스를 요청하며 대기**하는 프로세스가 존재해야 한다.
    
- **Circular wait (순환 대기)**  
    각 프로세스가 **다음 프로세스가 점유한 리소스를 기다리는 형태로**,  **원형(고리) 형태의 대기 관계**가 형성되어야 한다.

---
## **Resource-Allocation Graph**


![](../images/Pasted%20image%2020250521153754.png)
프로세스

![](../images/Pasted%20image%2020250521153817.png)
큰 직사각형은 리소스를 나타내며, 큰 직사각형 안에 작은 직사각형들은 인스턴스를 나타낸다.

![](../images/Pasted%20image%2020250521153920.png)
**프로세스 P가 어떤 리소스를 요청할 때는, 프로세스에서 리소스 방향으로 화살표를 그려 표현한다.**

![](../images/Pasted%20image%2020250521154008.png)

프로세스 P가 요청한 리소스의 인스턴스를 실제로 할당받은 경우에는,  해당 인스턴스에서 프로세스 방향으로 화살표를 그려 표현한다.

---
![](../images/Pasted%20image%2020250521154221.png)

왼쪽 그림에서는 **P1, P2, P3가 서로의 자원을 기다리고 있기 때문에**, **Deadlock이 발생한다.**

오른쪽 그림도 겉보기에는 **Deadlock이 발생한 것처럼 보일 수 있지만**,  **P2와 P4는 더 이상 다른 자원을 요청하지 않기 때문에**,  **언젠가는 자신이 점유한 R1과 R2를 반납하게 된다.**

이로 인해 **P1과 P3는 필요한 자원을 얻게 되고**,  결국 **모든 프로세스가 정상적으로 종료될 수 있다.**  따라서 **오른쪽 그림은 Deadlock 상태가 아니다.**

---
## **Deadlock Handling**

Deadlock을 해결하는 방법은 **두 가지 관점**으로 나눌 수 있다.

첫 번째 방법은 **Deadlock을 예방하거나 피하는 것**이다.  하지만 이 방법은 **Deadlock을 완전히 막을 수 있는 보장은 없으며**,  **조금이라도 Deadlock이 발생할 가능성이 있다면 이를 모두 차단해야 하므로**,  **리소스 활용(resource utilization) 측면에서 매우 비효율적일 수 있다.**

두 번째 방법은 **Deadlock이 실제로 발생하는지를 주기적으로 감시하고**,  **발생했을 경우 이를 해결하는 방식**이다. Deadlock을 **탐지하는 과정은 상대적으로 단순**하지만,  **탐지 이후 복구하는 과정은 매우 복잡하고 어려울 수 있다.**

---
## **Deadlock Prevention**

Deadlock이 일어나기 위해서는 반드시 **4가지 조건이 모두 만족**해야 한다.  따라서 이 중 **하나라도 만족되지 않도록 만들면**, Deadlock은 발생하지 않는다.

> **Mutual Exclusion을 없애보면 어떨까?**  

→ 사실 이건 **현실적으로 불가능하다.**  공유 자원이라는 건 **동시에 여러 프로세스가 접근하면 문제가 생기기 때문에**,  상호 배제를 하지 않는 건 **비합리적이다.**

> **Preemption(비선점 조건)을 깨보자!**  

→ 만약 어떤 프로세스가 **하나의 리소스를 보유한 채 다른 리소스를 요청했는데**,  그 요청한 리소스를 **즉시 획득할 수 없다면**,  **현재 보유 중인 리소스들을 모두 반납하도록 강제**한다.  그렇게 반납된 자원은 **다른 대기 중인 프로세스에게 할당**되고,  그 프로세스들이 작업을 마친 후, **원래 프로세스는 자원을 다시 획득하여 재시작**한다.


> **Hold and Wait을 방지해보자!**  

→ **자원을 반드시 한꺼번에 요청**하게 하여,  하나를 보유한 상태에서 **다른 자원을 추가로 요청하지 못하도록** 한다.  즉, 자원을 얻으려면 **모든 자원을 동시에 얻거나**,  
**아예 하나도 얻지 못하고 기다리게** 만드는 것이다.

→ 하지만 이 방식도 **현실성이 떨어진다.**  실제로는 자원이 **순차적으로 필요**한 경우가 많고,  모든 자원을 **사전에 예측해서 요청하는 건 매우 비효율적이다.**  결국 이는 **자원 활용도를 낮추고**, **Starvation(기아 현상)** 을 발생시킬 수 있다.


> **Circular Wait을 깨보자!** 

→ 모든 자원에 **번호를 부여하고**,  프로세스가 자원을 요청할 때는 반드시 **번호 순서대로 요청**하게 한다.  
즉, **낮은 번호 → 높은 번호 순서로만 요청**하도록 제한하는 것이다.  이렇게 하면 **사이클이 형성되지 않기 때문에 Deadlock이 발생하지 않는다.**

→ 하지만 이 방식도 **제약이 많다.**  모든 자원에 **일관된 번호를 부여하는 것 자체도 어려울 뿐더러**,  자원의 번호에 따라 **프로세스 흐름을 제어하는 것도 현실적이지 않다.**

---
## **Deadlock Example**

```c
/* thread one runs in this function */ 
void *do_work_one(void *param){ 
	pthread_mutex_lock(&first_mutex); 
	pthread_mutex_lock(&second_mutex); 
	/** * Do some work */
	pthread_mutex_unlock(&second_mutex); 
	pthread_mutex_unlock(&first_mutex); 
	pthread_exit(0); 
} 
/* thread two runs in this function */ 
void *do_work_two(void *param){ 
	pthread_mutex_lock(&second_mutex); 
	pthread_mutex_lock(&first_mutex); 
	/** * Do some work */
	pthread_mutex_unlock(&first_mutex); 
	pthread_mutex_unlock(&second_mutex); 
	pthread_exit(0); 
} 
```

---
## **Deadlock Avoidance**

그나마 가장 현실성 있는 방법은 Circular wait이 발생하지 않도록 방지하는 것이다. 하지만 아무런 정보 없이 Circular wait을 예방하는 것은 어렵기 때문에, 몇 가지 사전 정보를 기반으로 해야 한다. 

가장 간단하고 활용 가능한 정보는 각 프로세스가 필요한 **각 리소스의 최대 수량**을 미리 알고 있다고 가정하는 것이다. 

Deadlock-avoidance 알고리즘은 현재의 **자원 할당 상태(resource-allocation state)** 를 동적으로 검사하여, **순환 대기(Circular wait)** 조건이 절대 발생하지 않도록 한다. 여기서 자원 할당 상태란, **사용 가능한 자원 수, 이미 할당된 자원 수, 각 프로세스의 최대 자원 요구량**을 모두 포함한 상태 정보를 말한다.

---
## **Banker's Algorithm**

n개의 프로세스가 있다고 가정하고, 리소스의 종류가 m개라고 할 때, 각 리소스 R_i마다 i번째 리소스에 R_i개의 인스턴스가 존재한다고 가정한다. 

현재 상태에서 어떤 순서로 자원을 각 프로세스에 최대값까지 할당했을 때, 모든 프로세스가 자원을 획득하고 실행한 후 자원을 반납하여 전체 자원을 회수할 수 있는 순서가 존재하는지를 확인하는 것이 핵심이다. 이러한 자원 할당 순서를 **safe sequence**라고 하며, 이는 Deadlock 없이 자원을 안전하게 회수할 수 있도록 보장해준다. 

만약 j < i일 때, 프로세스 P<sub>i</sub> 가 원하는 자원을 즉시 획득할 수 없다면 P<sub>i</sub> 는 먼저 실행되는 프로세스 P<sub>j</sub> 가 종료될 때까지 기다린다. 이후 P<sub>j</sub> 가 종료되어 자원을 반환하면, P<sub>i</sub>는 자원을 획득하고 실행한 후 자원을 다시 반환한다. 그리고 P<sub>i</sub>가 종료되면, 다음 프로세스도 동일한 방식으로 자원을 획득하고 실행하며, 이러한 방식으로 모든 프로세스가 안전하게 실행될 수 있다.

safe sequence가 하나라도 있으면 safe state에 있다고 하고, 하나라도 없으면 unsafe state에 있다고 한다. deadlock을 이어질 수도 잇는거지..

![](../images/Pasted%20image%2020250521224321.png)

모든 프로세스가 자신의 **최대 자원 사용량을 사전에 알려준다고 가정**하고, 각각의 프로세스는 자원을 요청하거나 wait할 수 있다고 가정한다. 이때 시스템은 현재 상태가 **unsafe state로 진입할 가능성이 있다면**, 해당 요청을 거부하고 프로세스를 **대기 상태로 전환시킬 수 있다.** 또한 각 프로세스가 **필요한 자원을 모두 할당받은 경우에는**, 해당 프로세스는 반드시 **한정된 시간 내에 실행을 완료하고 자원을 반환해야 한다.** 

---
> [!note] Notation
> n은 프로세스의 수, m은 자원 타입의 수라고 가정
> 
> `Available[1:m]` : 각 자원 타입별로 **현재 사용 가능한 자원의 수**
> 
> `Max[1:n, 1:m]` : 각 프로세스가 **최대 얼마까지 자원을 요구할 수 있는지**를 나타내는 행렬
> 
> `Allocation[1:n, 1:m]` : **현재 각 프로세스에 할당된 자원의 수**
> 
> `Need[1:n, 1:m]` : 각 프로세스가 앞으로 **얼마나 더 자원이 필요한지를 나타내는 값**으로, 각 항목은 `Need[i, j] = Max[i, j] - Allocation[i, j]`로 계산  
> 즉, `Max[i, j] = Allocation[i, j] + Need[i, j]` 관계가 항상 성립

Safety Alogorithm -> 현재 safe state에 있는지 판단하는 알고리즘
Resource-Request Alogorithm -> 어떤 resource request가 있을 때 이를 허가해도 되는지 판단

---
## **Safety Alogrithm**

![](../images/Pasted%20image%2020250521230331.png)

![](../images/Pasted%20image%2020250521230802.png)

Need는 `Max - Allocation`으로 계산하며, 이 값을 기반으로 현재 Available 자원으로 어떤 프로세스가 실행 가능한지 판단한다. 위 그림에서 먼저 P1과 P3가 실행 가능한 상태이며, 여기서 P1을 선택해 실행하면, 실행이 끝난 뒤 P1에 할당됐던 자원을 Available에 반납하게 된다.

![](../images/Pasted%20image%2020250521231057.png)

다시 Need를 확인하면 P3와 P4가 실행 가능한데, Need가 Available보다 작거나 같기 때문이다. 이 중 P3를 선택하고 실행을 완료하면, 마찬가지로 P3의 Allocation이 Available에 더해진다.

![](../images/Pasted%20image%2020250521231254.png)

이 과정을 반복해 모든 프로세스가 실행되고 종료될 수 있다면, 이는 시스템이 safe sequence를 가지고 있다는 의미이며, Deadlock은 발생하지 않는다. 다음 단계부터는 모든 프로세스가 Need ≤ Available을 만족하므로, 어떤 순서로든 자원을 할당해도 Deadlock이 발생하지 않는다.

---
> [!note] Safety Algorithm
> 1. `Work[1:m]`과 `Finish[1:n]`을 초기화한다. 이때 `Work`는 현재 사용 가능한 자원 수인 `Available`로 설정하고, 모든 `Finish[i]`는 false로 초기화한다. 
> 
> 2. 그런 다음 아직 종료되지 않은 프로세스 i 중에서 `(a) Finish[i] = false`이고 `(b) Need[i] <= Work`인 프로세스를 찾는다. 만약 그런 프로세스가 존재하지 않으면 step 4로 간다. 
> 
> 3. 해당 조건을 만족하는 프로세스 i가 있다면, 그 프로세스를 실행 가능한 것으로 판단하고 `Work = Work + Allocation[i]`로 자원을 회수하고, `Finish[i] = true`로 설정한 후 다시 step 2로 돌아가 이 과정을 반복한다. 
> 
> 4. 최종적으로 모든 `Finish[i]`가 true가 되면, 즉 모든 프로세스가 안전하게 실행될 수 있다면 시스템은 safe state에 있는 것이다.


---
## **Banker's Algorithm - Resource - Request Alogrithm**

내가 Resource-Request를 들어줬다고 가정하고, 그 결과 시스템이 unsafe state로 판단된다면, 해당 요청은 허용해서는 안 된다. 이 판단은 앞서 정리한 safety algorithm을 그대로 사용해 수행한다.

![](../images/Pasted%20image%2020250521232119.png)

P0가 (0, 2, 0)을 요청했다고 가정하면, 요청을 수락했을 때 P0의 Allocation은 ( 0, 1, 0 )에서 (0, 3, 0)이 되고, 그만큼 자원을 사용했으므로 Available은 기존 (5, 3, 2)에서 (5, 1, 2)로 감소한다.

![](../images/Pasted%20image%2020250521232428.png)

상태에서 safety algorithm을 적용해 보면, 모든 프로세스가 종료 가능한 safe sequence가 존재한다. 따라서 이 요청은 시스템을 unsafe state로 만들지 않기 때문에, 해당 request를 **허용해도 된다**는 결론을 내릴 수 있다.

> [!note] Resource-Request Algorithm
> 먼저 요청 벡터 `Request i`가 `Needi`보다 작거나 같은지 확인한다. 만약 그렇지 않다면, 이는 Pi가 최대 자원 요구량을 초과한 것이므로 오류를 발생시킨다. 
> 
> 다음으로 `Request i`가 `Available`보다 작거나 같은지 확인한다. 작거나 같다면 현재 사용 가능한 자원으로 요청을 처리할 수 있다는 의미이고, 그렇지 않다면 Pi는 자원이 충분히 돌아올 때까지 기다려야 한다. 
> 
> 조건을 모두 만족하면, 요청된 자원을 Pi에게 할당한다고 가정하고 상태를 임시로 변경한다. 
> 
> `Available = Available - Requesti`
> `Allocationi = Allocationi + Requesti`
> `Needi = Needi - Requesti`
> 
> 임시로 변경한 뒤  safety algorithm을 실행해 시스템이 safe state인지 확인한다. 
> 
> 만약 이 상태가 안전하다면 Pi에게 자원을 실제로 할당한다. 반면, 이 상태가 unsafe하다면 Pi는 자원을 기다려야 하며, 위에서 변경한 자원 상태는 원래대로 복구된다.

실제로 이 알고리즘을 사용하는 것은 어렵다. 그 이유는 처음에 가정하는 자원의 수나 프로세스의 수가 **동적으로 변할 수 있기 때문**이며, 특히 **각 프로세스가 자신의 최대 자원 요구량(Max)을 정확히 예측해야 한다는 전제 자체가 현실적으로 매우 어렵다.** 모든 프로세스가 시작 전에 자원 사용량을 약속하고, 그 범위를 벗어나지 않는다는 것은 이상적일 뿐이다. 

또한 자원 할당을 위해 wait이 필요한 상황이 자주 발생하며, 이 경우 프로세스가 **무기한으로 기다리게 될 수도 있다.** 

게다가 이 알고리즘은 매우 보수적인 접근을 취한다. **safe state를 유지하려는 목적 때문에 자원 할당 자체를 제한적으로 수행하게 되고**, 프로세스들도 Max 값을 보수적으로 낮게 설정하게 되며, 결과적으로 **resource utilization이 낮아지는 문제**가 발생한다.

---
## **Deadlock Detection**

각 리소스 종류마다 인스턴스가 **하나만 존재하는 경우**, Wait-for 그래프를 그렸을 때 **사이클이 생기면 Deadlock이 반드시 발생한 것**으로 판단할 수 있다. 그러나 **리소스 인스턴스가 여러 개인 경우**에는, 사이클이 존재하더라도 반드시 Deadlock이라고 단정할 수 없고, **그래프 기반으로 판단하는 것이 매우 복잡해진다.** 이러한 경우에는 그래프 기반 방식 대신, banker’s algorithm과 비슷한  **Deadlock Detection 알고리즘을 사용하여** 현재 시스템 상태에서 실제로 Deadlock이 발생했는지를 **정확하게 파악**하는 방식이 사용된다.

### Single Instance

자원 타입마다 인스턴스가 하나만 존재하는 경우, 시스템은 **Wait-for Graph**를 유지하여 Deadlock을 감지한다. 이 그래프는 **각 프로세스가 어떤 다른 프로세스를 기다리고 있는지**를 나타내며, 주기적으로 이 그래프에 대해 **사이클(cycle)** 이 존재하는지를 확인하는 알고리즘을 실행한다. 만약 사이클이 발견되면, **Deadlock이 발생한 것으로 간주한다.** 사이클을 탐지하기 위한 그래프 알고리즘의 시간 복잡도는 O(n²)이며, 여기서 n은 그래프의 정점 수, 즉 프로세스의 수를 의미한다.

![](../images/Pasted%20image%2020250522002451.png)

인스턴스가 하나인 경우에는 자원이 어떻게 구체적으로 할당되어 있는지를 일일이 보는 것보다, **사이클이 존재하는지를 파악하는 것이 핵심**이기 때문에, 왼쪽 그림처럼 **프로세스와 자원 간의 관계(자원 할당 그래프)** 로 표현할 수도 있지만, **오른쪽처럼 자원 노드를 생략하고 프로세스 간의 대기 관계만을 표현한 Wait-for 그래프**로 단순화할 수 있다. 이처럼 **각 프로세스가 어떤 다른 프로세스를 기다리고 있는지만 표시하면**, 사이클 유무를 더 쉽게 확인할 수 있고, **사이클이 존재하면 Deadlock이 발생한 것**으로 판단할 수 있다.

---
### Multiple Instance

Banker's 알고리즘과 Deadlock Detection 알고리즘의 가장 큰 차이점은, **Banker's 알고리즘은 Max 값을 기반으로 Deadlock을 예방**하는 반면, **Deadlock Detection 알고리즘은 Max 값을 사용하지 않고 이미 발생한 Deadlock을 탐지**한다는 점이다. 

Banker's 알고리즘에서는 각 프로세스가 사전에 **최대 자원 요구량(Max)을 선언**하고, 요청이 들어올 때마다 시스템이 Safe 상태를 유지할 수 있는지를 검사해 자원 할당 여부를 결정한다. 반면 Deadlock Detection 알고리즘은 **이미 진행 중인 자원 할당 상태만을 바탕으로**, 시스템 내에서 **Deadlock이 발생했는지를 주기적으로 검사**하며, Max 값을 필요로 하지 않는다.

![](../images/Pasted%20image%2020250522002927.png)

`Request`는 어떤 프로세스가 자원을 요청했지만 아직 `Allocation`을 받지 못한 상태를 나타낸다. 단순하게 말하면 이 `Request`를 `Need`처럼 생각하고 Deadlock Detection 알고리즘을 수행하면 된다.

현재 상황에서 추가적인 `Request`가 없다고 가정할 때, 즉 `(0, 0, 0)`인 프로세스는 자원을 더 이상 요청하지 않으므로 직접적으로 Deadlock에 관여하지 않는다고 본다. 이런 프로세스는 곧바로 수행되어 자원을 반납할 수 있으며, 예를 들어 P0와 P2가 자원을 반납하게 되면 그 자원을 바탕으로 이후 다른 프로세스들도 모두 실행될 수 있다. 따라서 이 경우는 Deadlock 상태가 아니다.

##### 만약 P2가 ( 0 0 1 )을 요청하게 된다면?

![](../images/Pasted%20image%2020250522003532.png)

P0가 실행되고 자원을 반납하더라도, 그 다음에 자원을 할당받아 실행할 수 있는 프로세스가 없기 때문에 시스템은 Deadlock 상태에 빠진 것으로 판단된다.

---


> [!note] Deadlock Detection 알고리즘
> 먼저 `Work[1:m]`과 `Finish[1:n]`을 초기화한다. `Work`는 현재 사용 가능한 자원 수인 `Available`로 설정하고, `Finish[i]`는 `Allocation[i] ≠ 0`이면 false, 즉 아직 자원이 할당되어 있고 완료되지 않았다는 의미로 설정하고, 그렇지 않으면 true로 설정한다. 
> 
> 그런 다음 아직 종료되지 않은 프로세스 중에서 `Finish[i] = false`이고 `Request[i] <= Work`인 프로세스를 찾는다. 즉 현재 요청한 자원을 사용할 수 있는 프로세스를 찾는다. 만약 그런 프로세스가 존재하지 않으면 step 4로 이동한다. 
> 
> 조건을 만족하는 프로세스가 있다면, 그 프로세스를 실행 가능한 것으로 판단하고 `Work = Work + Allocation[i]`로 자원을 회수한 뒤, `Finish[i] = true`로 설정하고 다시 step 2로 돌아가 이 과정을 반복한다. 
> 
> 최종적으로 `Finish[i] == false`인 프로세스가 하나라도 존재한다면, 이 프로세스는 자원을 얻지 못하고 대기 중인 상태이며, 시스템은 Deadlock 상태이고 해당 `Pi`는 Deadlock에 빠졌다고 판단한다.

---
## **Deadlock Recovery**

Deadlock 상태에 처해 있는지 판단하는 것은 비교적 쉬운 일이다. 그렇다면 이제 Deadlock을 감지한 뒤, 이를 **어떻게 해결할 것인가**에 대해 살펴보자. 

#### Process termination
가장 단순한 방법은 **프로세스를 강제로 종료시키는 것**이다. 이 중에서도 가장 극단적인 방식은 **Deadlock에 관련된 모든 프로세스를 한 번에 종료하는 것**인데, 이 방법은 시스템에 너무 큰 영향을 미치기 때문에 일반적으로 바람직하지 않다. 
 
보다 현실적인 방식은 **프로세스를 하나씩 종료하면서 Deadlock 상태가 해소되는지 확인하는 방법**이다. 이 방식은 매번 프로세스를 하나씩 종료한 뒤 Deadlock Detection 알고리즘을 반복 수행하여 Deadlock이 풀렸는지 확인한다. 다만, 이 경우에는 **어떤 프로세스를 먼저 종료할 것인가에 대한 판단 기준**이 필요하다. 프로세스마다 우선순위가 다를 수 있고, 얼마나 실행되었는지, 종료까지 얼마나 남았는지, 자원을 얼마나 보유하고 있는지 등 다양한 요소를 고려해야 하므로 매우 복잡한 결정이 된다. 
 
###
또 다른 해결 방법으로는 **Resource Preemption(자원 선점)** 을 통해 Deadlock을 해소하는 방식도 있다. 

그러나 이 방식은 **이미 실행된 작업을 나중에 다시 수행해야 한다는 부담**이 있고, 어느 시점까지 시스템 상태를 되돌릴 것인지, 즉 **Rollback 지점**을 어떻게 설정할 것인지도 중요한 문제다. 또한 자원을 반복적으로 빼앗기는 프로세스는 **기아 상태(Starvation)**에 빠질 수 있으므로, 공정성과 안정성을 고려한 선점 기준이 필요하다.


---
너무 해결하기 어려워서 놀랍게도 대부분의 OS는 Deadlock을 해결하지 않는다. 

전부 해결하지 않는 것은 아니고, OS 커널 내부에서는 prevention 한다. 얼마나 자원을 사용할 지 대충 예측이 가능이 하기 때문이다. 

User - Program 사이의 deadlock은 답이 없다. 그래서 방지도 안 하고 리커버리도 안 한다. 기본적으로는 방지를 안 해주지만, 일부 자원 할당과 관련된 시스템 콜은 내부적으로 deadlock prevention 기능을 가진다. 