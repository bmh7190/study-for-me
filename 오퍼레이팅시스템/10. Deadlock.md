어떤 시스템에 m 개의 resource(R<sub>1</sub>, R<sub>2</sub>, ..., R<sub>m</sub> ) 가 있다고 생각해보자. 각각 resource는 CPU 코어가 될 수도 있고, 메모리 공간이 될 수도 있고, I/O devices가 될 수도 있다.

서로 다른 리소스기 때문에 리소스마다 가지고 있는 instance( W<sub>i</sub> )도 다르다. 각각의 프로세스들은 request use release한다고 생각하자.

---

어떤 프로세스들이 **서로 다른 프로세스가 가진 자원을 기다리는 상태에 놓여 있고**,  이 대기 상태가 **영원히 해결되지 않는 상황**을 **Deadlock(교착 상태)** 이라고 한다.

따라서 Deadlock은 **가장 단순한 경우, 두 개의 프로세스 사이에서도 발생**할 수 있다. 

![](../images/Pasted%20image%2020250521152756.png)


Process 0과 Process 1이 각각 `sem_X`와 `sem_Y`라는 자원을 필요로 하는 상황을 가정하자.  
이때 **Process 0이 먼저 `sem_X`를 획득하고**,  **Process 1이 먼저 `sem_Y`를 획득**했다면, 이후 두 프로세스는 **서로가 가지고 있는 세마포어를 추가로 요구하게 된다.**

즉, **Process 0은 `sem_Y`를 기다리고 있고**,  **Process 1은 `sem_X`를 기다리는 상태**가 되며,  **서로가 서로의 자원을 점유한 채 대기하기 때문에,  이 상태는 해소되지 않고 무한 대기 상태**, 즉 **Deadlock**에 빠지게 된다.

---
## **Deadlock Characterization**

Deadlock은 다음의 **4가지 조건이 모두 만족될 때에만 발생할 수 있다.**

- **Mutual exclusion (상호 배제)**  
    하나의 리소스 인스턴스는 **동시에 하나의 프로세스만 사용할 수 있다.**
    
- **No preemption (비선점)**  
    **한 번 할당된 리소스는** 해당 프로세스가 **자발적으로 반납하기 전까지** 다른 프로세스가 강제로 가져갈 수 없다.
    
- **Hold and wait (보유하며 대기)**  
    **최소 하나의 리소스를 보유한 상태에서**,  **추가적인 리소스를 요청하며 대기**하는 프로세스가 존재해야 한다.
    
- **Circular wait (순환 대기)**  
    각 프로세스가 **다음 프로세스가 점유한 리소스를 기다리는 형태로**,  **원형(고리) 형태의 대기 관계**가 형성되어야 한다.

---
## **Resource-Allocation Graph**


![](../images/Pasted%20image%2020250521153754.png)
프로세스

![](../images/Pasted%20image%2020250521153817.png)
큰 직사각형은 리소스를 나타내며, 큰 직사각형 안에 작은 직사각형들은 인스턴스를 나타낸다.

![](../images/Pasted%20image%2020250521153920.png)
**프로세스 P가 어떤 리소스를 요청할 때는, 프로세스에서 리소스 방향으로 화살표를 그려 표현한다.**

![](../images/Pasted%20image%2020250521154008.png)

프로세스 P가 요청한 리소스의 인스턴스를 실제로 할당받은 경우에는,  해당 인스턴스에서 프로세스 방향으로 화살표를 그려 표현한다.

---
![](../images/Pasted%20image%2020250521154221.png)

왼쪽 그림에서는 **P1, P2, P3가 서로의 자원을 기다리고 있기 때문에**, **Deadlock이 발생한다.**

오른쪽 그림도 겉보기에는 **Deadlock이 발생한 것처럼 보일 수 있지만**,  **P2와 P4는 더 이상 다른 자원을 요청하지 않기 때문에**,  **언젠가는 자신이 점유한 R1과 R2를 반납하게 된다.**

이로 인해 **P1과 P3는 필요한 자원을 얻게 되고**,  결국 **모든 프로세스가 정상적으로 종료될 수 있다.**  따라서 **오른쪽 그림은 Deadlock 상태가 아니다.**

---
## **Deadlock Handling**

Deadlock을 해결하는 방법은 **두 가지 관점**으로 나눌 수 있다.

첫 번째 방법은 **Deadlock을 예방하거나 피하는 것**이다.  하지만 이 방법은 **Deadlock을 완전히 막을 수 있는 보장은 없으며**,  **조금이라도 Deadlock이 발생할 가능성이 있다면 이를 모두 차단해야 하므로**,  **리소스 활용(resource utilization) 측면에서 매우 비효율적일 수 있다.**

두 번째 방법은 **Deadlock이 실제로 발생하는지를 주기적으로 감시하고**,  **발생했을 경우 이를 해결하는 방식**이다. Deadlock을 **탐지하는 과정은 상대적으로 단순**하지만,  **탐지 이후 복구하는 과정은 매우 복잡하고 어려울 수 있다.**

---
## **Deadlock Prevention**

Deadlock이 일어나기 위해서는 반드시 **4가지 조건이 모두 만족**해야 한다.  따라서 이 중 **하나라도 만족되지 않도록 만들면**, Deadlock은 발생하지 않는다.

> **Mutual Exclusion을 없애보면 어떨까?**  

→ 사실 이건 **현실적으로 불가능하다.**  공유 자원이라는 건 **동시에 여러 프로세스가 접근하면 문제가 생기기 때문에**,  상호 배제를 하지 않는 건 **비합리적이다.**

> **Preemption(비선점 조건)을 깨보자!**  

→ 만약 어떤 프로세스가 **하나의 리소스를 보유한 채 다른 리소스를 요청했는데**,  그 요청한 리소스를 **즉시 획득할 수 없다면**,  **현재 보유 중인 리소스들을 모두 반납하도록 강제**한다.  그렇게 반납된 자원은 **다른 대기 중인 프로세스에게 할당**되고,  그 프로세스들이 작업을 마친 후, **원래 프로세스는 자원을 다시 획득하여 재시작**한다.


> **Hold and Wait을 방지해보자!**  

→ **자원을 반드시 한꺼번에 요청**하게 하여,  하나를 보유한 상태에서 **다른 자원을 추가로 요청하지 못하도록** 한다.  즉, 자원을 얻으려면 **모든 자원을 동시에 얻거나**,  
**아예 하나도 얻지 못하고 기다리게** 만드는 것이다.

→ 하지만 이 방식도 **현실성이 떨어진다.**  실제로는 자원이 **순차적으로 필요**한 경우가 많고,  모든 자원을 **사전에 예측해서 요청하는 건 매우 비효율적이다.**  결국 이는 **자원 활용도를 낮추고**, **Starvation(기아 현상)** 을 발생시킬 수 있다.


> **Circular Wait을 깨보자!** 

→ 모든 자원에 **번호를 부여하고**,  프로세스가 자원을 요청할 때는 반드시 **번호 순서대로 요청**하게 한다.  
즉, **낮은 번호 → 높은 번호 순서로만 요청**하도록 제한하는 것이다.  이렇게 하면 **사이클이 형성되지 않기 때문에 Deadlock이 발생하지 않는다.**

→ 하지만 이 방식도 **제약이 많다.**  모든 자원에 **일관된 번호를 부여하는 것 자체도 어려울 뿐더러**,  자원의 번호에 따라 **프로세스 흐름을 제어하는 것도 현실적이지 않다.**

---
## **Deadlock Example**

```c
/* thread one runs in this function */ 
void *do_work_one(void *param){ 
	pthread_mutex_lock(&first_mutex); 
	pthread_mutex_lock(&second_mutex); 
	/** * Do some work */
	pthread_mutex_unlock(&second_mutex); 
	pthread_mutex_unlock(&first_mutex); 
	pthread_exit(0); 
} 
/* thread two runs in this function */ 
void *do_work_two(void *param){ 
	pthread_mutex_lock(&second_mutex); 
	pthread_mutex_lock(&first_mutex); 
	/** * Do some work */
	pthread_mutex_unlock(&first_mutex); 
	pthread_mutex_unlock(&second_mutex); 
	pthread_exit(0); 
} 
```

---
## **Deadlock Avoidance**

그나마 가장 현실성 있는 방법은 Circular wait이 발생하지 않도록 방지하는 것이다. 하지만 아무런 정보 없이 Circular wait을 예방하는 것은 어렵기 때문에, 몇 가지 사전 정보를 기반으로 해야 한다. 

가장 간단하고 활용 가능한 정보는 각 프로세스가 필요한 **각 리소스의 최대 수량**을 미리 알고 있다고 가정하는 것이다. 

Deadlock-avoidance 알고리즘은 현재의 **자원 할당 상태(resource-allocation state)** 를 동적으로 검사하여, **순환 대기(Circular wait)** 조건이 절대 발생하지 않도록 한다. 여기서 자원 할당 상태란, **사용 가능한 자원 수, 이미 할당된 자원 수, 각 프로세스의 최대 자원 요구량**을 모두 포함한 상태 정보를 말한다.

---
## **Banker's Algorithm**

