어떤 시스템에 m 개의 resource(R<sub>1</sub>, R<sub>2</sub>, ..., R<sub>m</sub> ) 가 있다고 생각해보자. 각각 resource는 CPU 코어가 될 수도 있고, 메모리 공간이 될 수도 있고, I/O devices가 될 수도 있다.

서로 다른 리소스기 때문에 리소스마다 가지고 있는 instance( W<sub>i</sub> )도 다르다. 각각의 프로세스들은 request use release한다고 생각하자.

---

어떤 프로세스들이 **서로 다른 프로세스가 가진 자원을 기다리는 상태에 놓여 있고**,  이 대기 상태가 **영원히 해결되지 않는 상황**을 **Deadlock(교착 상태)** 이라고 한다.

따라서 Deadlock은 **가장 단순한 경우, 두 개의 프로세스 사이에서도 발생**할 수 있다. 

![](../images/Pasted%20image%2020250521152756.png)


Process 0과 Process 1이 각각 `sem_X`와 `sem_Y`라는 자원을 필요로 하는 상황을 가정하자.  
이때 **Process 0이 먼저 `sem_X`를 획득하고**,  **Process 1이 먼저 `sem_Y`를 획득**했다면, 이후 두 프로세스는 **서로가 가지고 있는 세마포어를 추가로 요구하게 된다.**

즉, **Process 0은 `sem_Y`를 기다리고 있고**,  **Process 1은 `sem_X`를 기다리는 상태**가 되며,  **서로가 서로의 자원을 점유한 채 대기하기 때문에,  이 상태는 해소되지 않고 무한 대기 상태**, 즉 **Deadlock**에 빠지게 된다.

---
## **Deadlock Characterization**

Deadlock은 다음의 **4가지 조건이 모두 만족될 때에만 발생할 수 있다.**

- **Mutual exclusion (상호 배제)**  
    하나의 리소스 인스턴스는 **동시에 하나의 프로세스만 사용할 수 있다.**
    
- **No preemption (비선점)**  
    **한 번 할당된 리소스는** 해당 프로세스가 **자발적으로 반납하기 전까지** 다른 프로세스가 강제로 가져갈 수 없다.
    
- **Hold and wait (보유하며 대기)**  
    **최소 하나의 리소스를 보유한 상태에서**,  **추가적인 리소스를 요청하며 대기**하는 프로세스가 존재해야 한다.
    
- **Circular wait (순환 대기)**  
    각 프로세스가 **다음 프로세스가 점유한 리소스를 기다리는 형태로**,  **원형(고리) 형태의 대기 관계**가 형성되어야 한다.

---
## **Resource-Allocation Graph**


![](../images/Pasted%20image%2020250521153754.png)
프로세스

![](../images/Pasted%20image%2020250521153817.png)
큰 직사각형은 리소스를 나타내며, 큰 직사각형 안에 작은 직사각형들은 인스턴스를 나타낸다.

![](../images/Pasted%20image%2020250521153920.png)
**프로세스 P가 어떤 리소스를 요청할 때는, 프로세스에서 리소스 방향으로 화살표를 그려 표현한다.**

![](../images/Pasted%20image%2020250521154008.png)

프로세스 P가 요청한 리소스의 인스턴스를 실제로 할당받은 경우에는,  해당 인스턴스에서 프로세스 방향으로 화살표를 그려 표현한다.

---
![](../images/Pasted%20image%2020250521154221.png)

왼쪽 그림에서는 **P1, P2, P3가 서로의 자원을 기다리고 있기 때문에**, **Deadlock이 발생한다.**

오른쪽 그림도 겉보기에는 **Deadlock이 발생한 것처럼 보일 수 있지만**,  **P2와 P4는 더 이상 다른 자원을 요청하지 않기 때문에**,  **언젠가는 자신이 점유한 R1과 R2를 반납하게 된다.**

이로 인해 **P1과 P3는 필요한 자원을 얻게 되고**,  결국 **모든 프로세스가 정상적으로 종료될 수 있다.**  따라서 **오른쪽 그림은 Deadlock 상태가 아니다.**

---
## **Deadlock Handling**

Deadlock을 해결하는 방법은 **두 가지 관점**으로 나눌 수 있다.

첫 번째 방법은 **Deadlock을 예방하거나 피하는 것**이다.  하지만 이 방법은 **Deadlock을 완전히 막을 수 있는 보장은 없으며**,  **조금이라도 Deadlock이 발생할 가능성이 있다면 이를 모두 차단해야 하므로**,  **리소스 활용(resource utilization) 측면에서 매우 비효율적일 수 있다.**

두 번째 방법은 **Deadlock이 실제로 발생하는지를 주기적으로 감시하고**,  **발생했을 경우 이를 해결하는 방식**이다. Deadlock을 **탐지하는 과정은 상대적으로 단순**하지만,  **탐지 이후 복구하는 과정은 매우 복잡하고 어려울 수 있다.**

---
## **Deadlock Prevention**

Deadlock이 일어나기 위해서는 반드시 **4가지 조건이 모두 만족**해야 한다.  따라서 이 중 **하나라도 만족되지 않도록 만들면**, Deadlock은 발생하지 않는다.

> **Mutual Exclusion을 없애보면 어떨까?**  

→ 사실 이건 **현실적으로 불가능하다.**  공유 자원이라는 건 **동시에 여러 프로세스가 접근하면 문제가 생기기 때문에**,  상호 배제를 하지 않는 건 **비합리적이다.**

> **Preemption(비선점 조건)을 깨보자!**  

→ 만약 어떤 프로세스가 **하나의 리소스를 보유한 채 다른 리소스를 요청했는데**,  그 요청한 리소스를 **즉시 획득할 수 없다면**,  **현재 보유 중인 리소스들을 모두 반납하도록 강제**한다.  그렇게 반납된 자원은 **다른 대기 중인 프로세스에게 할당**되고,  그 프로세스들이 작업을 마친 후, **원래 프로세스는 자원을 다시 획득하여 재시작**한다.


> **Hold and Wait을 방지해보자!**  

→ **자원을 반드시 한꺼번에 요청**하게 하여,  하나를 보유한 상태에서 **다른 자원을 추가로 요청하지 못하도록** 한다.  즉, 자원을 얻으려면 **모든 자원을 동시에 얻거나**,  
**아예 하나도 얻지 못하고 기다리게** 만드는 것이다.

→ 하지만 이 방식도 **현실성이 떨어진다.**  실제로는 자원이 **순차적으로 필요**한 경우가 많고,  모든 자원을 **사전에 예측해서 요청하는 건 매우 비효율적이다.**  결국 이는 **자원 활용도를 낮추고**, **Starvation(기아 현상)** 을 발생시킬 수 있다.


> **Circular Wait을 깨보자!** 

→ 모든 자원에 **번호를 부여하고**,  프로세스가 자원을 요청할 때는 반드시 **번호 순서대로 요청**하게 한다.  
즉, **낮은 번호 → 높은 번호 순서로만 요청**하도록 제한하는 것이다.  이렇게 하면 **사이클이 형성되지 않기 때문에 Deadlock이 발생하지 않는다.**

→ 하지만 이 방식도 **제약이 많다.**  모든 자원에 **일관된 번호를 부여하는 것 자체도 어려울 뿐더러**,  자원의 번호에 따라 **프로세스 흐름을 제어하는 것도 현실적이지 않다.**

---
## **Deadlock Example**

```c
/* thread one runs in this function */ 
void *do_work_one(void *param){ 
	pthread_mutex_lock(&first_mutex); 
	pthread_mutex_lock(&second_mutex); 
	/** * Do some work */
	pthread_mutex_unlock(&second_mutex); 
	pthread_mutex_unlock(&first_mutex); 
	pthread_exit(0); 
} 
/* thread two runs in this function */ 
void *do_work_two(void *param){ 
	pthread_mutex_lock(&second_mutex); 
	pthread_mutex_lock(&first_mutex); 
	/** * Do some work */
	pthread_mutex_unlock(&first_mutex); 
	pthread_mutex_unlock(&second_mutex); 
	pthread_exit(0); 
} 
```

---
## **Deadlock Avoidance**

그나마 가장 현실성 있는 방법은 Circular wait이 발생하지 않도록 방지하는 것이다. 하지만 아무런 정보 없이 Circular wait을 예방하는 것은 어렵기 때문에, 몇 가지 사전 정보를 기반으로 해야 한다. 

가장 간단하고 활용 가능한 정보는 각 프로세스가 필요한 **각 리소스의 최대 수량**을 미리 알고 있다고 가정하는 것이다. 

Deadlock-avoidance 알고리즘은 현재의 **자원 할당 상태(resource-allocation state)** 를 동적으로 검사하여, **순환 대기(Circular wait)** 조건이 절대 발생하지 않도록 한다. 여기서 자원 할당 상태란, **사용 가능한 자원 수, 이미 할당된 자원 수, 각 프로세스의 최대 자원 요구량**을 모두 포함한 상태 정보를 말한다.

---
## **Banker's Algorithm**

n개의 프로세스가 있다고 가정하고, 리소스의 종류가 m개라고 할 때, 각 리소스 R_i마다 i번째 리소스에 R_i개의 인스턴스가 존재한다고 가정한다. 

현재 상태에서 어떤 순서로 자원을 각 프로세스에 최대값까지 할당했을 때, 모든 프로세스가 자원을 획득하고 실행한 후 자원을 반납하여 전체 자원을 회수할 수 있는 순서가 존재하는지를 확인하는 것이 핵심이다. 이러한 자원 할당 순서를 **safe sequence**라고 하며, 이는 Deadlock 없이 자원을 안전하게 회수할 수 있도록 보장해준다. 

만약 j < i일 때, 프로세스 P<sub>i</sub> 가 원하는 자원을 즉시 획득할 수 없다면 P<sub>i</sub> 는 먼저 실행되는 프로세스 P<sub>j</sub> 가 종료될 때까지 기다린다. 이후 P<sub>j</sub> 가 종료되어 자원을 반환하면, P<sub>i</sub>는 자원을 획득하고 실행한 후 자원을 다시 반환한다. 그리고 P<sub>i</sub>가 종료되면, 다음 프로세스도 동일한 방식으로 자원을 획득하고 실행하며, 이러한 방식으로 모든 프로세스가 안전하게 실행될 수 있다.

safe sequence가 하나라도 있으면 safe state에 있다고 하고, 하나라도 없으면 unsafe state에 있다고 한다. deadlock을 이어질 수도 잇는거지..

![](../images/Pasted%20image%2020250521224321.png)

모든 프로세스가 자신의 **최대 자원 사용량을 사전에 알려준다고 가정**하고, 각각의 프로세스는 자원을 요청하거나 wait할 수 있다고 가정한다. 이때 시스템은 현재 상태가 **unsafe state로 진입할 가능성이 있다면**, 해당 요청을 거부하고 프로세스를 **대기 상태로 전환시킬 수 있다.** 또한 각 프로세스가 **필요한 자원을 모두 할당받은 경우에는**, 해당 프로세스는 반드시 **한정된 시간 내에 실행을 완료하고 자원을 반환해야 한다.** 

---
> [!note] Notation
> n은 프로세스의 수, m은 자원 타입의 수라고 가정
> 
> `Available[1:m]` : 각 자원 타입별로 **현재 사용 가능한 자원의 수**
> 
> `Max[1:n, 1:m]` : 각 프로세스가 **최대 얼마까지 자원을 요구할 수 있는지**를 나타내는 행렬
> 
> `Allocation[1:n, 1:m]` : **현재 각 프로세스에 할당된 자원의 수**
> 
> `Need[1:n, 1:m]` : 각 프로세스가 앞으로 **얼마나 더 자원이 필요한지를 나타내는 값**으로, 각 항목은 `Need[i, j] = Max[i, j] - Allocation[i, j]`로 계산  
> 즉, `Max[i, j] = Allocation[i, j] + Need[i, j]` 관계가 항상 성립

Safety Alogorithm -> 현재 safe state에 있는지 판단하는 알고리즘
Resource-Request Alogorithm -> 어떤 resource request가 있을 때 이를 허가해도 되는지 판단

---
## **Safety Alogrithm**

![](../images/Pasted%20image%2020250521230331.png)

![](../images/Pasted%20image%2020250521230802.png)

Need는 `Max - Allocation`으로 계산하며, 이 값을 기반으로 현재 Available 자원으로 어떤 프로세스가 실행 가능한지 판단한다. 위 그림에서 먼저 P1과 P3가 실행 가능한 상태이며, 여기서 P1을 선택해 실행하면, 실행이 끝난 뒤 P1에 할당됐던 자원을 Available에 반납하게 된다.

![](../images/Pasted%20image%2020250521231057.png)

다시 Need를 확인하면 P3와 P4가 실행 가능한데, Need가 Available보다 작거나 같기 때문이다. 이 중 P3를 선택하고 실행을 완료하면, 마찬가지로 P3의 Allocation이 Available에 더해진다.

![](../images/Pasted%20image%2020250521231254.png)

이 과정을 반복해 모든 프로세스가 실행되고 종료될 수 있다면, 이는 시스템이 safe sequence를 가지고 있다는 의미이며, Deadlock은 발생하지 않는다. 다음 단계부터는 모든 프로세스가 Need ≤ Available을 만족하므로, 어떤 순서로든 자원을 할당해도 Deadlock이 발생하지 않는다.

---
> [!note] Safety Algorithm
> 1. `Work[1:m]`과 `Finish[1:n]`을 초기화한다. 이때 `Work`는 현재 사용 가능한 자원 수인 `Available`로 설정하고, 모든 `Finish[i]`는 false로 초기화한다. 
> 
> 2. 그런 다음 아직 종료되지 않은 프로세스 i 중에서 `(a) Finish[i] = false`이고 `(b) Need[i] <= Work`인 프로세스를 찾는다. 만약 그런 프로세스가 존재하지 않으면 step 4로 간다. 
> 
> 3. 해당 조건을 만족하는 프로세스 i가 있다면, 그 프로세스를 실행 가능한 것으로 판단하고 `Work = Work + Allocation[i]`로 자원을 회수하고, `Finish[i] = true`로 설정한 후 다시 step 2로 돌아가 이 과정을 반복한다. 
> 
> 4. 최종적으로 모든 `Finish[i]`가 true가 되면, 즉 모든 프로세스가 안전하게 실행될 수 있다면 시스템은 safe state에 있는 것이다.


---
## **Banker's Algorithm - Resource - Request Alogrithm**

내가 Resource-Request를 들어줬다고 가정하고, 그 결과 시스템이 unsafe state로 판단된다면, 해당 요청은 허용해서는 안 된다. 이 판단은 앞서 정리한 safety algorithm을 그대로 사용해 수행한다.

![](../images/Pasted%20image%2020250521232119.png)

P0가 (0, 2, 0)을 요청했다고 가정하면, 요청을 수락했을 때 P0의 Allocation은 ( 0, 1, 0 )에서 (0, 3, 0)이 되고, 그만큼 자원을 사용했으므로 Available은 기존 (5, 3, 2)에서 (5, 1, 2)로 감소한다.

![](../images/Pasted%20image%2020250521232428.png)

상태에서 safety algorithm을 적용해 보면, 모든 프로세스가 종료 가능한 safe sequence가 존재한다. 따라서 이 요청은 시스템을 unsafe state로 만들지 않기 때문에, 해당 request를 **허용해도 된다**는 결론을 내릴 수 있다.

> [!note] Resource-Request Algorithm
> 먼저 요청 벡터 `Request i`가 `Needi`보다 작거나 같은지 확인한다. 만약 그렇지 않다면, 이는 Pi가 최대 자원 요구량을 초과한 것이므로 오류를 발생시킨다. 
> 
> 다음으로 `Request i`가 `Available`보다 작거나 같은지 확인한다. 작거나 같다면 현재 사용 가능한 자원으로 요청을 처리할 수 있다는 의미이고, 그렇지 않다면 Pi는 자원이 충분히 돌아올 때까지 기다려야 한다. 
> 
> 조건을 모두 만족하면, 요청된 자원을 Pi에게 할당한다고 가정하고 상태를 임시로 변경한다. 
> 
> `Available = Available - Requesti`
> `Allocationi = Allocationi + Requesti`
> `Needi = Needi - Requesti`
> 
> 임시로 변경한 뒤  safety algorithm을 실행해 시스템이 safe state인지 확인한다. 
> 
> 만약 이 상태가 안전하다면 Pi에게 자원을 실제로 할당한다. 반면, 이 상태가 unsafe하다면 Pi는 자원을 기다려야 하며, 위에서 변경한 자원 상태는 원래대로 복구된다.

실제로 이 알고리즘을 사용하는 것은 어렵다. 그 이유는 처음에 가정하는 자원의 수나 프로세스의 수가 **동적으로 변할 수 있기 때문**이며, 특히 **각 프로세스가 자신의 최대 자원 요구량(Max)을 정확히 예측해야 한다는 전제 자체가 현실적으로 매우 어렵다.** 모든 프로세스가 시작 전에 자원 사용량을 약속하고, 그 범위를 벗어나지 않는다는 것은 이상적일 뿐이다. 

또한 자원 할당을 위해 wait이 필요한 상황이 자주 발생하며, 이 경우 프로세스가 **무기한으로 기다리게 될 수도 있다.** 

게다가 이 알고리즘은 매우 보수적인 접근을 취한다. **safe state를 유지하려는 목적 때문에 자원 할당 자체를 제한적으로 수행하게 되고**, 프로세스들도 Max 값을 보수적으로 낮게 설정하게 되며, 결과적으로 **resource utilization이 낮아지는 문제**가 발생한다.

---
## **Deadlock Detection**

각각의 리소스 종류마다 인스턴스가 하나만 있는 경우에는 그래프를 그렸을 때 사이클이 생기면 데드락이 무조건 생긴다. 그러나 인스턴스가 여러개인 경우 그래프를 그려서 판단하는 경우 너무 복잡하기 때문에 ㄹ deadlock detection 알고리즘을 사용해서 데드락이 생겼는지 파악한다.