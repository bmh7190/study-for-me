---

---

---

## **Computer Hardware**

CPU와 디바이스 컨트롤러는 **시스템 버스(System Bus)** 를 통해 연결되며, 시스템 버스는 컴퓨터의 주요 구성 요소 간 데이터 및 명령어 전송을 담당한다.  

![](../images/Pasted%20image%2020250406003003.png)

시스템 버스는 **데이터 버스(Data Bus), 주소 버스(Address Bus), 제어 버스(Control Bus)** 로 나뉘며,

- **데이터 버스**는 데이터를 주고받고,
- **주소 버스**는 메모리 및 I/O 장치의 주소를 지정하며,
- **제어 버스**는 읽기(Read) 및 쓰기(Write) 등의 제어 신호를 전달한다.


> [!note]
> Bus Arbiter(버스 중재기)
> 여러 개의 버스 요청이 있을 때, **충돌을 조정하고 우선순위를 결정**하는 역할을 한다.
> 
> Bus Master(버스 마스터) 
> 버스 요청 신호를 보내고, 버스 트랜잭션을 시작할 수 있는 장치**이다. (예: CPU, DMA 컨트롤러)
> 
> Bus Slave(버스 슬레이브) 
> 버스 마스터의 명령을 받아 해당 요청을 수행하는 장치이다. (예: 메모리, I/O 장치)


---
## **I/O Operations**

**I/O Controller**는 **CPU 명령에 따라 I/O 작업**을 수행한다.
I/O 컨트롤러에는 **여러 종류의 레지스터**가 있다:
    
- **Data Registers**: 입력 및 출력을 위한 데이터 레지스터
- **Control Registers**: 제어와 상태 정보를 저장하는 레지스터

##### ✅ I/O 작업 수행 과정

1. **I/O 작업은 CPU에 의해 시작된다**.  예를 들어, **출력 작업**을 수행한다고 할 때 상태 레지스터(Status Register)를 읽어 **출력 레지스터(Output Register)**가 사용 가능한지 확인한다.
    
2. 만약 **출력 레지스터가 사용 가능**하다면 **출력 데이터**를 **출력 레지스터에 이동**시킨다. **출력 명령**을 **제어 레지스터(Control Register)** 에 기록한다.
        
3. 만약 **출력 레지스터가 사용 불가능**하다면 이 과정을 **반복**하거나, **출력 레지스터가 사용 가능할 때까지 대기**한다.

##### ✅ Polling I/O vs. Interrupt-driven I/O

1. **Polling I/O**:
    
    - **CPU는 I/O 상태 레지스터를 계속 확인**하여 I/O 작업이 완료되었는지 점검한다.
        
    - **장점**: 구현이 간단하고 직관적이다.
        
    - **단점**: **CPU 자원을 낭비**하게 된다. CPU는 작업을 처리하는 대신, I/O 상태를 확인하기 위해 반복적으로 체크해야 한다.
        
2. **Interrupt-driven I/O**:
    
    - **I/O 컨트롤러가 작업을 마친 후 CPU에 인터럽트를 발생**시켜 I/O 작업이 완료되었음을 알린다.
        
    - **장점**: **CPU 자원을 효율적으로 사용**할 수 있다. CPU는 다른 작업을 수행하다가, I/O 작업이 끝나면 인터럽트를 통해 알림을 받는다.
        
    - **단점**: 인터럽트 처리 로직이 필요하고, 인터럽트 처리에 따른 **오버헤드**가 있을 수 있다.
        

##### ✅ Memory-mapped I/O vs. Port-mapped I/O

1. **Memory-mapped I/O**:
    
    - **I/O 장치도 메모리 주소 공간 내의 일부로 매핑**된다.
        
    - **메모리와 I/O 장치가 동일한 주소 공간을 공유**하여, 메모리 접근 방식으로 I/O 작업을 처리할 수 있다.
        
    - **장점**: I/O 작업을 처리할 때 메모리 접근 방식으로 **일관된 접근 방식**을 사용하므로, 처리 속도가 빠르고 직관적이다.
        
2. **Port-mapped I/O**:
    
    - **I/O 장치는 별도의 주소 공간**을 사용하여 매핑된다.
        
    - **I/O 장치와 메모리가 별도의 주소 공간**을 갖기 때문에, I/O 작업을 처리할 때 **특정 포트**를 이용해 데이터를 주고받는다.
        
    - **장점**: 메모리 공간과 I/O 장치 공간을 분리하여, 메모리 관리가 간편해진다.
        
    - **단점**: 메모리 공간과 I/O 공간을 따로 관리해야 하므로 **주소 공간이 분리**되어 조금 더 복잡할 수 있다.
    
---
## **DMA**

**DMA**는 **장치 컨트롤러**가 **CPU의 개입 없이**,  **버퍼 저장소와 메인 메모리 사이에서 데이터를 직접 전송**할 수 있도록 하는 방식이다.
    
- **장점**:
    
  **CPU 개입 없이** 데이터를 전송할 수 있으므로, **CPU의 부하**를 줄여준다.
        
  **하나의 인터럽트**만 발생하며, **매 바이트마다 인터럽트가 발생**하는 기존의 방식보다 효율적이다.  
  → 예를 들어, 한 번의 **블록 전송에 대해 하나의 인터럽트만 발생**한다.
        
- **사용되는 경우**:
    
  **고속 I/O 장치**가 있을 때 유용하다.  
  → 예를 들어, **메모리 속도에 근접한 속도로 데이터를 전송할 수 있는 장치**에서 사용된다.
        
---
## **Interrupts Mechanism**

#### interrupt 란?
하드웨어가 **Interrupt service routine (ISR)** 으로 제어를 넘기는 메커니즘으로,  **Interrupt Vector**를 통해 이루어진다.  

Interrupt Vector는 **모든 서비스 루틴의 주소를 저장한 테이블**로, 특정 Interrupt가 발생하면 해당 **서비스 루틴의 주소를 찾아 실행**하는 역할을 한다.

즉, Interrupt가 발생하면 CPU는 **Interrupt Vector Table** 을 참조하여 적절한 서비스 루틴을 실행하는 방식이다.

#### Trap or exception
소프트웨어에 의해 생성되는 **인터럽트(Interrupt)** 로, **오류(Error) 또는 사용자 요청(User Request)에 의해 발생**한다.

- **오류(Error)에 의한 트랩**: 0으로 나누기(Divide by Zero), 잘못된 메모리 접근(Segmentation Fault) 등
- **사용자 요청(User Request)에 의한 트랩**: 시스템 호출(System Call), 디버깅(Debugging Breakpoint) 등

즉, **트랩(Trap)과 예외(Exception)은 소프트웨어적으로 발생하는 인터럽트**이며, CPU는 이를 처리하기 위해 **인터럽트 핸들러(Interrupt Handler) 또는 예외 핸들러(Exception Handler)를 호출**한다.

---
## **Interrupt Handling**

운영체제(OS)는 **컨텍스트 스위칭(Context Switching)** 이나 **인터럽트 처리** 시, **CPU의 상태와 프로그램 카운터(Program Counter, PC)를 저장**해야 한다. 이를 위해 **레지스터를 저장하는 방식**을 사용한다.

1. **현재 실행 중인 프로그램의 수행을 멈춘다.**
    - 현재 실행 중인 명령어까지는 수행되고, 멈춘다.
    
2. **중지된 기능(프로그램)의 주소(현재 PC, 레지스터 값)를 저장한다.**
    - CPU는 **프로그램 카운터(PC)** 와 레지스터 상태를 **스택(Stack) 또는 PCB(Process Control Block)** 에 저장하여 이후 복원할 수 있도록 함.
    
3. **인터럽트 벡터 테이블(Interrupt Vector Table, IVT)을 사용하여 ISR(Interrupt Service Routine)의 주소를 가져온다.**
    - 인터럽트 요청(Interrupt Request Number, IRQ)에 해당하는 ISR의 주소를 찾음.
    - IVT에는 다양한 인터럽트 요청에 대한 **ISR의 주소 목록**이 저장되어 있음.
    
4. **ISR로 점프하여(이동하여) 실행한다.**
    - CPU가 **해당 ISR(인터럽트 서비스 루틴)으로 점프(jump)하여 인터럽트를 처리**함.

이후 ISR 실행이 끝나면, CPU는 저장된 **PC 및 레지스터 상태를 복원**한 후, 원래 수행 중이던 프로그램으로 돌아간다.

**인터럽트 처리 중 새로운 인터럽트가 발생하면, 현재 인터럽트가 정상적으로 처리되지 않을 수 있다.** **인터럽트가 중첩되면(CPU가 새로운 ISR로 계속 점프하면) 원래의 인터럽트 처리가 완료되지 않아 "Lost Interrupt(손실된 인터럽트)" 문제가 발생할 수 있다.** 이를 방지하기 위해, CPU는 **현재 인터럽트 처리 중에는 추가적인 인터럽트를 일시적으로 비활성화**한다.


![](images/Pasted%20image%2020250312214906.png)


- **I/O Request 발생**
	사용자 프로세스가 실행 중인 동안 **I/O 요청**이 발생한다. 이때, CPU는 계속 실행되지만, I/O 디바이스는 요청을 받고 데이터 전송을 시작한다.
    
- **I/O Interrupt 발생 및 ISR 실행**
	I/O 디바이스가 데이터를 다 읽었다면 **인터럽트를 발생시켜 CPU에 알린다.** CPU는 현재 실행 중인 사용자 프로세스를 잠시 중단하고, **인터럽트 서비스 루틴(ISR, Interrupt Service Routine)** 을 실행한다.  ISR에서는 I/O 작업이 완료된 데이터를 실제 메모리로 옮긴다.
    
- **ISR이 끝난 후 원래 작업 복귀**
    - 인터럽트 처리가 완료되면, CPU는 원래 실행 중이던 사용자 프로세스로 돌아간다.


여기서  ISR의 역할은 **I/O 완료 처리를 수행하고, 필요하면 추가적인 작업을 요청하는 것**이라고 할 수 있지!

---
## **OS Service**

services provide fucntions that are helpful to the user

1. User interface 
2. Program execution
3. I/O operation
4. File-system manipulation
5. Communications
6. Error detection

other services exist for ensuring the efficient operation of the system itselt via resource sharing

1. Resource allocation
2. Accounting
3. Protection and security


---
## **System Calls**

운영체제가 제공하는 서비스에 접근하는 프로그래밍 인터페이스는 주로 **고수준 API(High-Level API)를 통해 사용되며**, 시스템 호출(System Call)을 직접 사용하는 경우는 많지 않다.

대체적으로 각 **시스템 호출(System Call)** 에는 고유한 번호가 부여되며, **시스템 콜 인터페이스(System Call Interface)** 는 이러한 번호를 매핑한 테이블로 구성된다.

시스템 콜 인터페이스는 운영체제(OS) 커널에서 해당 시스템 호출을 실행하고, 그 결과와 상태 정보를 반환한다.

시스템 호출이 내부적으로 어떻게 동작하는지는 호출하는 프로그램(caller)이 알 필요가 없으며, 단순히 **API를 따르고, 운영체제가 시스템 호출을 통해 어떤 작업을 수행하는지만 이해하면 된다.**


---
## **User mode VS Kernel mode**

운영체제는 하드웨어의 지원을 받아 최소한 두 가지 운영 모드를 구별하여 **시스템 보호 및 안정성을 보장**합니다.

1. User mode
	1. User에 의해 실행된다. 
2. Kernel mode
	1. OS에 의해 수행된다.
	2. kerne mode에서 수행하고 있을 때, OS는 kernel과 user의 메모리에 대한 접근의 제한을 푼다.

컴퓨터 하드웨어에는 **모드 비트(Mode Bit)** 가 추가되며, 특히 **프로세서 상태(Processor Status)** 에 포함된다.
- kernel mode : 0
- user mode : 1

**인터럽트(Interrupt) 또는 트랩(Trap)이 발생하면, 하드웨어는 자동으로 커널 모드(Kernel Mode)로 전환된다.** **커널 모드에서는 특권 명령(Privileged Instructions)을 실행할 수 있다.**

---
## **OS Design and Implementation**

OS의 디자인과 구현은 단순히 해결할 수 있는 문제가 아니라, 여러 접근 방식을 통해 단계적으로 해결되어야 한다. 다양한 운영체제의 내부 구조는 매우 다르기 때문에, 각 운영체제의 목표와 요구 사항에 따라 설계가 달라진다. 디자인은 명확한 목표와 사양을 정의하는 것으로 시작된다.


하드웨어 선택과 시스템의 종류는 OS 설계에 중요한 영향을 미친다. 예를 들어, 리소스가 제한된 임베디드 시스템에서는 경량화된 OS가 필요하고, 대형 서버에서는 확장성과 안정성을 강조한 OS가 필요할 것이다.

유저의 목표와 시스템의 목표는 종종 다르다. 유저는 OS가 사용하기 쉽고, 배우기 쉬우며 신뢰할 수 있고 안전하고, 빠르기를 원한다. 반면 시스템 측에서는 OS가 설계와 구현, 유지 관리가 용이하고, 유연하며 신뢰성이 높고, 오류가 없으며, 효율적인 성능을 제공해야 한다.

따라서 운영체제를 설계할 때는 사용자 요구 사항과 시스템 요구 사항을 균형 있게 반영해야 한다.

---


---
## **OS Structure**

1. Simple Structure ( MS-DOS )
	MS-DOS는 **메모리 사용을 최소화하면서도 최대한의 기능을 제공하는 설계**였지만, **모듈화 부족과 명확한 계층 구조의 부재로 인해 현대 운영체제에 비해 구조적으로 복잡하고 유지보수가 어려웠음**. 
	모놀리 식 구조이다. 즉 OS 전부 하나의 프로그램만 돌릴 수 있다. 또 커널과 유저의 구분이 명확하지 않았다.
	![](../images/Pasted%20image%2020250406170235.png)
	
2.  More Complex (initial unix)
	모놀리식 구조이다.
	UNIX는 두 개의 분리 가능한 부분으로 구성된다.
    - **시스템 프로그램(System Programs)**  
		시스템 프로그램은 사용자와 시스템 간의 인터페이스를 제공하며, 파일 관리나 프로세스 관리를 돕는 유틸리티 프로그램들을 포함한다. 이 프로그램들은 대부분 사용자 모드에서 실행된다.
    
	- **커널(Kernel)**
	   커널은 시스템 호출 인터페이스 아래에서 물리적 하드웨어 위에 위치하며 파일 시스템, CPU 스케줄링, 메모리 관리 및 기타 운영체제 기능을 제공한다.
	   모든 코드가 메모리에 다 올라가기 때문에 수정과 디버그에 어려움이 있다.
	![](../images/Pasted%20image%2020250406170411.png)

3. Layered Approach
    OS는 몇 개의 계층으로 나누어진다. 아래 계층으로 갈 수록 하드웨어와 가깝고 위 계층으로  갈 수록 user interface에 가깝다.
    모듈화(Modularity)를 통해, 각 계층은 오직 하위 계층의 기능(연산)과 서비스만을 사용하도록 설계된다.
	![](../images/Pasted%20image%2020250406170559.png)

4. Microkernel
	OS는 kernel에서 필수적이지 않은 구성 요소들을 모두 제거하고, 그 요소들은 user-level 프로그램으로서 수행한다. ex) MAC
	사용자  모듈 간의 통신은 메세지 전달(Message Passing) 방식을 사용한다.
	![](../images/Pasted%20image%2020250406170708.png)

	장점 
	- 마이크로커널 확장에 용이
	- 운영체제를 새로운 아키텍쳐로 이식하기 쉬움
	- 더 높은 신뢰성 -> kernel에서 돌아가는 코드의 양이 적어지다 보니..
	- 더 높은 보안성
	
	단점 
	- 사용자 공간과 커널 공간 사이의 통신으로 인한 성능 오버헤드


5. Modules
	많은 현대 운영체제는 **로드 가능한 커널 모듈(LKM)** 방식을 구현한다.
	- **객체지향적(Object-Oriented) 접근 방식을 사용**
	- **각 핵심 구성 요소(Core Component)는 독립적으로 존재**
	- **모듈 간의 통신은 정의된 인터페이스(known interfaces)를 통해 이루어짐**
	- **필요할 때 커널 내에서 동적으로 로드 및 언로드 가능**
	- **계층 구조(Layered Structure)와 유사하지만 더 유연함**
	
6.  Hybrid Systems
    현대의 운영체제는 단일한 순수 모델을 사용하지 않는다. 대신 하이브리드 모델을 채택하여 성능, 보안, 사용성 요구를 모두 충족하려고 한다.
    
	**리눅스(Linux)** 와 **솔라리스(Solaris)**:
    
    - **커널 주소 공간**에서 **모놀리식 커널(Monolithic Kernel)**을 사용하면서,
    - **모듈화(Modular)**되어 있어, 필요한 기능을 **동적으로 로딩**할 수 있다.
        
    **윈도우(Windows)**:
    
    - 대부분 **모놀리식 커널**을 사용하지만,
    - **마이크로커널(Microkernel)** 방식도 도입되어, 다양한 서브시스템의 성격을 관리한다.
        
    **애플 macOS X**:
    
    - **하이브리드 모델**을 사용하며, **계층형(Layered)** 구조로 **Aqua UI**와 **Cocoa 프로그래밍 환경**을 제공한다.
    - **Mach 마이크로커널**과 **BSD 유닉스** 파트, **I/O Kit**, **동적으로 로드 가능한 모듈**(Kernel Extensions)로 구성된다.