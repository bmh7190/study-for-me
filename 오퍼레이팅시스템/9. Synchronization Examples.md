동기화의 고전적인 문제점은 Bounded-Buffer Problem, Readers and Writers Problem, Dining-Philosophers Problem 등이 있다.

---
## **Bounded-Buffer Problem**

Producer
```c
while (true) {
	/* produce an item in next produced */ 
	while (counter == BUFFER_SIZE) ; 
	/* do nothing */ 
	buffer[in] = next_produced; 
	in = (in + 1) % BUFFER_SIZE; 
	counter++; 
	}
```

Consumer
```c
while (true) {
	while (counter == 0);
	/* do nothing */ 
	next_consumed = buffer[out]; 
	out = (out + 1) % BUFFER_SIZE; 
	counter--; 
	/* consume the item in next consumed */ 
}
```

프로듀서는 버퍼 사이즈를 보고 가득 차기 전까지 버퍼 안에 데이터를 넣고, 손님은 버퍼에 비어 있는지 확인을 하면서, 비어 있지 않다면, 버퍼에서 데이터 하나를 꺼내서 소비한다.

여기서 counter 변수는 atomic하게 이뤄지지 않으므로, 만약 Producer와 Consumer가 동시에 counter 변수에 접근하면 문제가 생긴다!

---


> [!note] 사용 변수
> `int buffer size` = n
> `semaphore mutex` : buffer 접근에 대한 mutex exclusion 보장하며, 초기값은 1
> `semaphore full` : n 개 중에 몇 개가 사용중인지를 나타내며, 처음엔 0으로 초기화
> `semaphore empty` : n개 의 버퍼 공간 중에 비어있는 공간을 수를 말하며, n을 초기화
> 

Pr
```c
do {
	…
	/* produce an item in next_produced */
	…
	wait(empty);
	wait(mutex);
	…
	/* add next_produced to the buffer */
	…
	signal(mutex);
	signal(full);
} while (true);
```


