동기화의 고전적인 문제점은 Bounded-Buffer Problem, Readers and Writers Problem, Dining-Philosophers Problem 등이 있다.

---
## **Bounded-Buffer Problem**

Producer
```c
while (true) {
	/* produce an item in next produced */ 
	while (counter == BUFFER_SIZE) ; 
	/* do nothing */ 
	buffer[in] = next_produced; 
	in = (in + 1) % BUFFER_SIZE; 
	counter++; 
	}
```

Consumer
```c
while (true) {
	while (counter == 0);
	/* do nothing */ 
	next_consumed = buffer[out]; 
	out = (out + 1) % BUFFER_SIZE; 
	counter--; 
	/* consume the item in next consumed */ 
}
```

프로듀서는 버퍼 사이즈를 보고 가득 차기 전까지 버퍼 안에 데이터를 넣고, 손님은 버퍼에 비어 있는지 확인을 하면서, 비어 있지 않다면, 버퍼에서 데이터 하나를 꺼내서 소비한다.

여기서 counter 변수는 atomic하게 이뤄지지 않으므로, 만약 Producer와 Consumer가 동시에 counter 변수에 접근하면 문제가 생긴다!

---


> [!note] 사용 변수
> `int buffer size` = n
> `semaphore mutex` : buffer 접근에 대한 mutex exclusion 보장하며, 초기값은 1
> `semaphore full` : n 개 중에 몇 개가 사용중인지를 나타내며, 처음엔 0으로 초기화
> `semaphore empty` : n개 의 버퍼 공간 중에 비어있는 공간을 수를 말하며, n을 초기화
> 

##### Producer Process

```c
do {
	…
	/* produce an item in next_produced */
	…
	wait(empty);
	wait(mutex);
	…
	/* add next_produced to the buffer */
	…
	signal(mutex);
	signal(full);
} while (true);
```


`wait(empty)`는 빈 공간이 생길 때까지 기다리는 역할을 한다. 처음에는 `empty = n`이므로 바로 통과할 수 있고, 통과하면서 `empty` 값은 1 감소한다. 빈 버퍼가 있다는 것을 확인했으니 이제 실제로 사용하기 위해 buffer에 접근해야 하는데, buffer는 공유 자원이기 때문에 mutex를 통해 상호 배제를 보장해야 한다.

따라서 `wait(mutex)`를 호출해 mutex를 획득하고, 임계 구역에 들어가 buffer에 `next_produced` 항목을 추가한다. 버퍼 사용이 끝났다면 `signal(mutex)`를 호출하여 mutex를 반납하고, `signal(full)`을 통해 사용 중인 슬롯 수를 1 증가시킨다. 

이 과정은 반복적으로 수행되며, 버퍼가 가득 찰 때까지 n번 반복될 수 있다.

---

##### Consumer Process

```c
do {
	wait(full);
	wait(mutex);
	…
	/* remove an item from buffer to next_consumed */
	…
	signal(mutex);
	signal(empty);
	…
	/* consume the item in next consumed */
	…
} while (true);
```

`wait(full)`을 통해 버퍼에 채워진 데이터가 있는지 확인하고, 통과하면서 `full` 값을 1 감소시킨다. 이후 `wait(mutex)`를 호출하여 buffer에 접근하기 위한 상호 배체를 확보한다. mutex를 획득한 상태에서 최소한의 작업, 즉 버퍼에서 아이템을 꺼내 `next_consumed`에 저장하는 작업만 수행하고, 바로`signal(mutex)`를 통해 mutex를 반납한다. 

그런 다음 `signal(empty)`를 호출하여 버퍼에 비어 있는 슬롯 수를 1 증가시킨다. 이후에는 `next_consumed`에 담긴 항목을 실제로 소비하는 작업을 수행하고, 이 과정을 계속 반복하게 된다.

---
## **Readers-Writers Problem**

앞서 Producer와 Consumer는 1:1의 관계로 생각했지만, 이번 문제에서는 **다대다(many-to-many)** 관계에 놓여 있다고 볼 수 있다. 이 문제에서는 **공유 데이터를 접근하는 프로세스들이 두 종류**로 나뉘는데, **공유 데이터를 수정하려는 프로세스를 Writer**, **읽기만 하는 프로세스를 Reader**라고 한다.

**Readers**는 공유 데이터를 **읽기만 하며 수정하지 않기 때문에**, **여러 Reader가 동시에 접근해도 문제가 없다.**  즉, **Reader 간에는 병행 접근이 허용된다.**

반면, **Writers**는 공유 데이터를 **읽고 쓰는 작업 모두를 수행**하기 때문에,  **데이터의 일관성을 위해 동시간대에 하나의 Writer만 접근할 수 있어야 하며,**  **이때는 Reader들도 접근해서는 안 된다.**

> [!note] 공유 변수
> 데이터
> Semaphore `rw_mutex` : 하나의 Writer만 접근하도록 하는 mutex, 초기값 1
> Int `read_count` : 몇 명의 Reader 들이 접근했는지 확인 용 변수, 초기값 1
> Semaphore `mutex`: read_count 접근 통제를 위한 mutex, 초기값 1

##### Writer Process
```c
do {
	wait (rw_mutex);
	/* writing is performed */
	signal(rw_mutex);
} while (true);
```

`rw_mutex`는 공유 데이터에 대한 **Writer의 상호 배제(Mutual Exclusion)**를 보장하기 위한 세마포어이다.  `wait(rw_mutex)`를 통해 세마포어 값을 확인하고, 값이 1이면 **-1 하면서 통과**하고 진입한다.  
만약 값이 0이라면 이미 다른 Writer 또는 Reader들이 사용 중이므로 **진입하지 못하고 대기**하게 된다.

진입에 성공하면 공유 데이터를 수정하는 작업을 수행하고,  작업이 끝난 후에는 `signal(rw_mutex)`를 호출하여 **세마포어 값을 1 증가시키고 반납**,  다음 Writer 또는 Reader가 접근할 수 있도록 한다.

##### Reader Process

```c
do {
	wait(mutex);
	read_count++;
	if (read_count == 1)
		wait(rw_mutex);
	signal(mutex);
	/* reading is performed */
	wait(mutex);
	read_count--;
	if(read_count == 0)
		signal(rw_mutex);
	signal(mutex);
} while (true);
```

읽기 위해서 read_count를 증가시켜야 하기 때문에, 공유 변수인 read_count를 변경하기 위한 mutex 획득한다. 만약 증가시킨 read_count가 1이라면 자신이 처음 Reader거나 Writer가 수정이거나 둘 중 하나인다. 그래서 wait(rw_mutex)를 통해서 지금 Writer가 수정 중인지 확인하고, 만약 수정 중이 아니라면 다음 코드를 실행 시킬 수 있게 되는 것이다. mutex를 반납하고 다른 사람 읽으러 오세요~ 하고 reading 을 한다. 

만약 rw_mutex에서 잠궈져 있다면,  signal(mutex)를 못 하기 때문에 그 뒤로 들어오는 Reader들은 알아서 접근이 제한된다. 

다 읽었다면, 프로세스는 나가야 하고, read_count를 줄여야 하기 때문에 공유 변수 접근을 위해 wait(mutex)를 하고 