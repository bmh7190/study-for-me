 
프로세스란 무엇일까? 

> [!note]
> 실행 중인 프로그램
> 특정 프로세스 상태 내에서 실행되는 흐름

**프로세스 상태**( Process State )는 **프로세스에 영향을 줄 수 있고 영향을 받을 수 있는 모든 것**을 포함한다.  예를 들어 **코드(Code)** , **데이터 값(Data values)**, **열린 파일(Open files)**  등이 있다.

**실행 흐름**은 **프로세스 상태** 내에서 **수행되는 연속적인 명령어들**로 구성된다. 이는 **순차적으로 실행되는 명령어들**로, 프로세스의 코드에 의해 **제어되며** 해당 프로세스 상태 내에서 **하나의 흐름을 만든다**.
        
**프로세스 내에서는 한 번에 하나의 작업만 실행**되며, 여러 작업이 동시에 이루어지지 않는다.  **한 번에 하나의 명령어만 수행되기 때문에** 명령어들이 **순차적으로 실행**된다.

---
## **Process state**

##### Memory context
프로세스가 사용한 메모리 ( code segment, data segment, stack segment, heap )
프로세스마다 다름

##### Hardware context
프로세스가 실행되면서 사용되는 하드웨어
Program counter, CPU register, I/O register 

##### System context
프로세스 자체 관리
Process table, open file table, page table

프로그램은 디스크(하드디스크나 SSD 등)에 **파일 형태로 저장된 코드**로, 실행되기 전까지는 단순한 데이터에 불과한 **수동적(passive) 존재**이다. 반면, **프로세스는 프로그램이 메모리에 적재되어 CPU에 의해 실제로 실행 중인 상태**를 의미하며, 자원을 사용하고 동작을 수행하는 **능동적(active) 존재**이다.

하나의 프로그램은 여러 개의 프로세스로 동작할 수 있다.

---
### **Multiprogramming vs multiprocessing**

1. Uniprogramming
	시스템에서 돌아가는 프로그램이 하나 -> 프로세스도 하나
2. Multiprogramming
	프로세스가 메모리에서 여러 개 동작
3. multiprocessing
	CPU 여러 개가 프로세스를 여러 개 수행
	CPU 관점 / CPU가 여러개
	multiprocessing이 되려면 multiprogramming이 되어야 하지만, 반대는 아님

---
## **Process Control Block**

**멀티 프로그래밍**을 구현하기 위해서는, 운영체제가 **여러 프로세스를 추적하고 관리**해야 한다.  
이를 위해 각 프로세스는 **프로세스 제어 블록(PCB, Process Control Block)**을 가진다.

##### Process control block, PCB
**PCB**는 **각 프로세스에 대한 중요한 정보를 담고 있는 데이터 구조**이다.  
여러 프로세스를 **테이블 형태로 모아두는 곳**으로 사용된다.

> [!note]
> **Process State** : 프로세스의 **현재 상태** (예: 실행 중, 대기 중, 종료 등).
>         
> **Program Counter** : 프로세스가 **다음에 실행할 명령어의 위치**.
>         
> **Register** : **프로세스와 관련된 모든 레지스터의 내용**.
>         
> **Scheduling Information** : 프로세스의 우선순위**와 **스케줄링 큐의 포인터**.
>         
> **Memory Management Information**: **프로세스가 사용하는 메모리 공간**에 대한 정보.
>         
> **Accounting Information** : **프로세스가 사용한 리소스**에 대한 정보 (예: CPU 시간, 실행 시간 등).
>         
> **I/O Status Information** : **프로세스가 사용하는 I/O 장치**와 관련된 정보.


**프로세스 테이블**은 **연결 리스트(linked list)** 형태로 관리되어 각 프로세스의 PCB를 포함한다.  이 테이블을 통해 운영체제는 **모든 프로세스를 추적하고 관리**할 수 있다.

---
## **Process State**

![](images/Pasted%20image%2020250313170002.png)


1. **New (새로 생성된 프로세스)**:
    
    - **새로 만들어진 프로세스**로, 아직 실행되지 않은 상태이다.
    - 프로세스는 이 상태에서 **메모리에 적재**되고 **실행 준비가 완료**되면 **Ready 상태**로 넘어간다.
        
2. **Running (실행 중인 프로세스)**:
    
    - **실제로 CPU에서 실행되고 있는 프로세스**.
    - CPU 자원을 할당받아 **명령어를 실행** 중인 상태이다.
        
3. **Ready (준비 상태)**:
    
    - **실행 가능한 상태**로, **CPU 자원을 기다리고 있는 프로세스**이다.
    - 대부분의 프로세스가 **Ready 상태**에 있으며, **CPU 자리가 한정적**이어서 대기 중이다.  
     이 상태에서 프로세스는 **실행할 준비가 되어 있지만, CPU가 할당되지 않으면 실행되지 않는다**.
        
4. **Waiting (대기 상태)**:
    
    - 프로세스가 **I/O 작업**이나 **특정 이벤트**를 기다리면서 **잠시 정지**된 상태이다.
    - 예를 들어, **파일 읽기/쓰기**나 **네트워크 통신**을 기다리는 경우가 이에 해당한다.
        
5. **Terminate (종료 상태)**:
    
    - 프로세스가 **모든 작업을 마친 후** **정지된 상태**이다.
    - 이 상태에서는 **프로세스가 더 이상 실행되지 않으며**, **자원을 반환하고** **메모리에서 제거**된다.

---
## **State Transition**

![](../images/Pasted%20image%2020250406174416.png)

##### Ready queue 
모든 프로세스는 일단 Ready 큐로 들어간다. 프로세스 실행 준비가 완료되면, CPU 자리를 기다리면 Ready 큐에서 대기하다가 CPU가 비면 Ready 큐에서 CPU 자리를 할당 받은 프로세스가 실행된다.

##### Device queue ( I/O waiting queues ) 
**I/O 요청이 발생하면 해당 프로세스는 Device Queue로 이동**한다. 프로세스가 **I/O 작업을 수행해야 할 때**, 해당 프로세스는 **Device Queue에 대기**하게 되며, I/O 작업이 완료되면 다시 **Ready Queue**로 돌아간다. 예를 들어, **파일 읽기/쓰기**, **네트워크 통신** 등을 대기하는 프로세스가 이 큐에 포함된다.

##### Job queue
**전체 프로세스를 관리하는 큐**로, **시스템에 제출된 모든 프로세스**를 관리한다. 프로세스가 생성되면 **Job Queue에 추가**되며, 이 큐는 전체 프로세스의 상태와 흐름을 관리한다. **Job Queue**는 **Ready Queue**, **Device Queue** 등으로 프로세스를 분배하는 역할을 한다.

---
## **State Transition**
migrating processes between various queues

![](../images/Pasted%20image%2020250406174838.png)


---
## **Schedulers**
#### Short term scheduler (CPU scheduler)
**Short-Term Scheduler**는 **어떤 프로세스가 CPU에서 실행될지** 결정하는 스케줄러이다. **CPU에서 실행될 프로세스**를 빠르게 선택해야 하므로, **자주 실행되고 매우 빠르게 작동**해야 한다. 한 **CPU 자리를 여러 프로세스가 번갈아 가며 사용**하므로, **빠른 속도**가 요구되고 효율적**이어야 한다.

#### Long-Term Scheduler (Job Scheduler)
**Long-Term Scheduler**는 **어떤 프로세스를 Ready Queue에 넣을지** 결정하는 스케줄러이다.
**과도한 프로세스 실행**을 방지하기 위해 **메모리에 몇 개의 프로그램**이 올라갈지를 결정하고, **시스템 과부하를 피하기 위해 프로세스를 격리**한다. 이 스케줄러는 **자주 호출되지 않기 때문에 실행 속도가 느려도 상관없다**.


##### 프로세스를 구분해서 실행

1. **I/O-bound Process**:
    
    - **I/O 작업**에 더 많은 시간을 사용하는 프로세스.
    - 주로 **입출력 대기** 중에 시간이 많이 소요되며, **CPU 사용 시간이 짧고, I/O 처리 시간이 길다**.
        
2. **CPU-bound Process**:
    
    - **CPU에 남아있는 시간이 길고**, **오랫동안 실행되는 프로세스**.
    - **CPU 자원을 많이 사용하는** 작업을 수행한다.
        

---
## **CPU Switch From Process to Process**

#### Context Switch
**Context Switch**는 **CPU가 현재 실행 중인 프로세스**를 **다른 프로세스로 교체**할 때 발생하는 과정이다. 이 과정에서는 **현재 실행 중인 프로세스의 상태(즉, 정보)** 를 **저장하고**, **새로운 프로세스의 상태**를 **불러오는** 작업이 이루어진다.

**현재 돌아가고 있던 프로세스의 정보는 PCB**(Process Control Block)에 저장된다. **PCB** 는 각 프로세스의 **상태, 레지스터 값, 프로그램 카운터** 등을 포함하고 있기 때문에, 프로세스가 실행을 마치고 다시 실행될 때 이 정보를 다시 **불러와야 한다**.

교체 과정 자체도 CPU에서 일어나기 때문에. 교체 과정 중에는 CPU가 할 일을 못 하게 된다. 그래서 빠른 Context Swtich가 필요하다. 만약 느리다면 느릴 수록 CPU 자원 낭비가 되는 것이다.

![](../images/Pasted%20image%2020250406180344.png)

OS와 PCB가 복잡하면 복잡할 수록 Context Switch의 시간도 더 오래 걸린다.

**하드웨어**는 **Context Switch 시간을 빠르게** 만들기 위해 **CPU에 다중 레지스터 집합**을 제공한다. **다중 레지스터 집합**을 이용하면, 여러 개의 **Context**를 한 번에 로드하고 교체할 수 있다. 하드웨어가 이러한 기능을 지원하면, **CPU가 빠르게 여러 프로세스의 정보를 교체**할 수 있어 **Context Switch 시간이 단축**된다.

---
## **Threads**

예전에는 프로세스가 하나의 쓰레드만 실행했다.

하지만 여러 개의 프로그램 카운터를 가진 프로세스를 생각해보면, 여러 위치에서 동시에 실행될 수 있다. 즉, 여러 개의 실행 흐름이 존재하게 되는 것이다. 이때, 이러한 실행 흐름을 **쓰레드**라고 한다.

쓰레드마다 **프로그램 카운터**를 포함하므로, **각 쓰레드의 세부 정보**를 저장하려면, PCB에는 **여러 개의 프로그램 카운터**를 저장할 공간이 필요하다.

---
## **Process Representation in Linux**

![](../images/Pasted%20image%2020250406181126.png)

---
## **Multitasking in Mobile Systems**

1. **일부 모바일 시스템**(예: 초기 버전의 iOS)은 **하나의 프로세스만 실행**하고 나머지 프로세스들은 **일시 중지**하는 방식을 사용한다.
    
    - **iOS**에서는 화면 공간 제한과 사용자 인터페이스(UI) 때문에 다음과 같은 제약을 둔다:
        
        - **단일 포그라운드 프로세스**가 **사용자 인터페이스**를 통해 제어된다.
            
        - **여러 개의 백그라운드 프로세스**가 메모리에서 실행되지만, 화면에 표시되지는 않으며, **제한된 작업**만 수행한다.
            
        - **백그라운드 프로세스의 제한 사항**:
            
            - 단일하고 짧은 작업
                
            - 이벤트 알림 수신
                
            - 특정 **장기 실행 작업** (예: 오디오 재생)
                
2. **Android**에서는 **포그라운드와 백그라운드 프로세스**가 실행되며, **제한이 적다**.
    
    - **백그라운드 프로세스**는 **서비스**를 사용하여 작업을 수행한다.
        
    - **서비스**는 **백그라운드 프로세스가 일시 중지되더라도 계속 실행**될 수 있다.
        
    - **서비스**는 **사용자 인터페이스가 없고**, **작은 메모리 사용**을 한다.

---
## **Process Creation and Termination**

프로세스를 생성하고 종료하는 작업은 운영체제에서 중요한 역할을 한다. 프로세스 생성에는 두 가지 방식이 있다: **처음부터 만드는 방식**과 **복제하는 방식**.


> [!note] Buid from Scratch ( 처음부터 만드는 방식 )
> 1. **코드와 데이터를 프로그램 파일에서 읽어서 메모리에 적재 (Loading)**
>         
> 2. **빈 스택(Stack) 생성**
>     
>     - 새로운 프로세스를 위한 **스택**을 할당하여, **메모리 컨텍스트**를 준비한다.
>         
> 3. **PCB(Process Control Block) 만들기**
>     
>     - 프로세스를 관리하기 위한 **프로세스 제어 블록(PCB)** 을 생성한다.
>         
> 4. **해당 PCB를 Ready Queue에 넣기**
>     
>     - 프로세스가 실행될 준비가 되었으면 **Ready Queue**에 **PCB**를 추가한다.

- 사실, 실제로는 **이렇게 단순하게 작업을 수행**하지 않는다. 다양한 추가적인 관리 작업이 필요하다.


> [!note] Process Duplicaiton( 프로세스 복제 )
> 1. **현재 상태 저장 (PC, 레지스터 등)**
>     
>     - 프로세스의 **현재 상태**를 저장한다. (예: **프로그램 카운터(PC)** 와 **레지스터 값**)
>         
> 2. **메모리 컨텍스트 복사**
>     
>     - 현재 프로세스의 **메모리 상태**를 복사하여 새로운 프로세스를 위한 **메모리 컨텍스트**를 만든다.
>         
> 3. **PCB 복사 (PID, 부모/자식 관계만 변경)**
>     
>     - 기존 **PCB**를 복사하고, **새로운 프로세스의 PID**와 **부모-자식 관계**를 수정한다.
>         
> 4. **새로운 PCB를 Ready Queue에 넣기**
>     
>     - **복제된 프로세스의 PCB**를 **Ready Queue**에 추가하여 **실행 준비 상태**로 만든다.

실제로는 **복제 방식**을 사용하여 **프로세스를 빠르게 생성**하며, 새로운 프로그램을 실행할 때 단순히 복제하는게 아니라 **Loading**을 다시 한 번 **수행**하여 새로운 프로그램이 **메모리에 적재**되도록 한다.
    
이 방식은 **프로세스 간의 소통 창구** 역할을 하며, 프로세스 간 자원을 효율적으로 관리할 수 있다.
        
---
## **Process Creation**

![](images/Pasted%20image%2020250319144624.png)


✅ **0번 프로세스는 복제되지 않음**

- 최초의 프로세스는 **복제(Fork)로 생성되지 않고, 처음부터(build from scratch) 생성됨.**
- 대표적으로 `init` 프로세스가 여기에 해당.

✅ **가장 먼저 생긴 프로세스(init)는 처음부터 생성되고, 이후 프로세스는 복제를 통해 생성됨**

- `init` 프로세스 이후부터는 **부모 프로세스(Parent)를 복제하여 자식 프로세스(Child)를 생성**.
- 복제된 프로세스는 **부모의 메모리를 로드**하여 동일한 상태를 가짐.
- 부모는 새로운 프로세스를 생성하는 역할을 수행.

✅ **리소스 공유 가능 (Resource Sharing Enabled)**
	
- 부모와 자식 프로세스는 **일부 리소스를 공유** / 전체 리소스 공유 / 공유 하지 않을 수도 있음.
- 예: 파일 디스크립터, 메모리 공간, 환경 변수 등.

✅ **실행 옵션**

- 부모와 자식 프로세스는 동시에 실행될 수 있다.
- 자식 프로세스가 종료될 때까지 부모 프로세스는 기다릴 수 있다. 


---

## **Unix ( Linux ) eamples**

1. **부모 프로세스(Parent Process) → `fork()` 호출**
    
    - `fork()`를 호출하면 **부모 프로세스의 복사본(Child Process)이 생성됨.**
    - 자식 프로세스는 부모와 **거의 동일한 상태**로 시작됨.
    
2. **자식 프로세스(Child Process) → `exec()` 호출**
    
    - `exec()` 를 호출하면 **새로운 프로그램이 메모리에 로드됨.**
    - 즉, `exec()` 를 실행한 이후에는 **기존 부모의 코드가 아닌 새로운 프로그램이 실행됨.**

![](../images/Pasted%20image%2020250406181540.png)


#### Process Creation Example 

```C++
#include <sys/types.h>
#include <stdio.h>
#include <unistd.h>
int main() {
	pid_t pid;
	/* fork a child process */
	pid = fork();
	if (pid < 0) { /* error occurred */
		fprintf(stderr, “fork failed”);
		return 1;
	}
	else if (pid == 0) { /* child process */
		execlp(“/bin/ls”, “ls”, NULL);
	}
	else { /* parent process */
		/* parent will wait for the child to complete */
		wait(NULL);
		printf(“child complete”);
	}
	return 0;
}
```


---
## **Process Termination**

✅ **프로세스가 종료될 때 수행되는 작업**

1. 프로세스는 **마지막 명령을 실행한 후**, `exit()` 시스템 호출을 통해 운영체제에 **삭제 요청**을 보냄.
2. 자식 프로세스(Child)는 **`wait()` 시스템 호출을 통해 부모에게 종료 상태(Status Data)를 반환**.
3. 운영체제는 **프로세스가 사용하던 자원(메모리, 파일 디스크립터 등)을 해제(Deallocate)**.

✅ **부모 프로세스가 자식 프로세스를 강제 종료할 수 있음**

- 부모 프로세스는 필요에 따라 자식 프로세스를 종료할 수 있음.
- **Linux**: `kill()`
- **Windows**: `TerminateProcess()`

✅ **부모가 자식 프로세스를 종료하는 이유**

1. **자식 프로세스가 할당된 자원을 초과하여 사용함** (예: 메모리, CPU 시간 초과).
2. **자식 프로세스가 수행해야 할 작업이 더 이상 필요하지 않음**.
3. **부모 프로세스가 종료될 경우, 일부 운영체제는 자식 프로세스를 계속 실행하는 것을 허용하지 않음**.

---


✅ **일부 운영체제에서는 부모 프로세스가 종료되지 않는 한 자식 프로세스도 존재할 수 없음.**

- 만약 부모 프로세스가 종료되면, **그에 속한 모든 자식 프로세스도 함께 종료되어야 함.**
- 이를 **"Cascading Termination(연쇄 종료)"** 라고 하며, **부모뿐만 아니라 모든 자식 프로세스와 그들의 하위 프로세스도 제거됨.**
- 이 종료는 **운영체제(OS)에 의해 자동으로 수행됨.**

✅ **부모가 `wait()` 시스템 콜을 사용하여 자식 프로세스의 종료를 기다릴 수 있음.**

- 부모가 `wait()` 호출 시, 자식 프로세스가 종료될 때까지 기다림.
- 종료된 자식 프로세스의 **PID(Process ID)와 상태 정보를 반환**받음.

```c
pid = wait(&status);
```

✅ **좀비 프로세스(Zombie Process)**

- **부모가 `wait()`을 호출하지 않으면, 자식 프로세스는 좀비 상태가 됨.**
- 좀비 프로세스는 **실행되지 않지만, 프로세스 테이블에서 정보가 남아있는 상태**로 자원을 차지함.

✅ **고아 프로세스(Orphan Process)**

- **부모가 `wait()`을 호출하지 않고 먼저 종료되면, 자식 프로세스는 고아 프로세스가 됨.**
- 대부분의 운영체제에서는 **고아 프로세스를 `init` 프로세스가 자동으로 관리하여 제거**함.


---
### Multiprogram Architecture Example (Chrome)

✅ **일반적인 웹 브라우저**

- 대부분의 웹 브라우저는 **싱글 프로세스(Single Process) 모델**을 사용하여 동작.
- 이 경우, **하나의 웹사이트에서 문제가 발생하면 전체 브라우저가 멈추거나 충돌(Hang or Crash)할 가능성이 높음.**

✅ **구글 크롬의 멀티 프로세스 모델**  
구글 크롬은 **3가지 주요 프로세스**로 동작하여 안정성과 보안을 강화함.

1. **브라우저 프로세스(Browser Process)**
    
    - **사용자 인터페이스(UI), 디스크 I/O, 네트워크 I/O** 등을 관리함.
    - 크롬의 전체 프레임워크를 제어하는 **중앙 프로세스** 역할.
2. **렌더러 프로세스(Renderer Process)**
    
    - 웹 페이지를 **렌더링(HTML, CSS, JavaScript 처리)** 하는 역할.
    - **각 웹사이트(탭)마다 새로운 렌더러 프로세스가 생성**됨.
    - 웹사이트 충돌이 발생해도 **다른 웹사이트(탭)에는 영향을 주지 않도록 격리됨 (Sandboxing).**
3. **플러그인 프로세스(Plug-in Process)**
    
    - 플러그인(예: Flash, PDF 뷰어 등)이 **독립적인 프로세스로 실행**됨.
    - 특정 플러그인이 충돌해도 브라우저 전체에는 영향을 미치지 않음.

---
### Inter - process Communication

✅ **시스템 내의 프로세스는 두 가지 유형으로 분류될 수 있음**

1. **독립적인 프로세스 (Independent Process)**
    
    - 다른 프로세스에 영향을 주거나 받지 않음.
    - 예: 개별 실행 중인 텍스트 에디터, 미디어 플레이어 등.
    
2. **협력하는 프로세스 (Cooperating Process)**
    
    - **공유 데이터**를 포함하여 다른 프로세스와 상호작용할 수 있음.
    - 예: 웹 브라우저(렌더러 & 네트워크 프로세스), 클라이언트-서버 모델 등.

✅ **협력하는 프로세스가 필요한 이유 (Reasons for Cooperating Processes)**

1. **정보 공유 (Information Sharing)**
    
    - 여러 프로세스가 동일한 데이터를 사용해야 할 경우 필요.
    - 예: 데이터베이스, 파일 공유 시스템.
    
2. **연산 속도 향상 (Computation Speedup)**
    
    - 작업을 여러 프로세스로 나누어 병렬 처리하면 속도가 향상됨.
    - 예: 멀티스레딩, 병렬 연산.

3. **모듈화 (Modularity)**
    
    - 프로그램을 여러 개의 독립적인 프로세스로 분리하여 관리가 용이함.
    - 예: 운영체제의 커널 모듈, 웹 브라우저의 멀티 프로세스 아키텍처.
    
4. **편의성 (Convenience)**
    
    - 특정 작업을 백그라운드에서 실행하여 사용자 경험을 향상.
    - 예: 오디오/비디오 스트리밍, 프린터 스풀링.

✅ **프로세스 간 통신 (Inter-Process Communication, IPC)**  
협력하는 프로세스는 **프로세스 간 통신(IPC)** 이 필요함.  
대표적인 두 가지 방식:

1. **공유 메모리 (Shared Memory)**
    
    - 프로세스들이 같은 메모리 공간을 공유하여 데이터를 주고받음.
    - 빠른 속도지만 동기화(예: 뮤텍스, 세마포어) 필요.
    
2. **메시지 전달 (Message Passing)**
    
    - 프로세스 간 직접 데이터를 공유하지 않고, **메시지를 교환하여 통신**.
    - 운영체제 커널이 메시지를 중재하여 데이터 동기화 문제를 줄임.

![](images/Pasted%20image%2020250319150329.png)

##### **(a) 메시지 전달(Message Passing) 방식**

- `msgsnd()`, `msgrcv()` 와 같은 시스템 호출을 사용하여 프로세스 간 메시지를 주고받음.
- **데이터를 복사하여 전달하므로** 대용량 데이터를 주고받을 때 **비효율적**일 수 있음.
- 하지만 **운영체제가 메시지 전달을 관리하므로 동기화 문제가 발생하지 않음**.

##### **(b) 공유 메모리(Shared Memory) 방식**

- 공유 메모리 영역을 생성하고, **프로세스들이 동일한 메모리 공간을 참조**하여 데이터를 주고받음.
- 데이터를 **복사하지 않고 직접 접근**하므로, 대용량 데이터 전송에 유리함.
- 하지만 **여러 프로세스가 동시에 접근할 경우 동기화 관리가 필요함** (예: Mutex, Semaphore 사용).

| IPC 방식     | 데이터 전달 방식 | 속도  | 동기화 필요 여부 | 대용량 데이터 처리 |
| ---------- | --------- | --- | --------- | ---------- |
| **메시지 전달** | 데이터 복사    | 느림  | ❌ 필요 없음   | ❌ 비효율적     |
| **공유 메모리** | 포인터 제공    | 빠름  | ✅ 필요함     | ✅ 효율적      |

---
### Producer - Consumner Problem

Producer과 Consumer Process들이 공유된 메모리 공간을 공유한다고 가정해보자

- Processer 0 : Producer
- Processor 1 : Consumer
##### 1. Shared data
```C++
#define BUFFER_SIZE 10
typedef struct {
. . .
} item;
item buffer[BUFFER_SIZE];
int in = 0;
int out = 0;
```

##### 2. Consumer code
```C++
item next_consumed; 
while (true) {
while (in == out) 
; /* do nothing */
next_consumed = buffer[out]; 
out = (out + 1) % BUFFER_SIZE;
/* consume the item in next consumed */ 
} 
```

##### 3. Consumer code
```c++
item next_produced; 
while (true) { 
/* produce an item in next produced */ 
while (((in + 1) % BUFFER_SIZE) == out) 
; /* do nothing */ 
buffer[in] = next_produced; 
in = (in + 1) % BUFFER_SIZE; 
} 
```

