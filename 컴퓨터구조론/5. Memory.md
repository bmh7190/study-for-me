
---
## **Locality**

프로그램은 실행 중에 **전체 주소 공간 중 일부만 집중적으로 접근**하는 경향이 있다. 이로부터 두 가지 중요한 **locality(지역성)** 개념이 도출된다:

##### ✅ Temporal Locality (시간적 지역성)

**최근에 접근한 데이터나 명령어가 곧 다시 접근될 가능성이 높다.**

- 예시: 반복문 안에서 반복적으로 사용되는 변수나 instruction
    
- 의미: 캐시에 최근 사용된 데이터를 유지하면 성능 향상 가능

##### ✅ Spatial Locality (공간적 지역성)

**최근 접근된 메모리 위치의 인접한 위치도 곧 접근될 가능성이 높다.**

- 예시: 연속된 배열 요소, 순차적으로 실행되는 명령어
    
- 의미: 한 번에 블록 단위로 메모리를 가져오면 효율적

----
## **Taking Advantage of Locality**

실제 메모리는 **계층적 구조(hierarchical structure)** 로 이루어져 있다.

가장 아래에는 **디스크**가 있다. **매우 느리지만 용량이 크며**, 모든 데이터를 영구적으로 저장한다.
    
디스크보다 빠르지만 상대적으로 작은 메모리가 바로 **DRAM**, 즉 **메인 메모리(Main Memory)** 다.  프로그램이 실행 중일 때 필요한 데이터 중 **자주 접근하고, 가까운 데이터들**을 이곳에 올려둔다.
    
DRAM보다 더 빠르고, 더 작은 메모리가 바로 **SRAM**, 즉 **캐시 메모리(Cache)** 다.  DRAM에 있는 데이터 중에서도 **가장 자주 사용되고, 최근에 접근된 데이터들**을 캐시에 저장한다.

이러한 메모리 계층은 **속도와 용량의 절충** 구조로 설계되며,  **Locality(지역성) 원리**를 기반으로 하여  
자주 쓰이는 데이터가 **더 빠른 계층에 위치하도록 하여 전체 시스템 성능을 향상**시킨다.

---
## **Memory Hierarchy Levels**

![](../images/Pasted%20image%2020250528000025.png)

각 단계에서 데이터를 가져올 때는 **데이터 하나씩이 아니라 일정 단위로 묶어서 가져오며**, 이 단위를 **block** 또는 **cache line**이라고 부른다.  데이터를 하나만 가져오면 **공간적 지역성(spatial locality)** 을 활용하지 못하므로 손해이기 때문이다.  예를 들어 현대 컴퓨터에서는 보통 **32바이트 또는 64바이트**를 하나의 block으로 사용한다.

프로세스가 데이터를 접근할 때는 **가장 빠른 단계(보통 캐시)부터 확인**하게 되며, 찾고자 하는 데이터가 해당 단계에 **존재하면 이를 "Hit"** 라고 하고, 전체 접근 중에서 Hit이 발생한 비율을 **Hit Ratio**라고 한다. 만약 그 단계에 없다면, 다음 단계(더 느리고 큰 계층)로 내려가야 하며,  이 경우를 **"Miss"** 라고 한다.

데이터를 발견했을 경우에는 **그 데이터만 가져오는 것이 아니라**, **그 데이터가 포함된 block 전체를 상위 계층으로 가져온다.** 이는 다음 번에 인접한 데이터를 사용할 가능성이 높기 때문 (→ 공간적 지역성 활용).

만약 더 밑의 단계까지 내려가서 데이터를 찾게 되면, **그만큼 접근 시간이 더 길어지며**, 이 추가 시간을 **Miss Penalty**라고 한다.

마지막으로 전체 접근 중 **Miss가 발생한 비율은 Miss Ratio**라고 하며,  
이는 단순히 `1 - Hit Ratio`로 계산할 수 있다.

---
## **Memory Technology**

| **Memory Type**        | **Access Time**      | **Cost per GB**         |        |
| ---------------------- | -------------------- | ----------------------- | ------ |
| **Static RAM (SRAM)**  | 0.5ns ~ 5ns          | $400 ~ $800             | 캐시     |
| **Dynamic RAM (DRAM)** | 20ns ~ 50ns          | $2 ~ $4                 | 메인 메모리 |
| **NAND Flash (SSD)**   | 250µs ~ 1000µs       | $0.04 ~ $0.10           | 스토리지   |
| **Magnetic Disk**      | 2ms ~ 20ms           | $0.01 ~ $0.02           | 스토리지   |
| **Ideal Memory**       | SRAM 수준의 Access Time | 디스크 수준의 Capacity 및 Cost |        |
프로그램이 사용하는 주소는 메인 메모리에서 저장된다고 보면 된다.


---
## **Cache Memory**

CPU와 굉장히 가까이에 있어서 빠른 속도로 접근할 수 있다.

메인 메모리의 경우 특정 주소로 접근하려고 하면 그냥 하면 되지만, cache 메모리에는 접근하려는 주소가 있을 수도 있고 없을 수 있다. 따라서 해당 데이터가 cache 메모리에 있는지 없는지 확인해 봐야 한다.

가장 쉬운 방법은 cache 메모리에 있는 데이터에 어디서 왔는지 주소를 다 적어서 넣어놓는 것이다. 그러나 이것은 굉장히 비효율적이다.

---
## **Direct Mapped Cache**

위의 비효율적인 방법 대신에, **주소마다 저장될 수 있는 칸을 고정하는 방법**이 있다.  즉, **주소가 주어지면 cache 메모리의 특정 위치에만 저장되도록 연결된 공간이 정해지는 방식**이다.

![](../images/Pasted%20image%2020250528001858.png)

자, 위의 예시처럼 메인 메모리에는 32개의 칸이 있고, Cache에는 8개의 칸이 있다고 하자.  
그렇다면 메인 메모리의 각 칸을 구별하기 위해서는 2<sup>5</sup>=32 이므로 **5개의 비트**로 주소를 구분할 수 있고,  
Cache 메모리는 2<sup>3</sup>=8이므로 **3개의 비트**로 구분할 수 있다.

그래서 **메인 메모리의 하위 3비트**를 확인해서 **Cache 메모리의 3비트와 비교**했을 때,  **똑같은 위치에만 메인 메모리의 데이터가 저장될 수 있는 것**이다.  

>즉, **Cache 메모리의 각 칸에는 올 수 있는 메인 메모리 주소가 정해져 있다는 의미**다.

그래서 **하위 3비트는 Cache 메모리의 위치를 결정**하는 데 사용되므로,  해당 위치를 통해 이미 알고 있는 정보이다.  따라서 **Cache 메모리 내부에는 나머지 상위 2비트만 저장**해두면,  이를 통해 **메인 메모리의 전체 주소를 복원하거나 확인**할 수 있게 된다.

---
## **Tags and Valid Bits**

따라서 해당 Cache 메모리 안에 있는 메인 메모리를 나타내는 값들을 **Tag**라고 한다.

만약 컴퓨터를 처음 켰을 때를 생각해보면, **Cache 메모리는 비어 있는 상태**가 된다.  이처럼 Cache 메모리 안에 있는 데이터가 **유효할 수도 있고, 유효하지 않을 수도 있기 때문에**,  이를 확인하기 위한 **Valid bit**가 하나 포함되어 있다.

따라서 주소의 **하위 비트**를 통해 Cache 메모리에서 **위치를 찾고**,  **상위 비트(Tag)** 를 통해 메인 메모리의 해당 주소가 **실제로 맞는지 확인**하며,  **Valid bit**를 통해 그 데이터가 **유효한지 아닌지를 판단**하게 된다.

---
## **Cache Memory**

8개의 block으로 이뤄져있고, block마다 1word가 저장된다. 즉 용량이 32byte인 cache이다 그리고 direct mapped 방식을 사용한다고 가정하자.

##### 1️⃣ 초기값

![](../images/Pasted%20image%2020250528003243.png)
완전 초기값에는 **Tag나 Data 값이 임의의 값으로 채워져 있을 수 있지만**,  **Valid bit가 0**이기 때문에 **이 데이터는 무시되며 적용되지 않는다.**

즉, **Valid bit가 1이 되어야만** 해당 Tag와 Data가 **유효한 값으로 인식**되고,  **Valid bit가 0이면 아무리 Tag와 Data가 일치하더라도 cache miss로 처리**된다.

![](../images/Pasted%20image%2020250528003308.png)

22번 주소가 왔다고 가정하면, 2진수로 표현하면 **10110**이다.

이 중에서 **하위 3비트(110)** 를 확인해 보면, 해당 위치의 **Valid bit가 0**, 즉 **유효하지 않다.**  따라서 이 주소에 해당하는 데이터는 **Cache에 존재하지 않는 것(miss)** 으로 판단하게 된다. 그러면 **메인 메모리에서 원하는 데이터를 가져와서 사용**하게 되며,  **같은 Cache 위치(하위 3비트 = 110)** 에 해당 데이터를 **저장**한다.

이때 상위 비트인 **Tag = 10** (즉, 상위 2비트) **Valid bit는 1로 설정**한다. 즉, 다음부터 해당 위치를 다시 접근할 경우,  **Tag가 일치하고 Valid bit도 1이면 cache hit으로 동작**하게 된다.

![](../images/Pasted%20image%2020250528003620.png)

만약 cache 메모리에 원하는 Tag값이 있고, valid 하다면 메인 메모리까지 가지 않고, cache에서 가져가면 된다!

---

![](../images/Pasted%20image%2020250528003729.png)

Index는 맞지만 Tag가 다르다면 원하는 데이터가 아니므로, 메인 메모리에서 가져온 다음 원래 있던 데이터 대신에 새로 가져온 데이터를 Cache에 넣는다. 원래 저장되어 있던 데이터는 쫓겨나게 되는데 이 과정을 evict이라고 한다. 여기서 만약 쫓겨난 데이터가 변경되었다면 어떻게 처리할지도 나중에 알아보자.


---
## **Address Subdivision**

![](../images/Pasted%20image%2020250530165232.png)

---
## **Example: Larger Block Size**

![](../images/Pasted%20image%2020250530165423.png)

index 랑 offset
