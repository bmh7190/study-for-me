---

---

## **ALU Control**


![](../images/Pasted%20image%2020250522141231.png)

ALU 컨트롤 신호를 만들기 위해서 앞에 opcode( 상위 6비트 )를 보고 일차 decoding을 한다. 그리고 R type일 경우에만 funct를 보고 2차 디코딩을 한다. 

---
## **The Main Control Unit**

![](../images/Pasted%20image%2020250522141418.png)

```assembly
add rd, rs, rt
```

여기서 rs와 rt는 읽기용으로 사용되며, ALU에서 덧셈을 수행한 결과가 rd에 저장된다.

```assembly
lw rt, N(rs)
```

주소 계산을 위해 rs를 읽고, 메모리에서 읽은 값을 rt에 저장하기 때문에 rt는 쓰기용이다.

```assembly
sw rt, N(rs)
```

메모리에 저장할 데이터를 rt에서 가져오고, 주소 계산을 위해 rs를 사용하므로 둘 다 읽기용이다.

lw와 sw에서 rt의 역할이 서로 다르다는 점을 확인할 수 있다.

```assembly
beq rs, rt, N
```

rs와 rt의 값을 비교해야 하므로, 두 레지스터 모두 읽기용으로 사용된다.

정리해보면, rs는 jump 명령을 제외한 대부분의 명령에서 읽기만 하며, 실제로 jump에서도 rs를 읽기는 하지만 명령 실행에 영향을 주지 않기 때문에 사실상 **모든 명령에서 rs는 읽기용**이다.

rt는 `lw` 명령을 제외하고 대부분의 명령에서 읽기용으로 사용된다. 하지만 `lw`에서도 rt를 읽는 것이 명령 실행에 영향을 주지는 않으므로, **모든 경우 rt는 기본적으로 읽기 용으로 간주하고**, `lw`일 때만 **추가로 쓰기 동작이 발생**한다고 보면 된다.

R-type일 때랄ㅇ Load 일 때랑 쓰는 위치의 번호가 다르다. R-type 일 때는 15:11 Load는 20:16에 쓴다.