---

---

## **ALU Control**


![](../images/Pasted%20image%2020250522141231.png)

ALU 컨트롤 신호를 생성하기 위해 먼저 **opcode(상위 6비트)** 를 참고하여 **1차 디코딩**을 수행한다. 이 과정에서 명령어가 R-type인지, I-type인지, 또는 Load/Store나 Branch 계열인지 판별하게 된다. 이후 **R-type 명령어일 경우에만** 하위 6비트에 위치한 **funct 필드를 추가로 확인하여 2차 디코딩**을 수행하고, 이를 통해 정확한 연산 종류(예: add, sub, and, or 등)를 구분해 ALU에 전달할 제어 신호를 생성한다.


---
## **The Main Control Unit**

![](../images/Pasted%20image%2020250522141418.png)

```assembly
add rd, rs, rt
```

여기서 rs와 rt는 읽기용으로 사용되며, ALU에서 덧셈을 수행한 결과가 rd에 저장된다.

```assembly
lw rt, N(rs)
```

주소 계산을 위해 rs를 읽고, 메모리에서 읽은 값을 rt에 저장하기 때문에 rt는 쓰기용이다.

```assembly
sw rt, N(rs)
```

메모리에 저장할 데이터를 rt에서 가져오고, 주소 계산을 위해 rs를 사용하므로 둘 다 읽기용이다.

lw와 sw에서 rt의 역할이 서로 다르다는 점을 확인할 수 있다.

```assembly
beq rs, rt, N
```

rs와 rt의 값을 비교해야 하므로, 두 레지스터 모두 읽기용으로 사용된다.

정리해보면, rs는 jump 명령을 제외한 대부분의 명령에서 읽기만 하며, 실제로 jump에서도 rs를 읽기는 하지만 명령 실행에 영향을 주지 않기 때문에 사실상 **모든 명령에서 rs는 읽기용**이다.

rt는 `lw` 명령을 제외하고 대부분의 명령에서 읽기용으로 사용된다. 하지만 `lw`에서도 rt를 읽는 것이 명령 실행에 영향을 주지는 않으므로, **모든 경우 rt는 기본적으로 읽기 용으로 간주하고**, `lw`일 때만 **추가로 쓰기 동작이 발생**한다고 보면 된다.

R-type 명령어와 Load 명령어는 **결과를 저장하는 레지스터의 위치(번호)가 다르다.**  R-type 명령어에서는 결과를 저장할 레지스터가 **`rd` 필드에 위치하며, 이는 명령어의 비트 15:11에 해당한다.**  반면, Load 명령어(`lw`)는 결과를 저장할 레지스터가 **`rt` 필드에 위치하며, 이는 비트 20:16에 해당한다.**

---

## **Datapath with Control**

![](../images/Pasted%20image%2020250522142354.png)


##### RegWrite
`RegWrite`는 해당 명령어가 **레지스터에 값을 쓸지 여부**를 결정하는 제어 신호로, **R-format 명령어**와 **`lw` 명령어**인 경우에는 **1**로 설정되어 값을 레지스터에 기록한다. 나머지 명령어들(`sw`, `beq` 등)은 레지스터에 값을 쓰지 않기 때문에 이 경우 `RegWrite`는 **0**이 된다.

##### RegDst
`RegDst`는 **레지스터 파일의 어느 위치에 값을 쓸 것인지를 선택하는 제어 신호**로, **R-format 명령어**의 경우 결과값을 **`rd` 필드(비트 15:11)** 에 저장해야 하므로 이때 `RegDst`는 **1**로 설정된다. 반면, **`lw` 명령어**는 결과를 **`rt` 필드(비트 20:16)** 에 저장하므로 `RegDst`는 **0**이 된다. 그 외 명령어들은 애초에 레지스터에 값을 쓰지 않기 때문에 `RegDst`의 값은 무관하며, 실제로는 `RegWrite`가 0이기 때문에 `RegDst`는 사용되지 않는다.

##### ALUSrc
`ALUSrc`는 ALU의 두 번째 입력을 결정한다. `Read data1`은 항상 ALU와 연결되어 있다. `lw`, `sw`일 때는 상수를 사용하기 때문에 `ALUSrc = 1`, `R-format`이거나 `beq`일 때는 `ALUSrc = 0`이다. 이 경우 레지스터 하나 더 읽은 값을 사용해야 하므로 `Read data2`와 연결된다.

##### PCsrc
`PCSrc`는 다음 PC 값을 결정하는 신호로, `beq` 명령어이고 ALU 결과가 zero일 때 `PCSrc = 1`이 된다. 그 외의 경우는 `PCSrc = 0`이며 기본적으로 `PC + 4`를 사용한다. 즉, `PCSrc`는 단순히 `PC + 4`를 사용할지, 분기 상수를 더한 값을 사용할지를 결정하는 신호다.

##### MemWrite / MemRead
`MemWrite` sw 일 때만 1, 나머지는 0
`MemRead` lw 일 때만 1, 나머지는 0

##### MemtoReg
`MemtoReg` 메모리에서 읽은 걸 레지스터에 저장해야 하니까 lw만 1, ALU의 결과를 사용해야 하는 R-format 은 0, 나머지는 상관없다. 

---
## **R-type Instruction**

![](../images/Pasted%20image%2020250522144036.png)

RegDst : R-type은 15-11비트에 있는 rd를 사용하기 때문에 1  
ALUSrc : rs는 항상 읽어서 ALU에 들어가고 레지스터를 하나 더 읽어서 ALU에 넣어야 하므로 0  
MemtoReg : R-format은 ALU의 결과가 rd에 들어가야 하므로 0  
RegWrite : 레지스터에 값을 써야 하므로 1  
MemRead / MemWrite : 메모리를 사용하지 않으므로 둘 다 0  
Branch : 브랜치 명령어가 아니므로 0

---
## **Load Instruction**

![](../images/Pasted%20image%2020250522144549.png)

RegDst : lw는 결과물이 rt(20-16)로 가기 때문에 0  
ALUSrc : 주소 계산에 상수를 사용해야 하므로 1  
MemtoReg : 메모리에서 읽은 값을 레지스터로 보내야 하기 때문에 1  
RegWrite : 레지스터에 값을 써야 하므로 1  
MemRead / MemWrite : 메모리에서 읽어야 하므로 MemRead는 1, MemWrite는 0  
Branch : 브랜치 명령어가 아니므로 0

---
## **Branch-on-Equal Instruction**

![](../images/Pasted%20image%2020250522144902.png)

RegWrite : 레지스터 쓰기를 하지 않으므로 0  
RegDst : 두 레지스터를 비교만 하기 때문에 사용하지 않는다  
MemtoReg : RegWrite가 0이므로 상관 없다  
ALUSrc : 두 레지스터를 비교해야 하므로 Read data2를 사용해야 하며, 따라서 0  
MemRead / MemWrite : 메모리 접근이 없으므로 둘 다 0  
Branch : beq이므로 1, 다만 Branch 신호만으로 점프하지 않고 ALU 결과가 zero일 때 함께 작동해 점프가 수행된다

---
## **Implementiong Jumps**

![](../images/Pasted%20image%2020250522145419.png)

opcode가 jump라고 판별되면, 명령어의 address 필드를 이용해 **새로운 PC 값을 계산**한다. 이때 PC는 다음과 같이 구성된다: **현재 PC의 상위 4비트 + (address 필드 << 2)**. 즉, address 뒤에 00을 붙여 왼쪽으로 2비트 시프트하고, 이 값을 현재 PC의 상위 4비트와 결합하여 **완전한 32비트의 jump target 주소**를 만든다.

![[Pasted image 20250522145804.png]]

아까까지는 PC를 계산할 때 **PC + 4**를 그대로 쓸지, 아니면 **PC + 4 + (immediate × 4)**로 분기할지를 결정하는 방식이었다. 하지만 **jump 명령어인 경우**에는 이 두 가지 경우를 **완전히 무시하고**, **(PC + 4)의 상위 4비트 + address 필드 + 00**을 조합하여 **즉시 해당 위치로 이동한다.** 즉, jump는 분기와 달리 조건 검사 없이 **절대 주소로 점프하는 방식**이다.

그래서 RegWrite, MemRead, MemWrite은 0,  `jump` control이 1이 되고, 나머지는 상관없다. 

----

## **Performance Issues**

가장 큰 delay를 가지는 연산이 전체 clock 주기를 결정하게 된다. 일반적으로 가장 긴 지연을 가지는 명령어는 `lw`이며, 이 명령은 Instruction memory → Register file → ALU → Data memory → Register file의 단계를 모두 거치기 때문에 전체 경로가 길고 시간이 오래 걸린다. 

문제는 명령어마다 수행 시간이 제각각인데, 그때그때 clock 주기를 바꾸는 것은 현실적으로 불가능하다. 따라서 모든 명령어가 **고정된 clock 주기 안에서 실행되도록 설계해야 하며**, 결국 **가장 긴 시간(lw 기준)에 맞춰 clock 주기를 설정해야 하므로 전체적으로 비효율적**이 된다.

> 이 문제를 해결하기 위한 방법이 바로 `Pipelining`이다. 

> [!note] Pipelining
> 
> clock마다 새로운 명령어가 들어오도록 하고, 명령어의 실행을 여러 단계로 나누어 각 단계에서 병렬로 처리되도록 한다. 즉, **이전 명령어가 사용한 자원이나 회로를 다음 명령어가 재사용할 수 있도록 순차적으로 넘겨주는 방식**이다. 
> 
> 이렇게 하면 **하나의 명령어가 끝날 때까지 기다리지 않고**, 각 clock 사이클마다 새로운 명령어가 들어와 **CPU 자원을 더 효율적으로 사용할 수 있게 된다.**


---
## **Pipelining Analogy**

![](../images/Pasted%20image%2020250522150610.png)

• **4개의 load 명령어가 있을 때**
	파이프라인 도입 전후의 성능을 비교한 Speedup은  **Speedup = 8 / 3.5 = 2.3** (총 8 사이클 소요되는 순차 실행 대비 3.5 사이클에 완료되었을 때)

• **Non-stop 방식으로 파이프라인이 완전하게 채워진 상태**
  **Speedup = 2n / (0.5n + 1.5) ≈ 4**,  
  이는 파이프라인의 **스테이지 수가 4단계**임을 의미한다.

---
## **MIPS Pipeline**

• IF: instruction 읽는 단계
• ID: Instruction decoding 하고, 레지스터 읽기 ( 일단 레지스터 읽고, 나중에 골라서 쓰기 )
• EX: ALU 연산 또는 주소 계산하는 단계
• MEM: 메모리에서 데이터를 읽거나 쓰는 단계
• WB: 레지스터에 결과물 쓰는 단계

MIPS는 5개의 단계로 구분한다. 

---
## **Pipeline Performance**

단계가 5개라서 5배의 성능을 보여주는 것은 아니다. 단계마다 걸리는 시간이 다르기 때문이다. 그래서 단계를 나눴지만, 가장 길게 걸리는 단계의 시간으로 cycle을 설정한다. 

![](../images/Pasted%20image%2020250522151415.png)

위의 표를 보면 단계에서 가장 길게 걸리는 시간이 200ps 이기 때문에 시간을 200ps로 설정해야 한다. 

![](../images/Pasted%20image%2020250522151637.png)

그래서 비교적 짧게 걸리는 Reg 접근 단계에서는 남는 시간이 생긴다. 


---
## **Pipeline Speedup**

모든 파이프라인 스테이지가 **균형 있게 구성되어 있다면**, 즉 각 스테이지가 **동일한 시간**을 소요한다면,  
  
  **파이프라인된 명령어 간 시간 = 비파이프라인 명령어 간 시간 ÷ 스테이지 수**가 된다.  

만약 스테이지 간 시간이 **불균형하다면**, 전체 성능 향상은 줄어들게 된다.  

파이프라이닝으로 얻는 **속도 향상(Speedup)은 처리량(Throughput)이 증가**했기 때문이며, **각 명령어의 지연 시간(Latency)**, 즉 하나의 명령어가 끝날 때까지 걸리는 시간 자체는 **줄어들지 않고 오히려 증가한다.**

---
## **Pipelining and ISA Design**

모든 instruction이 32비트로 고정되어 있기 때문에, MIPS에서는 **Decoding을 한 사이클 내에 쉽게 수행할 수 있다.** 반면, x86 아키텍처는 명령어 길이가 가변적이기 때문에 **디코딩이 복잡하고 어려운 구조**이다. 

또한 **레지스터 접근도 단순하게 설계되어 있어 읽는 작업이 용이하다.** 

Load/Store 명령어도 마찬가지로 수행이 쉽다. MIPS에서는 주소 계산 방식이 **하나로 통일되어 있기 때문에**, 주소 계산과 메모리 접근을 **각각 한 스테이지씩 할당**하면 된다. 

게다가 **메모리 주소들이 정렬(aligned)되어 있기 때문에**, 접근 또한 **간단하고 효율적으로 처리할 수 있다.**

---
## **Hazards**

다음 사이클에 instruction이 정상적으로 실행되는 것을 **방해하는 상황**들이 발생할 수 있다.

##### Structure hazards
하드웨어 자원이 동시에 여러 instruction에 의해 사용되어 **충돌이 발생하는 상황**이다.  
##### Data hazard
다음 instruction이 **연산에 필요한 데이터 값을 사용하려고 하지만**, 그 값이 **이전 instruction에서 아직 계산 중이거나 저장되지 않은 상태**일 때 발생한다.

##### Control hazard
분기(branch)나 jump와 같이 **다음에 실행할 instruction의 흐름이 이전 instruction 결과에 의존하는 경우** 발생한다.  정확한 분기 결과가 나올 때까지 어떤 instruction을 실행해야 할지 모르는 상황이다.

---
## **Structural Hazards**

금 다루고 있는 MIPS 구조에서는 이러한 문제가 발생하지 않는다. 

> 우리는 instruction이 저장되는 메모리와 데이터(레지스터) 메모리가 **서로 분리되어 있다고 가정**하고 있지만, 실제로는 instruction과 data 모두 **하나의 메모리**에 저장되는 경우가 많다. 

이 경우 instruction을 읽기 위해 메모리에 접근해야 하고, 동시에 데이터를 저장하기 위해서도 메모리에 접근해야 하는데, **메모리는 한 번에 하나의 접근만 허용**하기 때문에 **resource 충돌이 발생한다.** 이로 인해 한 cycle을 날리게 되며, 파이프라인 상에는 **무의미한 명령어(bubble)** 를 넣어 **구조적 충돌을 회피**해야 한다.

---
## **Data Hazards**

![](../images/Pasted%20image%2020250522153646.png)


지금 `add $s0, $t0, $t1` 명령어에서 계산된 결과 `$s0`는 다음 명령어에서 바로 사용되고 있다. 이때 `add` 명령어는 MEM 단계에서 실질적인 동작은 없지만, **구조 통일을 위해 파이프라인 단계는 그대로 거친다고 가정**하자. 

실제 연산은 EX 단계에서 수행되며, 결과 값이 **레지스터에 쓰이는 시점은 WB 단계**이다. 하지만 만약 바로 다음 명령어인 `sub $s2, $s0, $s3`가 실행된다면, 이 명령은 **ID 단계에서 레지스터 값을 읽는데**, 이 시점에는 아직 `$s0`의 값이 **WB 단계에서 갱신되지 않았기 때문에 이전 값이 반영된다.** 

따라서 이런 상황에서는 파이프라인 사이에 **두 사이클 정도 bubble(무의미한 명령어)**을 삽입해주면, **이전 명령의 결과가 레지스터에 반영된 이후에 읽게 되어 올바른 값으로 연산이 가능해진다.**

---
## **Forwarding (aka Bypassing)**

이처럼 bubble을 계속 삽입하면 CPI가 증가하게 된다. 이를 해결하기 위해 추가적인 최적화 작업이 필요하다. 

사실 연산 결과 자체는 **EX 단계에서 이미 계산이 완료되고**, **WB 단계에서는 단순히 그 결과를 레지스터에 저장만** 하는 것이다. 

그렇기 때문에 굳이 결과가 WB까지 도달할 때까지 기다리지 않고, **EX 단계에서 나온 결과 값을 바로 다음 instruction에 전달하는 방식**, 즉 **forwarding(또는 bypassing)** 기법을 사용하면 불필요한 bubble 삽입 없이도 데이터 의존 문제를 어느 정도 해결할 수 있다.

![](../images/Pasted%20image%2020250522154549.png)

레지스터 반영까지 기다리지 말고, 연산 결과를 적절하게 사용하자!

---
## **Load-Use Data Hazard**

위의 방식을 사용하면 모든 Data Hazard를 막을 수 있을까? 아니다.

![[Pasted image 20250522154951.png]]

아까는 R-format 명령어였기 때문에 EX 단계에서 결과물이 바로 나왔고, forwarding을 통해 다음 instruction에 값을 넘겨줄 수 있었다. 

하지만 `lw`와 같은 Load 명령어의 경우, **실제 데이터는 MEM 단계에서 메모리로부터 읽혀지기 때문에**, EX 단계에서는 아직 유효한 값이 없다. 그래서 아무리 forwarding을 사용하더라도 다음 명령어가 그 값을 바로 사용할 수 없고, **데이터 hazard가 발생한다.** 

이 경우에는 **한 사이클 정도 bubble을 삽입해야 하며**, 이를 통해 Load 명령어 이후의 instruction이 올바른 데이터를 참조할 수 있도록 한다.

> forwarding 을 하면 1 cycle 안 하면 2cycle 버블이 생긴다. 

---
## **Code Scheduling to Avoid Stalls**

다음 instruction에서 바로 load된 값을 사용하는 것을 피하기 위해, **코드의 순서를 변경하여 hazard를 회피할 수 있다.** 즉, **load 명령의 결과를 바로 사용하는 instruction을 지연시키고**, **그 사이에 이전 코드의 영향을 받지 않는 명령어를 먼저 실행**함으로써 bubble의 삽입을 줄일 수 있다. 이렇게 하면 불필요한 stall 없이 파이프라인을 효율적으로 사용할 수 있다.

![](../images/Pasted%20image%2020250523205754.png)

---
## **Control Hazards**

branch 명령어의 결과에 따라 **다음에 실행될 instruction이 결정되기 때문에**, 보통은 **EX 단계에서 분기 여부가 결정되며**, 그 전까지는 어떤 instruction을 가져올지 확정할 수 없다. 이로 인해 파이프라인에는 **최소 두 개의 bubble이 삽입**되어야 다음 명령어를 정확히 실행할 수 있다. 

이를 개선하기 위해, 하드웨어적으로 레지스터를 읽은 직후, 즉 **ID 단계와 EX 단계 사이에 간단한 비교용 ALU를 추가하여 ID 단계에서 분기 조건을 미리 판단**할 수 있도록 하면, 한 사이클 정도는 빠르게 처리할 수 있다. 

하지만 이 최적화를 적용하더라도 **분기 결과가 완전히 확정되기까지는 최소 한 사이클의 bubble이 필요**하므로, 완전히 제거할 수는 없다.

![](../images/Pasted%20image%2020250523210144.png)

bubble을 채워 넣어서 한 사이클을 멈추는 행위를 stall이라고 한다.

---
## **Branch Prediction**

branch instruction은 프로그램 내에서 굉장히 자주 등장하는 명령어이기 때문에, 매번 한 사이클씩 bubble을 채워야 한다면 전체 성능에 큰 영향을 미친다. 

이를 해결하기 위해 **branch prediction**, 즉 **분기 예측 기법**이 사용된다. 분기 결과를 미리 예측하고, **예측된 방향으로 다음 명령어를 먼저 가져와 실행**하는 방식이다. 

예측이 맞으면 그대로 이어서 실행하면 되고, **예측이 틀렸다면 그때 실행한 명령어를 취소(flush)하고 실제 분기된 경로로 다시 fetch**하면 된다. 어차피 무조건 stall하는 것보다, **성공 확률이 높은 예측을 통해 평균적인 성능을 끌어올리는 쪽이 훨씬 효율적**이다.


![](../images/Pasted%20image%2020250523211006.png)

---
## **More-Realistic Branch Predicion**

예측 방식은 매우 중요하다. 왜냐하면 **프로그램마다 taken과 not taken의 분포가 다르기 때문**이다.

##### Static branch prediction

고정된 방식으로 예측하는 방법으로, **일반적인 분기 패턴**에 기반하여 판단한다.  
예를 들어 반복문에서는 **보통 루프를 다시 반복하는 경우가 많기 때문에** backward jump는 taken, forward jump는 not taken으로 정해놓고 예측한다.  이 방식은 **구현이 단순하고 어느 정도 효과가 있지만**, 다양한 상황에서 높은 정확도를 기대하긴 어렵다.

##### Dynamic branch prediction

실행 중인 상황을 실시간으로 기록하고 그 정보를 기반으로 예측하는 방식이다.  
**코드는 반복적으로 실행되는 경우가 많기 때문에**, 이전 분기 결과를 기억해두고 다음에도 비슷한 행동을 할 거라고 가정한다.  즉, 이전에 taken이었으면 다음에도 taken으로 예측하고, **예측이 틀리면 stall한 뒤 예측 정보를 갱신**한다.  이 방식은 시간이 지날수록 예측 정확도가 높아지는 경향이 있다.

---
## **MIPS Pipelined Datapath**

![](../images/Pasted%20image%2020250523212445.png)

여기서 말하는 Register는 데이터가 **막힘 없이 흘러가는 흐름 속에서**, 중간중간에 **댐처럼 구분을 만들어주는 역할**을 한다. 파이프라인의 각 단계 사이에 있는 레지스터는 **이전 단계에서 생성된 데이터를 잠시 저장하고**, **다음 단계로 넘겨주는 경계 역할**을 하여 각 스테이지가 **독립적으로 동작할 수 있도록 구분**해준다.

![](../images/Pasted%20image%2020250523212652.png)

각 파이프라인 단계 사이에는 **레지스터가 필요하다.** 이는 **이전 사이클에서 생성된 정보를 저장**해두기 위한 용도로 사용된다. 매 Clock마다 **이 레지스터에 저장된 값이 다음 스테이지로 전달**되며, 파이프라인이 순차적으로 진행된다.

>즉, **각 단계 사이에 존재하는 중간 레지스터**가 파이프라인의 흐름을 유지시켜주는 핵심 역할을 한다.

**PC(Program Counter)** 역시 마찬가지로, **clock이 바뀔 때만 값이 갱신되는 레지스터**이다.

---
## **IF for Load, Store**

![](../images/Pasted%20image%2020250523213335.png)

1. **PC + 4**를 먼저 계산하여 다음 instruction의 주소를 미리 준비하고, 다음 명령어를 바로 실행할 수 있도록 한다.
    
2. 현재 PC 값을 이용해 **instruction memory에서 해당 instruction을 fetch**한다.
    
3. 계산된 PC + 4 값과 가져온 instruction은 **IF/ID 레지스터에 저장**되어 다음 ID 단계에서 사용될 수 있도록 한다.

---
## **ID for Load, Store**

![](../images/Pasted%20image%2020250523213712.png)

IF/ID에 저장되어 있던 데이터는 **다음 clock 사이클에 ID 단계로 넘어온다.** 레지스터에 있는 값이 실제로 사용될지 아닐지는 아직 모르지만, **일단 필요한 두 개의 레지스터 값을 모두 읽는다.** 

또한, 명령어에 포함된 **immediate 값도 추출하여 sign-extension을 수행**한다. 

이렇게 읽어들인 값들과 제어 신호 등은 **ID/EX 레지스터에 저장**되고, **다음 clock 사이클까지 대기**하게 된다.

---
## **EX for Load**

![](../images/Pasted%20image%2020250523214017.png)

다음 clock이 오면 ALU에서 주소 계산 

---
## **MEM for Load**

![](../images/Pasted%20image%2020250523214137.png)

전 단계에서 주소 계산을 했고, 그 주소가 넘어오면 그 주소에서 읽는다. 주소 읽은 값을 MEM/WB에 저장

---
## **WB for Load**

![](../images/Pasted%20image%2020250523214236.png)

WB을 수행하기 위해 다시 ID 단계에 있는 레지스터로 돌아가 값을 쓰려고 하면 문제가 생긴다. 왜냐하면 그 시점의 레지스터는 **현재 WB를 하려는 instruction의 레지스터가 아닌**, **그보다 두 세 사이클 이후에 들어온 instruction의 레지스터 정보로 덮여져 있기 때문**이다. 따라서 WB 단계에서 잘못된 레지스터에 값을 쓰게 되어 **데이터 오류가 발생하게 된다.**

따라서 제대로 된 WB을 하기 위해서 WB이 적용되어야 하는 레지스터의 번호도 같이 넘어와야한다.

![](../images/Pasted%20image%2020250523214641.png)

제대로 된 그림에서는 말한 것처럼, **처음에 Write register로 사용되는 레지스터 번호를 IF/ID → ID/EX → EX/MEM → MEM/WB** 순으로 **각 파이프라인 레지스터에 함께 전달**한다. 이렇게 해야 WB 단계에서 **정확히 어떤 레지스터에 결과 값을 써야 하는지**를 파악할 수 있고, **다른 instruction의 레지스터 정보와 혼동되지 않으며**, **정확한 위치에 WB(Write Back)** 이 이루어질 수 있다.

---
## **EX for Store**

![](../images/Pasted%20image%2020250523214843.png)

![](../images/Pasted%20image%2020250523214858.png)

Store 명령어(`sw`)는 **레지스터에 값을 쓰는 동작(WB)을 하지 않기 때문에**, 파이프라인의 **마지막 단계(WB)에서는 아무 동작도 수행하지 않는다.** 실제 데이터는 **MEM 단계에서 메모리에 저장되며**, 그 이후 단계에서는 **결과를 다시 레지스터로 되돌릴 필요가 없기 때문에** WB 단계는 단순히 통과만 하게 된다.

---
