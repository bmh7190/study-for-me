
# Parallel Rendom Access Machine (PRAM)

n개의 프로세서는 하나의 전역(shared) 메모리에 연결되어 있다.  
어떤 프로세서든 모든 메모리 위치에 **상수 시간(constant time)** 안에 접근할 수 있으며,  
프로세서 간의 통신은 이 **공유 메모리의 읽기(read)와 쓰기(write)** 를 통해 이루어진다.

즉, 여러 프로세서가 데이터를 서로 직접 주고받는 것이 아니라,  **공유 메모리 공간을 매개로 데이터를 공유**하게 된다.

이제 n개의 프로세서가 동시에 같은 작업을 수행한다고 가정해보자.  

각 작업에서 모든 프로세서는 하나의 **명령 주기(instruction cycle)** 동안 다음의 세 단계를 거쳐 실행된다.

1. **Read Phase (읽기 단계)**:  
    각 프로세서는 동시에 공유 메모리로부터 하나의 데이터를 읽어와 자신의 레지스터(register)에 저장한다.
    
2. **Compute Phase (연산 단계)**:  
    각 프로세서는 레지스터에 저장된 데이터를 이용해 연산을 수행하고,  그 결과를 다시 레지스터에 저장한다.
    
3. **Write Phase (쓰기 단계)**:  
    각 프로세서는 연산 결과를 공유 메모리에 기록한다.  
    이때 **Exclusive Write PRAM** 방식에서는  모든 프로세서가 **서로 다른 메모리 위치에만** 쓸 수 있다.  반면 **Concurrent Write PRAM** 방식에서는 여러 프로세서가 **같은 메모리 위치에 동시에 쓰는 것**도 가능하지만,  이 경우 **경쟁 상태(race condition)** 가 발생할 수 있다.

## PRAM Variants
PRAM 모델에서는 **읽기(Read)** 와 **쓰기(Write)** 가  서로 **배타적(Exclusive)** 인지, 혹은 **동시적(Concurrent)** 인지에 따라 다양한 접근 방식으로 구분할 수 있다.

EREW(Exclusive Read Exclusvie Wrtie) 은 하나의 데이터에 대해서 동시에 읽거나 동시에 쓸 수 없다는 방식이다.

Concurrent Read Exclusive Write(CREW) 은
몇몇의 프로세서는 같은 공유 메모리 셀에 있는 데이터는 동시에 읽을 수 있다. 하지만 다른 프로세서들은 동일한 공유 메모리 셀에 데이터를 작성하지 못한다. 

Concurrent REad Concurrent Write(CRCW)은 같은 공유 메모리 셀에 동시에 데이터를 읽고 쓸 수 있는 방식이다. 동시에 작성하는 경우에는 어떤 데이터가 저장되게 할지 정해줄 필요가 있다.

- Pririty CW:
	프로세서에 우선 순위를 부여해서 동시에 데이터를 작성하는 경우 우선순위가 높은 프로세서가 작성하려는 데이터를 적용하는 방식이다 .

- Arbitrary CW:
	랜덤하게 프로세서를 골라서 그 프로세서가 읽으려는 내용을 반영한다.

- Common CW:
	여러 프로세서가 하나의 공유 데이터 셀에 데이터를 쓰려는 상황에서 작성하려는 데이터가 똑같은 경우에만 반영하고, 하나라도 다르면 변동사항을 적용하지 않는다.

- Combining CW:
	여러 프로세서가 쓰려고 하는 데이터를 모두 반영하는 방식인데 추가 작업을 수행한다. means of ansassociativebinary operations( sum product minimum logical and)

---
# Prarallel Prefix Computation




---
# Parallel Prefix on a PRAM: NAIVE

![](../images/Pasted%20image%2020251012161145.png)

``` c++
for ( j = 0; j<n; j++) do_in_parallel
	reg_j = A[j];
	
for(i = 0; i<cell(log(n)); i++) do
	for(j = pow(2,i); j<n; j++) do_in_parallel {
			reg_j += A[j-pow(2, i)];
			A[j] = reg_j;
	}
```

이 알고리즘은 각 단계에서 **왼쪽으로 2ⁱ만큼 떨어진 값**을 더하는 구조를 가진다.

- **1단계 (i = 0)** → `2⁰ = 1` 칸 왼쪽 값 더함  
    → 바로 이전 원소(`A[j-1]`)를 더한다.
    
- **2단계 (i = 1)** → `2¹ = 2` 칸 왼쪽 값 더함  
    → 2칸 떨어진 원소(`A[j-2]`)까지 누적된다.
    
- **3단계 (i = 2)** → `2² = 4` 칸 왼쪽 값 더함  
    → 4칸 떨어진 원소까지 포함된다.
    
- **4단계 (i = 3)** → `2³ = 8` 칸 왼쪽 값 더함  
    → 8칸 뒤까지 모두 누적된다.
    

이처럼 단계가 진행될수록,  한 프로세서가 커버하는 누적 범위가  
`1 → 2 → 4 → 8 → … → 2ⁱ` 식으로 **2의 거듭제곱으로 확장**된다.

그래서 배열의 크기가 n 이라고 했을 때 모든 원소가 자신의 앞선 원소를 포함하긴 위해서는 2^i 는 n 보다 커야 한다. 

각 단계에서는 상수 시간이 걸린다. 그래서 프로세서가 몇 단계를 거쳤는지 확인하면, 그게 프로세서가 일 하는 시간일 것이고, 전체 단계는 log n 단계가 있으니까 하나의 프로세서가 일 하는 시간 logn이 된다. 
 