

## Spawning and Joining Threads

스레드는 하나의 프로세스 안에서 동시에 여러 작업을 수행하기 위해 만들어진 실행 단위다. 프로그램이 실행되면 운영체제는 기본적으로 하나의 **메인 스레드(또는 마스터 스레드)** 를 생성한다. 우리가 `std::thread` 같은 방법으로 만드는 모든 스레드는 이 메인 스레드로부터 파생된 **자식 스레드**다.

같은 프로세스에 속한 모든 스레드는 **공유 자원**을 함께 사용한다. 이들은 코드 영역, 힙 영역, 전역 변수 공간 등을 공유하기 때문에 같은 메모리 공간에 접근할 수 있다. 이런 구조 덕분에 스레드 간 통신은 별도의 IPC(프로세스 간 통신) 없이 빠르게 이루어질 수 있으며, 낮은 지연 시간(latency)을 가진다는 장점이 있다. 

하지만 동시에 여러 스레드가 동일한 자원에 접근하면 **데이터 경쟁(data race)** 이 발생할 수 있으므로, 반드시 **뮤텍스(mutex)** 나 **조건 변수(condition variable)** 같은 동기화 도구를 사용해야 한다. 참고로 스택 영역은 스레드마다 독립적으로 할당되어 각 스레드의 지역 변수들이 서로 간섭하지 않는다.

![](../images/Pasted%20image%2020251017141305.png)

스레드를 생성하면 메인 스레드와는 독립적으로 실행되지만, 메인 스레드가 그 스레드의 작업이 끝날 때까지 기다리도록 할 수도 있다. 이때 사용하는 함수가 `join()`이다. `join()`을 호출하면 메인 스레드는 해당 스레드가 종료될 때까지 블록 상태로 기다린다. 반대로 `detach()`를 호출하면 해당 스레드는 독립적으로 실행되며, 메인 스레드가 기다리지 않는다. 이 경우 스레드가 끝나면 운영체제가 자동으로 자원을 정리(clean up)한다.

하지만 주의할 점이 있다. 메인 스레드가 종료되면 그 프로세스 자체가 종료되기 때문에, 그 안에서 동작 중이던 모든 스레드도 함께 종료된다. 따라서 `detach()`된 스레드가 아직 작업을 마치지 않았더라도 프로세스가 끝나면 강제적으로 중단된다. 일반적으로는 이런 상황을 방지하기 위해 `join()`으로 모든 스레드의 종료를 기다리거나, 별도의 종료 신호를 통해 안전하게 작업을 마무리하도록 설계한다.

---
## Multithreaded C++11 

```c++
#include <cstdint.h> // uint64_t
#include <vector> // std::vector
#include <thread> // std::thread
// this function will be called by the threads ( should be void )
void say_hello(uint64_t id) {
	std::cout << "Hello from thread: " << id << std::endl;
}

int main(int argc, char* argv[]) { // this runs in the master thread
	const uint64_t num_threads = 4;
	std::vector<std::thread> threads;
	
	for (uint64_t id = 0; id<num_threads; id++) // for all threads
		threads.emplace_back(say_hello, id); // call say_hello with arg. id
	
	for (auto& thread : threads) //join each thread at the end
		thread.join();
}
```

- 일단 무조건 thread가 실행할 함수는 리턴 값이 void이다.
- C++11 부터 쓰레드들은 객체로 관리를 하게 된다.
- thread 타입으로 쓰레드 객체를 생성하고 emplace_back(실행 함수와, 함수 인자)를 통해 쓰레드를 만들고, 그 쓰레드가 할 일을 배정한다. 
- 마지막에는 메인 쓰레드는 자식 쓰레드가 할 일을 끝날 때까지 thread.join을 통해 기다린다.

```c++
std::vector<std::thread> threads;
```

thread 객체를 벡터에 넣어서 한꺼번에 관리한다. `std::thread` 타입의 객체를 담을 수 있는 vector를 생성하고, 이 안에 지금 아무것도 없다.

```c++
thread.emplace_back(say_hello, id);
```

쓰레드 vector 안에 thread 객체를 생성해서 넣어준다. 이때 그 쓰레드들은 say_hello 함수를 수행한다. say_hello 함수 를 사용할 때 필요한 id도 같이 넣어줬다.

지금은 쓰레드 벡터를 만들어서 새로운 쓰레드를 생성해서 넣어줬다.

하지만 그냥 행렬ㅗ 생성할 수 있다!

```c++
std::thread* threads = new std::thread[num_threads];
threads[i] = std::thread(say_hello, id);
```

---
### Join or Detach Threads

```c++
for (auto& thread : threads) thread.join();
for (auto& thread : threads) thread.detach();
```

쓰레드 벡터를 생성하고, 그 안에 새로운 쓰레드를 만들어서 계속넣어줬다. 

- join : 생성된 쓰레드가 끝나길 마스터 쓰레드는 기다린다.
- detach : 기다리지 않고, 그냥 마스터 쓰레드가 끝나면 같이 종료되도록 한다.
- auto& : 복사해서 가져오면 안되기 때문에 auto 타입과 참조를 통해 벡터 안의 행렬에 직접 join 혹은 detach를 한다.


우리는 쓰레드가 join 혹은 detach 되었는지 확인해야 하고, detached 된 쓰레드가 다시 join 될 수 없으며 한번 join되거나 detach된 쓰레드는 다시 사용할 수 없다. 이게 무슨 말이냐면 쓰레드ㅏㄱ 함수의 실행을 끝내고 종료되었을 때 다시 그 쓰레드를 사용할 수 없다는 것이다. 

모든 쓰레드가 join 혹은 detach 될 때는 항상 같은 영역 안 이어야 한다. 

---
### Handle Return Values

```c++
template <typename value_t, typename index_t>
value_t fibo(value_t n) {
	value_t a_0 = 0;
	value_t a_1 = 1;
	
	for (index_t index = 0; index < n; index++) {
		const value_t tmp = a_0;
		a_0 = a_1;
		a_1 += tmp;
	}
	
	return a_0;
}
```


위에서 다뤗듯이 쓰레드가 실행할 함수의 리턴 값은 무조건 void 여야 한다. 하지만 return 값이 필요할 경우 어떻게 해야할까?

```c++

template <typename value_t, typename index_t>
void fibo(value_t n, value_t *result) {
// here we pass the address of result
value_t a_0 = 0;
value_t a_1 = 1;
for (index_t index = 0; index < n; index++) {
const value_t tmp = a_0; a_0 = a_1; a_1 += tmp;
}
*result = a_0;
}
int main(int argc, char* argv[]) { // this runs in the master thread
const uint64_t num_threads = 32;
std::vector<std::thread> threads;
std::vector<uint64_t> results(num_threads, 0); // allocate num_threads result values
for (uint64_t id = 0; id < num_threads; id++)
// specify template parameters and arguments
threads.emplace_back(fibo<uint64_t, uint64_t>, id, &(results[id]));
for (auto& thread : threads) thread.join(); // join the threads
// print the result
for (const auto& result : results) std::cout << result << std::endl;
}
```