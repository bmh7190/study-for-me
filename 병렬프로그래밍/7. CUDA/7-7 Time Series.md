여기서는 시계열(time series) 데이터를 예시로 활용해보려고 한다. 시계열 데이터란 말 그대로 시간의 흐름에 따라 변화하는 값을 기록한 데이터로, 음성 신호, 센서 기록, 주가, 생체신호 등 다양한 분야에서 등장한다. 우리는 여러 개의 시계열 데이터가 주어졌을 때, **서로 얼마나 유사한지 비교해야 하는 상황**을 가정해볼 것이다.


![](../../images/Pasted%20image%2020251204151653.png)
예를 들어 위 그림은 “exact”라는 단어를 미국인과 영국인이 발음한 음성 파형을 각각 시계열로 나타낸 것이다. 두 사람은 같은 단어를 발음했기 때문에 전체적인 파형의 모양은 비슷하다. 지금까지 이미지에서는 단순히 유클리디안 거리(Euclidean distance)를 이용해 두 데이터가 비슷한지 판별할 수 있었다. 이미지의 경우 각 픽셀이 고정된 위치를 갖고 있기 때문에 같은 위치의 값을 비교하면 의미가 있기 때문이다.

하지만 시계열 데이터는 상황이 다르다. 같은 파형이라도 **언제 피크가 발생했는지**, 즉 **시간이 얼마나 빨리 혹은 늦게 흐르는지**에 따라 모양이 어긋날 수 있다. 예를 들어 두 사람이 같은 단어를 말하더라도 한 사람은 조금 더 천천히 말하고, 다른 사람은 더 빠르게 말할 수 있다. 이럴 때 단순히 같은 시점(time index)의 값을 빼서 거리를 계산해버리면, 실제로는 유사한 두 신호가 서로 다르게 보일 수 있다.

## Dynamic Time Warping (DTW)
그래서 이번에는 이러한 시간 차이를 보정해가며 유사도를 계산할 수 있는 방법, 즉 **Dynamic Time Warping(DTW)** 을 적용해볼 것이다. 쉽게 말하면, DTW는 두 시계열의 특정 시점들이 꼭 일대일로 대응하지 않더라도, **시간 축을 자유롭게 늘였다 줄였다 하면서 가장 잘 맞는 정렬(alignment)을 찾아주는 방법**이다. 다시 말해, “이 두 시계열이 서로 얼마나 비슷하게 생겼는가?”를 **시간의 왜곡을 허용한 상태에서 계산**할 수 있게 해주는 알고리즘이다.

DTW를 이해하기 위해서는 먼저, 두 시계열을 어떻게 “정렬”하는지를 그래프로 표현한 DAG(Directed Acyclic Graph) 구조를 살펴볼 필요가 있다. 아래 그림은 길이가 각각 4인 두 시계열에 대해 DTW 거리 계산 과정에서 등장하는 DAG의 한 예시이다. 이 그래프의 각 노드는 두 시계열의 특정 시점 조합 $(i,j)$을 나타내며, DTW는 이 노드들을 연결하는 경로 중 비용이 최소가 되는 경로를 찾는 과정이라고 볼 수 있다.

![](../../images/Pasted%20image%2020251204152921.png)


이 그래프에는 다음과 같은 핵심 제약 조건들이 존재한다.

1. **Continuity(연속성)**  
    노드 간 이동은 항상 한 칸씩만 가능하며, 이동 방향은 가로, 세로, 대각선의 세 가지뿐이다.  
    즉, $(i, j) \rightarrow (i+1, j), (i, j+1), (i+1, j+1)$ 형태로만 이동할 수 있다.  
    이를 통해 warping path가 불연속적으로 점프하지 않도록 제한한다.
    
2. **Monotony(단조성)**  
    이동할 때마다 적어도 하나의 인덱스가 증가해야 한다.즉, 시간축을 거꾸로 되돌아가거나 감소하는 방향으로 움직일 수 없다. 이는 시계열의 시간 흐름을 보존한다는 뜻이다.
    
3. **Bounding(경계 조건)**  
    최적의 warping path는 **왼쪽 위(0,0)** 에서 시작하여 **오른쪽 아래(n−1, m−1)** 에서 끝나야 한다. 다시 말해, 두 시계열의 처음과 끝이 반드시 서로 매칭되어야 한다.
    

이 세 가지 조건이 만족되는 경로들 중에서, 각 노드에서의 시계열 간 “거리”(예: |x[i] − y[j]|)를 누적했을 때 총 비용이 가장 작은 경로가 바로 **DTW가 말하는 최적 warping path**이다.  

그 경로 위의 노드들이 두 시계열이 시간 왜곡을 허용한 상태에서 어떻게 서로 “최적으로 정렬되는지”를 보여준다.

---
![](../../images/Pasted%20image%2020251204153822.png)

DTW 계산은 크게 두 단계로 나눌 수 있다. 먼저, 두 시계열의 모든 시점 쌍을 서로 비교하여 **local cost**, 즉 해당 지점 간의 거리(weight)를 계산한다. 이 단계는 일종의 weighting function을 적용하는 과정이라고 볼 수 있다. 가장 단순한 경우에는 두 시계열 값의 차이를 제곱한 값 $(x_i - y_j)^2$을 local cost로 사용한다. 즉, query 시계열과 subject 시계열의 각 포인트 간 유사도를 전체적으로 계산해 cost matrix를 채우는 것이다.

그 다음 단계에서는 이 local cost들을 기반으로, 시계열의 처음 지점에서 끝 지점까지 이동하는 **누적 비용**을 계산하여 최적 경로를 찾는다. 이때 DTW는 반드시 세 가지 조건, 즉 **연속성**, **단조성** , **경계 조건을 만족해야 한다. 이를 반영하면 현재 (i, j) 위치에서 다음 위치로 이동할 수 있는 방향은 오직 세 가지뿐이다:

- 오른쪽 방향 (i, j+1)
- 아래 방향 (i+1, j)
- 오른쪽 아래 대각선 (i+1, j+1)

즉, grid 상에서 “뒤로 가는” 것 또는 큰 점프는 허용되지 않는다.

누적 비용을 채울 때는 각 셀 (i, j)에 대해, local cost(i, j)에 더해 **왼쪽, 위쪽, 대각선 위** 이 세 셀 중 누적 비용이 가장 작은 값을 선택하면 된다. DTW는 동적 계획법(DP)을 사용하기 때문에, 이전까지의 비용이 이미 누적되어 있고, 현재 위치에서는 세 방향 중 가장 비용이 작은 경로를 확장하는 것이 전체 경로의 최적 해를 보장한다.

이 과정을 시작점인 (0,0)부터 끝점인 (n−1, m−1)까지 반복하면, 마지막 셀에 도달했을 때 저장된 값이 두 시계열 사이의 **최소 warping cost**, 즉 DTW 거리이다. 이 값이 가장 낮은 정렬 경로가 두 시계열이 시간 왜곡을 허용한 상태에서 가장 비슷하게 매칭되는 형태를 나타낸다.

---
## Dynamic Programming Formulation of DTW

이제 각 과정을 자세하게 알아보자.

![](../../images/Pasted%20image%2020251204154615.png)

왼쪽 그림은 DTW 알고리즘의 첫 번째 단계인 **weight matrix**, 즉 두 시계열의 각 시점에서 값을 빼고 제곱하여 얻은 local cost들을 모아놓은 행렬을 나타낸 것이다. 시계열 길이가 4라면 이 행렬은 4×4 크기가 된다. 그 다음 단계에서는 이 weight matrix를 기반으로 실제 최단 경로를 찾기 위한 **DP matrix(누적 비용 행렬)** 을 구성하는데, 이 DP 행렬의 크기가 4×4가 아닌 5×5인 이유는 경계 조건을 처리하기 위해 padding을 한 줄씩 추가하기 때문이다. 이렇게 하면 DP를 채우는 과정에서 인덱스 예외 처리를 하지 않아도 되고, 시작점과 초기값을 명확히 정의할 수 있다.

![](../../images/Pasted%20image%2020251204155115.png)

DP matrix를 채울 때는 DTW의 이동 규칙을 따라, 특정 칸에 도달하기 위해 가능한 세 가지 이전 위치—왼쪽, 위쪽, 왼쪽 위 대각선—중 누적 비용이 가장 작은 값에 현재 weight 값을 더해 적는다. 즉, 실제 이동 방향은 오른쪽, 아래, 대각선 아래로 “전진”하지만, 비용 계산은 그 반대 방향을 참조하여 “어디서 왔을 때 가장 비용이 적은지”를 판단하는 방식으로 이루어진다. 이 과정을 테이블 끝까지 반복하면, 마지막 셀(오른쪽 아래 모서리)에 기록된 값이 두 시계열 사이의 최소 누적 거리, 즉 DTW 거리가 된다.