일단 Transport Layer에서 TCP를 사용한다면 segment 라는 단위로서 데이터를 보내게 된다. 이 segment는 헤더와 데이터, 즉 페이로드로 이어져있다. 헤더는 기본 20byte이지만 옵션을 사용하면 최대 60byte까지 데이터가 들어갈 수 있다.

![](../images/Pasted%20image%2020250917005728.png)


![](../images/Pasted%20image%2020250917005804.png)

헤더는 가로 32비트(4바이트) 단위로 구성되며, 기본적으로 5줄(=20바이트) 크기를 가진다. 따라서 이 20바이트 안에 TCP의 핵심 정보들이 모두 포함된다.

### Port Address
가장 먼저 확인할 부분은 포트 주소다. 송신자와 수신자의 포트 번호가 들어가는데, 데이터를 보낼 때는 운영체제가 자동으로 송신 포트를 지정해 준다. 이 과정에서 한 가지 의문이 생길 수 있다. 컴퓨터에는 총 2¹⁶개(65,536개)의 포트가 있고, 특정 번호를 직접 지정할 수도 있다. 그렇다면 어떻게 수신 측 컴퓨터가 데이터를 받을 ‘입구 포트’를 정확히 알 수 있을까?

그 답은 애플리케이션 계층에서 사용하는 **프로토콜의 약속**에 있다. 우리가 애플리케이션 계층에서 데이터를 메시지 형태로 표현할 때, HTTP·FTP 같은 프로토콜은 각각 정해진 형식을 따르고, 이 프로토콜마다 기본적으로 사용하는 포트 번호가 미리 약속되어 있다. 예를 들어 HTTP라면 80번 포트, HTTPS라면 443번 포트가 사용된다. 이렇게 전 세계적으로 약속된 규칙 덕분에 송신자는 목적지의 프로토콜에 맞는 포트 번호를 TCP 헤더에 넣어 보낼 수 있고, 수신 측은 해당 포트를 통해 데이터를 정확히 받아 처리할 수 있는 것이다.

### Sequence Number
TCP는 **스트림 전달(stream delivery)** 방식을 사용한다. 즉, 상위 계층(예: 애플리케이션 계층)에서 내려온 데이터를 고정된 블록 단위로 자르는 것이 아니라, TCP가 상황(네트워크 상태, 혼잡 정도, 윈도우 크기 등)에 맞게 임의의 크기로 잘라낸다. 이렇게 잘라낸 각 조각에는 TCP 헤더가 붙고, 이 헤더에는 데이터의 순서를 식별할 수 있는 **Sequence Number(순서 번호)** 가 포함된다.

이 Sequence Number는 **데이터 스트림 내에서 현재 세그먼트의 첫 번째 바이트가 원래 전체 데이터 흐름에서 몇 번째 위치인지**를 나타낸다. 예를 들어, 전체 데이터 스트림이 10,000바이트라고 할 때, 처음 보낸 세그먼트의 Sequence Number가 1000이라면, 이 세그먼트의 첫 바이트는 전체 스트림에서 1000번째 바이트라는 뜻이다.

특히, **연결을 시작할 때 최초의 Sequence Number(ISN, Initial Sequence Number)는 랜덤하게 선택**된다. 이는 보안상의 이유(예상 불가능하게 하여 세션 하이재킹 공격 방지)와 동시에 중복된 연결을 방지하기 위함이다. 이후 송신자는 보낸 바이트 수만큼 Sequence Number를 증가시키면서 전송을 이어간다.

### Acknowledgement Number
이번에는 **응답 번호(Acknowledgment Number, ACK Number)** 에 대해 보자.
TCP는 단순히 데이터를 보내는 데서 끝나는 것이 아니라, **상대방이 데이터를 잘 받았는지 확인**까지 한다. 그래서 송신 측은 보낸 데이터를 곧바로 버리지 않고, **버퍼에 임시로 저장**해 둔다. 이후 수신 측으로부터 “데이터를 잘 받았다”는 신호(ACK)가 오면 그제서야 해당 데이터를 버퍼에서 제거한다.

여기서 ACK는 **누적 확인(cumulative acknowledgment)** 방식을 사용한다. 즉, “내가 지금까지 받은 데이터는 모두 정상이고, 이제 다음 Sequence Number부터 보내라”는 식으로 알려준다. 이 말은 ACK Number는 단순히 “다음에 받을 것으로 기대하는 바이트 번호”를 의미한다. 

예를 들어, 송신자가 **Sequence Number = 10000**인 세그먼트를 보냈다고 하자. 수신자가 이 세그먼트를 문제없이 받았다면, 응답으로 **ACK Number = 10001**을 보낸다. 이 말은 “10000번 바이트까지 다 받았으니, 이제 10001번부터 보내라”라는 뜻이다. 만약 10000~10099까지 총 100바이트를 보냈다면, 수신자는 잘 받았다는 의미로 **ACK Number = 10100**을 보낼 것이다.

### HLEN
TCP 헤더의 길이를 나타내는 필드는 **Header Length (Data Offset)** 이라고 부른다.

기본 TCP 헤더는 **20바이트**이고, 옵션 필드가 붙으면 최대 **60바이트**까지 늘어난다. 문제는 실제 전송 시 데이터는 `010101...` 같은 이진수 형태로 전송되기 때문에, 수신 측은 “어디까지가 헤더이고 어디부터가 데이터인지”를 구분할 수 있어야 한다. 이를 위해 TCP 헤더 안에 **헤더의 길이를 표시하는 필드**를 둔다.

이 필드는 단순히 바이트 단위가 아니라 **4바이트(=32비트) 단위**로 길이를 기록한다.

예를 들어, 기본 헤더는 20바이트 → `20 ÷ 4 = 5` → 필드 값은 `0101(=5)`
만약 헤더가 60바이트라면 → `60 ÷ 4 = 15` → 필드 값은 `1111(=15)`

즉, **송신 측은 헤더 길이를 4로 나눈 값을 기록**하고, **수신 측은 그 값을 4배 해서 실제 헤더 길이를 계산**한다. 이렇게 하면 헤더 길이를 나타내는 데 필요한 비트를 줄일 수 있다. 실제로는 **4비트**(2⁴ = 16가지 값)만 있으면 충분하다. 그 결과 헤더 길이는 최소 20바이트(5 × 4)부터 최대 60바이트(15 × 4)까지 표현할 수 있다.