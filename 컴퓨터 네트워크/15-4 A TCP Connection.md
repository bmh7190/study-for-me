TCP는 **패킷 교환(Packet Switching)** 방식을 사용하는 네트워크 위에서 동작하지만,  
그 위에서 마치 **회선 교환(Circuit Switching)** 과 비슷한 형태로  
**논리적인 연결(Logical Connection)** 을 설정한다.

TCP는 물리적으로는 **패킷 교환 방식**을 사용하지만,  
논리적으로는 송신자와 수신자 사이에 **연결이 설정된 것처럼 동작한다.**

즉, TCP는 연결을 설정할 때 **3-way handshake** 과정을 통해 양쪽이 사용할 **IP 주소, 포트 번호, 시퀀스 번호 등**을 교환한다. 이 정보들을 바탕으로 TCP는 두 호스트 간에 **논리적인 통신 경로**를 만든다.

이 논리적 연결을 통해 송신자는 데이터를 **순서대로, 신뢰성 있게** 전송하고 수신자는 데이터를 **정확히 재조립하고 확인(ACK)** 한다.

비록 실제로는 네트워크 내부에서 패킷이 여러 경로로 흩어져 이동하지만,  
TCP는 이를 감추고 **마치 두 호스트가 전용 회선으로 연결된 것처럼 보이게 한다.**


---
### three-way handshake
TCP에서 연결을 설정할 때는 **Three-Way Handshake(3단계 연결 설정)** 방식을 사용한다.  

이 과정은 클라이언트와 서버가 서로를 인식하고,  
양방향으로 데이터를 안전하게 주고받을 준비가 되었음을 확인하기 위한 절차이다.

![](../images/Pasted%20image%2020251014141322.png)
##### [1단계] 클라이언트 -> 서버
클라이언트가 서버에 연결을 요청할 때, TCP 헤더의 **Control Bit 중 SYN**(Synchronize) 비트를 **1로 설정**한 세그먼트를 보낸다. 이 SYN 세그먼트에는 클라이언트가 선택한 **초기 순서 번호(ISN, Initial Sequence Number)** 가 포함되어 있다.  

서버는 이 패킷을 받고 “연결 요청이 들어왔구나!” 라고 인식한다.
##### **[2단계] 서버 → 클라이언트**  
서버는 클라이언트의 SYN을 받은 후, 연결 요청에 대한 응답으로 자신의 **SYN** 비트와 **ACK** 비트를 모두 1로 설정한 세그먼트를 보낸다.

- **SYN** : 서버도 클라이언트에게 연결 요청을 보냄
    
- **ACK** : 클라이언트의 SYN 요청을 잘 받았다는 확인 응답
    
즉, 서버는 클라이언트에게 “너의 연결 요청 잘 받았고, 나도 연결하길 원해!”라는 의미의  
**SYN+ACK** 세그먼트를 보낸다.

##### **[3단계] 클라이언트** 
클라이언트는 서버의 **SYN+ACK** 세그먼트를 받으면, 이에 대한 확인 응답으로 **ACK 비트**를 1로 설정한 세그먼트를 보낸다. 이때부터 양쪽 모두 연결이 완료되었다고 인식하며, 데이터를 주고받을 준비가 완료된다.


---

1. SYN 세그먼트는 데이터를 담고 있지 않는다. 하지만 하나의 sequence number 가진 상태로 연결 요청을 한다.
2. SYN+ACK 세그먼트도 데이터를 담고 있지 않지만 하나의 sequence number 를 포함된다.
3. 마지막 ACK도 데이터를 담고 있지 않지만, 하나의 sequence number 를 포함한다.

---
### Data Transfer

다음은 TCP에서 데이터를 어떻게 보내는지에 대해서 보자 

![](../images/Pasted%20image%2020251014142116.png)

이 예시에서 보자며 seq 8001 번으로 데이터 하나 보냈고, 9001번인 데이터르 하나 보냈다. 1000byte씩 끊어서 보내는 것을 알 수 있고, 서버는 이것을 다 받아서 처리햇으면 8001 ~ 10000까지 바이트를처리했기 때문에 10001을 ACK 번호로 해서 넣어서 다시 보내게 된다. 

이떄 서버도 데이터를 보낼 수 있기 때문에 15001을 seq번호로 해서 보낸다. 2000byte씩 보낸다고 했을  클라이언트도 데이터를 다 받았으면 17001을 ACK으로 넣어서 보낸다.