TCP는 **패킷 교환(Packet Switching)** 방식을 사용하는 네트워크 위에서 동작하지만,  
그 위에서 마치 **회선 교환(Circuit Switching)** 과 비슷한 형태로  
**논리적인 연결(Logical Connection)** 을 설정한다.

TCP는 물리적으로는 **패킷 교환 방식**을 사용하지만,  
논리적으로는 송신자와 수신자 사이에 **연결이 설정된 것처럼 동작한다.**

즉, TCP는 연결을 설정할 때 **3-way handshake** 과정을 통해 양쪽이 사용할 **IP 주소, 포트 번호, 시퀀스 번호 등**을 교환한다. 이 정보들을 바탕으로 TCP는 두 호스트 간에 **논리적인 통신 경로**를 만든다.

이 논리적 연결을 통해 송신자는 데이터를 **순서대로, 신뢰성 있게** 전송하고 수신자는 데이터를 **정확히 재조립하고 확인(ACK)** 한다.

비록 실제로는 네트워크 내부에서 패킷이 여러 경로로 흩어져 이동하지만,  
TCP는 이를 감추고 **마치 두 호스트가 전용 회선으로 연결된 것처럼 보이게 한다.**


---
### 연결 시작: three-way handshake
TCP에서 연결을 설정할 때는 **Three-Way Handshake(3단계 연결 설정)** 방식을 사용한다.  

이 과정은 클라이언트와 서버가 서로를 인식하고,  
양방향으로 데이터를 안전하게 주고받을 준비가 되었음을 확인하기 위한 절차이다.

![](../images/Pasted%20image%2020251014141322.png)
##### [1단계] 클라이언트 -> 서버
클라이언트가 서버에 연결을 요청할 때, TCP 헤더의 **Control Bit 중 SYN**(Synchronize) 비트를 **1로 설정**한 세그먼트를 보낸다. 이 SYN 세그먼트에는 클라이언트가 선택한 **초기 순서 번호(ISN, Initial Sequence Number)** 가 포함되어 있다.  

서버는 이 패킷을 받고 “연결 요청이 들어왔구나!” 라고 인식한다.
##### **[2단계] 서버 → 클라이언트**  
서버는 클라이언트의 SYN을 받은 후, 연결 요청에 대한 응답으로 자신의 **SYN** 비트와 **ACK** 비트를 모두 1로 설정한 세그먼트를 보낸다.

- **SYN** : 서버도 클라이언트에게 연결 요청을 보냄
    
- **ACK** : 클라이언트의 SYN 요청을 잘 받았다는 확인 응답
    
즉, 서버는 클라이언트에게 “너의 연결 요청 잘 받았고, 나도 연결하길 원해!”라는 의미의  
**SYN+ACK** 세그먼트를 보낸다.

##### **[3단계] 클라이언트** 
클라이언트는 서버의 **SYN+ACK** 세그먼트를 받으면, 이에 대한 확인 응답으로 **ACK 비트**를 1로 설정한 세그먼트를 보낸다. 이때부터 양쪽 모두 연결이 완료되었다고 인식하며, 데이터를 주고받을 준비가 완료된다.


---

1. SYN 세그먼트는 데이터를 담고 있지 않는다. 하지만 하나의 sequence number 가진 상태로 연결 요청을 한다.
2. SYN+ACK 세그먼트도 데이터를 담고 있지 않지만 하나의 sequence number 를 포함된다.
3. 마지막 ACK도 데이터를 담고 있지 않지만, 하나의 sequence number 를 포함한다.

---
### Data Transfer

TCP에서 데이터 통신은 양방향으로 이루어진다.  

즉, 클라이언트와 서버 모두 데이터를 보낼 수도 있고 받을 수도 있다. 이때 각 방향의 전송은 **별도의 Sequence Number(순서 번호)** 와 **ACK Number(확인 응답 번호)** 로 관리된다.

![](../images/Pasted%20image%2020251014142116.png)

예를 들어, 클라이언트가 서버에게 **1000바이트씩 데이터를 전송**한다고 하자.  

##### ① 클라이언트 → 서버

예를 들어, 클라이언트가 서버에게 **1000바이트씩 데이터를 전송**한다고 하자.  

첫 번째 세그먼트의 **Sequence Number(SEQ)** 가 **8001**이라면, 그 세그먼트는 **8001번부터 9000번까지의 바이트**를 포함한다. 다음 세그먼트는 **SEQ = 9001**, 즉 **9001~10000번 바이트** 구간을 전송한다.

서버는 이 데이터를 모두 수신하고 확인하면, “8001~10000까지 잘 받았다”는 의미로 **ACK = 10001**을 담은 세그먼트를 클라이언트에게 보낸다.  

이 ACK 번호는 **“다음에 받을 것으로 기대하는 바이트의 번호”** 를 뜻한다.

##### ② 서버 → 클라이언트

한편, TCP는 **양방향 통신(Full Duplex)** 을 지원하므로, 서버도 동시에 데이터를 클라이언트로 전송할 수 있다.

예를 들어 서버가 데이터를 **2000바이트 단위**로 보낸다고 하고, 이때 서버의 **SEQ = 15001**이라면, 이 세그먼트에는 **15001~17000번 바이트**가 포함된다.

클라이언트가 이를 모두 수신했다면, “17000번까지 잘 받았다”는 의미로 **ACK = 17001**을 서버에게 보낸다.

---
### 연결 종료: Three-way handshake

TCP에서 연결을 종료할 때도 **연결 설정 때와 마찬가지로** 양방향 통신을 고려한 **Handshake 방식**을 사용한다. 이때 사용되는 제어 비트는 **FIN (Finish)** 과 **ACK (Acknowledgment)** 이다.

![](../images/Pasted%20image%2020251014142824.png)

##### 기본적인 연결 종료 과정 (Four-Way Handshake)

TCP는 **양방향 통신(Full Duplex)** 이므로, 각 방향의 데이터 전송을 **독립적으로 종료**해야 한다.  
따라서 한쪽이 먼저 종료 요청을 보내더라도, 상대방은 아직 보낼 데이터가 남아 있을 수 있다.  
이 때문에 보통은 다음과 같은 **4단계(Four-Way Handshake)** 로 종료된다:

1. **클라이언트 → 서버 : FIN 전송**  
    클라이언트가 더 이상 보낼 데이터가 없을 때,  
    **FIN 플래그**가 켜진 세그먼트를 서버로 보낸다.  
    → “이제 나는 데이터 전송을 끝낼게요.”
    
2. **서버 → 클라이언트 : ACK 전송**  
    서버는 FIN을 수신하고, 이에 대한 **ACK**을 보낸다.  
    → “네, 당신이 끝낸 건 알겠어요.”  
    하지만 서버는 아직 자신의 데이터를 보낼 수도 있으므로, 연결은 완전히 종료되지 않는다.
    
3. **서버 → 클라이언트 : FIN 전송**  
    서버도 모든 데이터를 다 보냈다면,  
    자신의 연결을 닫기 위해 **FIN 플래그**가 켜진 세그먼트를 전송한다.
    
4. **클라이언트 → 서버 : ACK 전송**  
    클라이언트는 서버의 FIN을 수신한 뒤,  
    마지막으로 **ACK**을 보내며 연결을 완전히 종료한다.  
    이후 클라이언트는 일정 시간(**TIME_WAIT**) 동안 대기했다가 소켓을 완전히 닫는다.
    

##### FIN+ACK이 합쳐지는 경우 (Three-Way Termination)

만약 서버가 클라이언트의 FIN을 받자마자 자신의 데이터 전송도 이미 끝난 상태라면,  
**ACK과 FIN을 동시에 묶어서 한 세그먼트로 보낼 수도 있다.**

이 경우 과정이 이렇게 단축된다:

1. 클라이언트 → 서버 : FIN
    
2. 서버 → 클라이언트 : FIN + ACK
    
3. 클라이언트 → 서버 : ACK
    

즉, **ACK과 FIN이 한 번에 묶여 전송**되면서 연결 종료가 **Three-Way Handshake** 형태로 수행된다.

---

### Half-Close

연결을 하게 되면, 서로 receving 버퍼와 sending 버퍼를 가지게 되는데, 연결이 종료될 때에는 이것들이 바로 사라지지 않는다. 

Clinet는 먼저 연결 종료를 요청하고, 