### 복습 Packet Switching vs Circuit Switching

우리가 통신을 하는 방식은 크게 **Packet Switching** 과 **Circuit Switching** 두 가지로 나눌 수 있다.  이 두 방식의 가장 큰 차이점은 **“경로를 어디서, 어떻게 설정하느냐”** 에 있다.

먼저 **패킷 교환 방식**은 중앙에서 전체 경로를 미리 정하지 않는다. 송신지와 수신지의 주소만 알면 되고, 중간 경로는 각 라우터가 그때그때 네트워크 상황에 따라 **동적으로 결정**한다.  
데이터는 일정 크기의 **패킷 단위**로 쪼개져 각각 독립적으로 전송되며, 서로 다른 경로를 통해 도착할 수도 있다.  이 때문에 모든 패킷이 반드시 같은 경로를 거치지는 않는다.  

중앙에서 경로를 통제하지 않기 때문에 **모니터링이나 제어가 어렵고**, 네트워크의 혼잡도에 따라 **전송 지연 시간이 일정하지 않다.**  하지만 여러 사용자가 네트워크 자원을 효율적으로 공유할 수 있고, 필요할 때만 전송하므로 전체적인 자원 활용률이 높다는 장점이 있다.  

우리가 사용하는 **인터넷이 바로 이 패킷 교환 방식**을 기반으로 동작한다.

반면 **회선 교환 방식**은 통신을 시작하기 전에 송신자와 수신자 사이의 **경로를 중앙에서 미리 설정**한다.  즉, 데이터를 주고받기 전에 하나의 **전용 회선(회로)** 을 확보하고, 통신이 끝날 때까지 그 경로가 **고정적으로 유지**된다.  

이 회선은 다른 트래픽의 영향을 받지 않기 때문에 **일관된 속도와 안정적인 품질**을 보장할 수 있다.  하지만 모든 사용자가 동시에 회선을 요청하면 사용할 수 있는 경로가 부족해 **연결 자체가 불가능한 상황**이 발생할 수도 있다. 또한 한 번 연결된 회선은 통신이 끝날 때까지 점유되므로, 자원 활용 효율이 낮다는 단점이 있다.  

전화 통신이 대표적인 회선 교환 방식의 예다.

---

우리가 지금 보려는 개념은 **네트워크의 혼잡(Congestion)** 이다.  

![](../images/Pasted%20image%2020251014004547.png)


만약 라우터와 라우터 사이의 **전송 용량이 100Mbps**라고 가정하자.  
이때 어떤 하나의 경로에서 데이터가 이 **100Mbps 전송 용량을 모두 사용하고 있다면**,  
그 구간은 **혼잡한(congested)** 상태라고 할 수 있다.

즉, 라우터가 처리할 수 있는 용량(대역폭, Bandwidth)을 이미 모두 사용하고 있기 때문에  
추가적인 데이터가 들어오면 **지연(latency)** 이 발생하거나 **패킷이 손실(loss)** 될 가능성이 커진다.  
이런 상태를 **네트워크 혼잡**이라고 부르며,  
혼잡이 심해질수록 전체 네트워크 성능이 급격히 저하될 수 있다.

![](../images/Pasted%20image%2020251014005528.png)


여기 그래프를 보면, **x축은 Load(부하)**, 즉 **데이터를 보내는 양**을 나타내고, 
**y축은 Delay(지연 시간)** 을 나타낸다.

처음에는 네트워크 부하가 적을 때, 데이터를 조금씩 더 보내더라도 지연 시간은 거의 증가하지 않는다.  하지만 부하가 점점 커져서 **라우터나 링크의 전송 용량(Capacity)** 에 가까워질수록, 즉 **최대 처리 속도(예: 100Mbps)** 에 도달할수록 **지연 시간(Delay)** 이 **급격하게 증가**하는 것을 볼 수 있다.


![](../images/Pasted%20image%2020251014005714.png)

이번 그래프에서 **x축은 데이터 전송량(Load)**, 즉 네트워크에 보내는 데이터의 양을 나타내고,  
**y축은 처리량(Throughput)**, 즉 단위 시간당 실제로 전송이 성공적으로 완료된 데이터의 양을 나타낸다.

처음에는 데이터 전송량이 증가함에 따라 처리량도 함께 증가한다. 그러나 일정 수준을 넘어가면서 **네트워크에 혼잡(Congestion)** 이 발생하면 상황이 달라진다.  

혼잡이 생기면 라우터의 **버퍼(Buffer)** 가 가득 차게 되고, 새로 들어오는 패킷은 **버퍼에 저장되지 못하고 즉시 버려지게 된다**. 이때 송신자는 패킷이 손실되었음을 직접 알 수 없기 때문에, **ACK(확인 응답)** 이 오지 않거나 **Timeout** 또는 **Fast Retransmission** 메커니즘을 통해 손실된 패킷을 **다시 재전송**하게 된다.

문제는 이러한 재전송이 **혼잡 상태에서는 계속 반복될 수 있다는 점**이다.  

즉, 네트워크가 과부하 상태일수록 손실과 재전송이 늘어나고, 그 결과 실제로 단위 시간당 성공적으로 전달되는 데이터의 양(Throughput)은 오히려 **감소**하게 된다.

결국 그래프를 보면, **처리량은 초기에는 부하 증가와 함께 상승하다가**, **최대 용량(Capacity, 예: 100Mbps)** 을 넘는 시점부터는 혼잡으로 인해 급격히 **하락**하는 모습을 보인다.  

이 구간이 바로 네트워크의 **혼잡 구간(Congestion Region)** 이며, TCP 혼잡 제어 알고리즘이 동작해야 하는 핵심 구간이다.

---
### Slow start, exponential increase

네트워크에서 혼잡이 발생하더라도, TCP는 이를 스스로 감지하고 조절할 수 있는 **혼잡 제어(Congestion Control)** 메커니즘을 가지고 있다.

우리가 앞서 배운 **흐름 제어(Flow Control)** 에서는 수신 측이 받을 수 있는 데이터의 양을 의미하는 **rwnd (Receiver Window)** 를 기준으로 윈도우 크기를 조절했다. 그러나 실제 전송 속도를 결정하는 데에는 수신 측의 상태뿐 아니라, **네트워크 전체의 혼잡도**도 고려되어야 한다. 이때 TCP는 **cwnd (Congestion Window)** 라는 개념을 추가로 사용한다.

즉, **rwnd**는 “수신자가 얼마나 받을 수 있는가”를 나타내는 값이라면, **cwnd**는 “현재 네트워크가 얼마나 감당할 수 있는가”를 나타내는 값이다.  TCP는 이 두 값 중 더 작은 값을 실제 윈도우 크기로 선택하여 전송량을 조절한다. 이때 cwnd는 중앙에서 알려주는 값이 아니라, 송신 측이 스스로 네트워크 상태를 관찰하며 동적으로 계산한다.

만약 cwnd가 존재하지 않는다면, 수신 측이 매우 큰 rwnd를 보내왔을 때 송신 측은 한 번에 엄청난 양의 데이터를 전송하게 된다. 그 결과 네트워크가 한순간에 과부하되어 **혼잡(Congestion)** 이 발생할 수 있다. 이를 방지하기 위해 TCP는 처음에는 **cwnd를 1 MSS (Maximum Segment Size)** 로 설정한 뒤, 네트워크의 상태를 살펴보며 점진적으로 전송 속도를 늘려 나간다.

![](../images/Pasted%20image%2020251014204555.png)

이 과정이 바로 **Slow Start Algorithm(느린 시작 알고리즘)** 이다.

이름은 ‘느린 시작’이지만, 실제로는 매우 빠르게 증가한다. 처음에는 cwnd가 1 MSS로 시작하고, 데이터를 전송한 뒤 **ACK을 받을 때마다 cwnd를 두 배씩 증가**시킨다. 즉, 첫 번째 라운드에서는 cwnd = 1, 두 번째에는 2, 세 번째에는 4, 그다음에는 8 MSS로 증가하는 식이다. 이처럼 지수적으로 성장하기 때문에 네트워크의 여유 용량을 빠르게 탐색할 수 있다.

다만 cwnd가 무한정 커지면 결국 다시 혼잡이 발생할 수 있으므로, TCP는 **threshold(임계값)** 를 정해두고, cwnd가 이 값에 도달하기 전까지는 두 배씩 증가시키지만, 이후부터는 증가 속도를 줄여 점진적으로 늘려 나간다. 이 임계값은 네트워크 상태를 고려하기보다는 시스템이 설정한 **기본값(default 값)** 에 의해 정해진다.

결국 **Slow Start Algorithm**은 이름처럼 처음에는 천천히 시작하는 것이 아니라, “Flow Control에 비해 상대적으로 느린 시작을 보인다”는 의미를 가진다.

---
### 혼잡 회피
TCP의 **혼잡 제어(Congestion Control)** 는 단순히 전송 속도를 늘리거나 줄이는 것이 아니라,  
네트워크의 상태를 관찰하면서 **점진적으로 안전한 수준의 전송량을 유지**하려는 과정이다.

앞서 설명한 **Slow Start 단계**에서는 cwnd(Congestion Window)가 **ACK을 받을 때마다 2배씩 증가**했다. 그러나 cwnd가 **임계값(Threshold, ssthresh)** 에 도달하면 TCP는 더 이상 지수적으로 증가시키지 않고, **혼잡 회피(Congestion Avoidance)** 단계로 진입한다.

![](../images/Pasted%20image%2020251014205230.png)

threshold를 넘게 되면 cwnd는 그대로 유지되거나 감소되는게 아니라 1씩 증가하게 된다.

실제로는 보낼 수 있는 만큼 전부 보내기 때문에 요청이 여러개일 것이다. 그리고 이 여러개에 대해 전부 ACK이 다 오면 혼잡하지 않다고 판단하고 cwnd를 1증가시킨다. 이때 RTT 즉 데이터를 보내고 ACK이 날라온 시간마다 window size는 편하게 되는거 ㅅ이다.