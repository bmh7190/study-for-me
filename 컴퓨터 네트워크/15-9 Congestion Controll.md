### 복습 Packet Switching vs Circuit Switching

우리가 통신을 하는 방식은 크게 **Packet Switching** 과 **Circuit Switching** 두 가지로 나눌 수 있다.  이 두 방식의 가장 큰 차이점은 **“경로를 어디서, 어떻게 설정하느냐”** 에 있다.

먼저 **패킷 교환 방식**은 중앙에서 전체 경로를 미리 정하지 않는다. 송신지와 수신지의 주소만 알면 되고, 중간 경로는 각 라우터가 그때그때 네트워크 상황에 따라 **동적으로 결정**한다.  
데이터는 일정 크기의 **패킷 단위**로 쪼개져 각각 독립적으로 전송되며, 서로 다른 경로를 통해 도착할 수도 있다.  이 때문에 모든 패킷이 반드시 같은 경로를 거치지는 않는다.  

중앙에서 경로를 통제하지 않기 때문에 **모니터링이나 제어가 어렵고**, 네트워크의 혼잡도에 따라 **전송 지연 시간이 일정하지 않다.**  하지만 여러 사용자가 네트워크 자원을 효율적으로 공유할 수 있고, 필요할 때만 전송하므로 전체적인 자원 활용률이 높다는 장점이 있다.  

우리가 사용하는 **인터넷이 바로 이 패킷 교환 방식**을 기반으로 동작한다.

반면 **회선 교환 방식**은 통신을 시작하기 전에 송신자와 수신자 사이의 **경로를 중앙에서 미리 설정**한다.  즉, 데이터를 주고받기 전에 하나의 **전용 회선(회로)** 을 확보하고, 통신이 끝날 때까지 그 경로가 **고정적으로 유지**된다.  

이 회선은 다른 트래픽의 영향을 받지 않기 때문에 **일관된 속도와 안정적인 품질**을 보장할 수 있다.  하지만 모든 사용자가 동시에 회선을 요청하면 사용할 수 있는 경로가 부족해 **연결 자체가 불가능한 상황**이 발생할 수도 있다. 또한 한 번 연결된 회선은 통신이 끝날 때까지 점유되므로, 자원 활용 효율이 낮다는 단점이 있다.  

전화 통신이 대표적인 회선 교환 방식의 예다.

---

우리가 지금 보려는 개념은 **네트워크의 혼잡(Congestion)** 이다.  

![](../images/Pasted%20image%2020251014004547.png)


만약 라우터와 라우터 사이의 **전송 용량이 100Mbps**라고 가정하자.  
이때 어떤 하나의 경로에서 데이터가 이 **100Mbps 전송 용량을 모두 사용하고 있다면**,  
그 구간은 **혼잡한(congested)** 상태라고 할 수 있다.

즉, 라우터가 처리할 수 있는 용량(대역폭, Bandwidth)을 이미 모두 사용하고 있기 때문에  
추가적인 데이터가 들어오면 **지연(latency)** 이 발생하거나 **패킷이 손실(loss)** 될 가능성이 커진다.  
이런 상태를 **네트워크 혼잡**이라고 부르며,  
혼잡이 심해질수록 전체 네트워크 성능이 급격히 저하될 수 있다.

![](../images/Pasted%20image%2020251014005528.png)


여기 그래프를 보면, **x축은 Load(부하)**, 즉 **데이터를 보내는 양**을 나타내고, 
**y축은 Delay(지연 시간)** 을 나타낸다.

처음에는 네트워크 부하가 적을 때, 데이터를 조금씩 더 보내더라도 지연 시간은 거의 증가하지 않는다.  하지만 부하가 점점 커져서 **라우터나 링크의 전송 용량(Capacity)** 에 가까워질수록, 즉 **최대 처리 속도(예: 100Mbps)** 에 도달할수록 **지연 시간(Delay)** 이 **급격하게 증가**하는 것을 볼 수 있다.


![](../images/Pasted%20image%2020251014005714.png)

이번 그래프에서 **x축은 데이터 전송량(Load)**, 즉 네트워크에 보내는 데이터의 양을 나타내고,  
**y축은 처리량(Throughput)**, 즉 단위 시간당 실제로 전송이 성공적으로 완료된 데이터의 양을 나타낸다.

처음에는 데이터 전송량이 증가함에 따라 처리량도 함께 증가한다. 그러나 일정 수준을 넘어가면서 **네트워크에 혼잡(Congestion)** 이 발생하면 상황이 달라진다.  

혼잡이 생기면 라우터의 **버퍼(Buffer)** 가 가득 차게 되고, 새로 들어오는 패킷은 **버퍼에 저장되지 못하고 즉시 버려지게 된다**. 이때 송신자는 패킷이 손실되었음을 직접 알 수 없기 때문에, **ACK(확인 응답)** 이 오지 않거나 **Timeout** 또는 **Fast Retransmission** 메커니즘을 통해 손실된 패킷을 **다시 재전송**하게 된다.

문제는 이러한 재전송이 **혼잡 상태에서는 계속 반복될 수 있다는 점**이다.  

즉, 네트워크가 과부하 상태일수록 손실과 재전송이 늘어나고, 그 결과 실제로 단위 시간당 성공적으로 전달되는 데이터의 양(Throughput)은 오히려 **감소**하게 된다.

결국 그래프를 보면, **처리량은 초기에는 부하 증가와 함께 상승하다가**, **최대 용량(Capacity, 예: 100Mbps)** 을 넘는 시점부터는 혼잡으로 인해 급격히 **하락**하는 모습을 보인다.  

이 구간이 바로 네트워크의 **혼잡 구간(Congestion Region)** 이며, TCP 혼잡 제어 알고리즘이 동작해야 하는 핵심 구간이다.

---
### Slow start, exponential increase

이런 혼잡 상황에서 TCP 알아서 해결한다. 

자 우리 flow controll 에서 window size를 결정할 때 보면 수신 받는 사람에게 받는 rwnd도 있었지만, cwnd와 비교해서 그 중 작은 값을 윈도우  사이즈로 결정했다. 여기서 cwnd가 이 혼잡제어를 하는 수단이다.

간단히 말해서 rwnd는 받는 사람이 받을 수 있는 양을 알려주는 용도지만. cwnd는 지금 네트워크 상태에 따라서 변화된다. packet switching 방식이기 때문에 rwnd 처럼 누군가 알려주는게 아니라 1에서 시작해서 점점 키워나가면서 혼잡이 걸릴 때 줄이는 방식을 사용해서 혼잡을 제어한다.  만약 cwnd가 없다면 rwnd가 엄청난 크기로 왔을 때, 우리는 받을 수 있는 만큼 전부 보낸다. 그래서 처음에ㅐ 많은 양을 보내게 될 경우에 바로 혼잡이 발생한다. 그렇기 때문에 cwnd를 1로둬서 혼잡한지 안 한지 살펴보면서 점점 늘리게 되는 것이다. 

