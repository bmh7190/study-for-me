
TCP 통신에서 **송신 측이 너무 작은 단위로 데이터를 전송하는 비효율적인 상황**을  
**Silly Window Syndrome (SWS)** 이라고 한다.

TCP 세그먼트 하나는 일반적으로 약 **40바이트(20B IP 헤더 + 20B TCP 헤더)** 의 오버헤드를 가진다.  그런데 만약 실제 전송해야 할 데이터(payload)가 **1바이트**에 불과하다면, 1바이트를 전송하기 위해 40바이트의 헤더를 함께 보내는 **극도로 비효율적인 상황**이 발생한다.

이 현상은 주로 **Application 계층에서 데이터가 너무 천천히 생성될 때** 발생한다.  

즉, 애플리케이션이 Transport 계층(TCP)으로 데이터를 조금씩, 간헐적으로 내려보내기 때문에  
TCP는 매번 매우 작은 단위로 패킷을 만들어 전송하게 된다.  

결과적으로 네트워크 대역폭 낭비와 헤더 오버헤드가 커져 **전송 효율이 급격히 저하**된다.

---
### 송신 측에서 발생하는 신드롬

위의 예시는 **송신 측에서 발생하는 Silly Window Syndrome**이다.  이 문제를 해결하기 위해 TCP는 **Nagle 알고리즘 (Nagle’s Algorithm)** 을 도입할 수 있다.

> “작은 데이터를 자주 보내지 말고, 어느 정도 쌓이면 한꺼번에 보내자.”

![](Pasted%20image%2020251013232853.png)

동작 방식을 살펴보자면 

1. 송신 측은 처음에는 작은 데이터라도 보낸다.
    
2. 이후 ACK(수신 확인 응답)가 돌아올 때까지 새로 들어오는 데이터는 **버퍼에 임시로 저장**한다.
    
3. 다음 두 조건 중 하나가 만족되면 데이터를 전송한다:
    
    - 이전 데이터에 대한 **ACK이 도착했을 때**
        
    - 혹은 **버퍼에 MSS(Maximum Segment Size)** 만큼 데이터가 쌓였을 때
        

즉, **ACK이 오기 전에는 새로운 작은 세그먼트를 만들지 않고**,  데이터를 모아 효율적인 크기의 세그먼트로 묶어서 전송하는 방식이다.


---
### 수신 측에서 발생하는 신드롬

이번에는 **수신 측에서 발생하는 Silly Window Syndrome(SWS)** 과 그 해결 방법에 대해 알아보자.

수신 측에서 이 문제가 발생하는 이유는, **Application Layer가 데이터를 너무 느리게 처리하기 때문**이다. 즉, 수신 버퍼에 도착한 데이터가 위 계층으로 즉시 전달되지 않아 버퍼 공간이 잘 비워지지 않는 상황이다.

#### 문제 상황

예를 들어 수신 측 애플리케이션이 버퍼에서 단 **1바이트**만 읽어갔다고 하자.  

그러면 TCP는 다음과 같이 동작한다:

- **“1바이트를 읽었으니 이제 1바이트만큼 버퍼가 비었다”** 고 판단
    
- 그 정보를 송신자에게 알리기 위해 **ACK 패킷**을 전송
    
- 이때 “현재 수신 가능 공간 = 1바이트” → `RWND = 1`
    

즉, 단 1바이트의 여유 공간을 알리기 위해 **40바이트의 헤더를 가진 TCP 패킷**을 보내는 비효율이 발생한다. 바로 이것이 **수신 측에서의 Silly Window Syndrome**이다.

이 문제를 완화하기 위한 대표적인 방법은 두 가지다.

#### (1) Clark’s Solution (클락 해결 방법)

Clark은 “ACK은 보내되, **RWND 값을 0으로 설정**”하여 
송신 측의 전송을 **일시적으로 멈추게** 하는 방식을 제안했다.

수신 버퍼가 거의 가득 차 있을 때는 `RWND = 0` 으로 설정하여 송신 정지한다. 그 후, 버퍼가 충분히 비워졌을 때(예: 버퍼의 절반 이상이 비거나 MSS만큼의 공간이 확보될 때) 다시 실제 `RWND` 값을 넣어 ACK을 전송하고, 송신 측은 그제서야 데이터 전송을 재개함
    
즉, **“작은 여유 공간이라면 굳이 알려주지 말고, 충분히 비워졌을 때만 다시 알려주자”**  
라는 원리다.

이 방식은 **ACK은 유지하면서도 송신 측의 데이터 폭주를 방지**할 수 있다는 장점이 있다.


#### (2) Delayed ACK (확인 응답 지연)

두 번째 방법은 **ACK 자체를 지연시키는 방식**이다.

수신 측이 데이터를 받더라도 **즉시 ACK을 보내지 않고 잠시 기다린다.** 이 시간 동안 애플리케이션이 버퍼의 일부를 처리하면 더 많은 공간이 확보되어 이후 더 큰 `RWND` 값을 보낼 수 있게 된다.

- 초기에는 수신 버퍼가 가득 차서 송신 측이 더 이상 데이터를 못 보냄
    
- 수신 측은 ACK을 잠시 지연시켜 **버퍼 비우는 시간 확보**
    
- 일정 시간 후, 더 큰 `RWND` 값과 함께 ACK을 전송
    
- 송신 측은 이를 받아 **한 번에 더 많은 데이터**를 전송
    

즉, **ACK 빈도를 줄여 작은 윈도우 갱신을 최소화**하는 방법이다.