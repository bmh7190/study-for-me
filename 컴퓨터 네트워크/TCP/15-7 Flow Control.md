**Flow Control(흐름 제어)** 란, 데이터를 보내는 **송신 측의 속도**가 데이터를 처리하는 **수신 측의 속도**를 초과하지 않도록 조절하는 메커니즘이다.  

> 데이터를 보내는 속도는 “받는 쪽이 데이터를 소비하는 속도”에 의해 결정된다.

TCP는 데이터를 한 패킷씩 보내는 것이 아니라,  수신 측이 한 번에 처리할 수 있는 만큼(=버퍼 크기) 여러 패킷을 연속적으로 보낸다.  이때 수신 측은 자신이 현재 **얼마나 더 받을 수 있는지**를 알려주는데,  이 값이 바로 **RWND (Receive Window)** 이다.

이 RWND 정보는 **3-way handshake 과정**(SYN → SYN+ACK → ACK)에서 교환되며,  
TCP 연결이 성립될 때부터 송신 측은 수신 측의 버퍼 크기를 알고 전송을 시작한다. 

한편, 송신 측은 네트워크의 혼잡도를 고려하여  스스로 데이터 전송 속도를 제한하는데,  이때 사용되는 값이 **CWND (Congestion Window)** 이다.  CWND는 네트워크가 혼잡해지지 않도록 송신 측이 자율적으로 조정하는 **전송 가능량(보낼 수 있는 최대 데이터 크기)** 라고 보면 된다.

![](Pasted%20image%2020251013230551.png)

결국 TCP가 실제로 데이터를 전송할 때 사용할 수 있는 **실질적인 윈도우 크기(Window Size)** 는  
두 제약 조건 중 더 작은 값을 따른다

![](Pasted%20image%2020251013231051.png)

송신 측의 동작을 먼저 보자면 

1. 송신 측 Application Layer는 전송할 데이터를 **Transport Layer(TCP)** 로 내려보낸다.
    
2. TCP는 수신 측이 알려준 **RWND 값**을 참고하여,  
    “수신자가 받을 수 있는 만큼만” 데이터를 전송한다.
    
3. 데이터를 보낼 때마다 수신자로부터 ACK과 함께 새로운 **RWND 값**을 계속 전달받는다.  
    → 이 값이 줄어들면 송신 속도가 자동으로 느려진다.

수신 측은 받은 데이터를 **수신 버퍼(buffer)** 에 임시로 저장한 뒤,  **Application Layer**로 데이터를 올려보낸다.

그런데 만약 Application Layer의 처리 속도가 느리면,  버퍼에 데이터가 오래 남게 되어 **버퍼 여유 공간이 줄어든다**.  이때 수신 측은 **더 이상 많은 데이터를 받을 수 없다**는 신호로 RWND 값을 작게 줄여 송신자에게 보낸다.

결과적으로 **수신자**는 자신의 버퍼 상태에 따라 RWND를 조정하고, **송신자**는 RWND를 보고 전송 속도를 조절한다. 따라서 송신자의 TCP 전송 속도는 **수신자의 처리 속도에 의해 자연스럽게 제어**된다.


> 송신자가 데이터를 보내는 속도는  
> 수신자가 데이터를 “소비”하는 속도에 맞춰 자동으로 조절된다.

이런 과정을 **TCP의 Flow Control(흐름 제어)** 이라고 한다.

---


![](Pasted%20image%2020251013231119.png)

### 연결 과정 ( 3 - way handshake )

1. **[1단계]** 클라이언트(Client)가 서버(Server)에게 **SYN** 패킷을 보낸다.
    
2. **[2단계]** 서버는 연결 요청을 승인하며 **SYN + ACK** 패킷을 보낸다.  
    이때, **자신이 현재 받을 수 있는 버퍼 크기(RWND)** 값을 함께 전달한다.
    
3. **[3단계]** 클라이언트는 **ACK** 패킷을 보내 연결을 완료한다.
    

이 과정을 통해 TCP 연결이 성립되고,  
클라이언트는 **서버의 수신 가능 용량(RWND)** 을 알게 되어  
“얼마나 많은 데이터를 보낼 수 있는지” 계산할 수 있게 된다.


### 데이터 전송 예시

연결이 완료되면 이제 클라이언트는 데이터를 전송하기 시작한다.

- 서버가 처음 보낸 **RWND = 800 bytes**
    
- 클라이언트가 보낼 첫 번째 데이터의 **시퀀스 번호 = 101**
    

이때 클라이언트는 “최대 800바이트까지 보낼 수 있다”는 것을 알고 있다.  
그래서 예를 들어 **101번부터 200바이트**를 보냈다고 해보자.


### 수신 측(Server)의 처리

서버는 데이터를 수신하고 나면,  그만큼 버퍼 공간이 줄어든다.

- 처음 버퍼 크기: **800 bytes**
    
- 받은 데이터: **200 bytes**
    
- 남은 버퍼(RWND): **600 bytes**
    

서버는 이 정보를 **ACK 패킷**에 함께 실어서 클라이언트에게 보낸다.  
이때 ACK 번호는 “다음에 받을 데이터의 순번”이므로,  `101 + 200 = 301` → **ACK = 301**

서버는 “200바이트까지 잘 받았고, 이제 301번부터 보내도 된다”는 뜻으로  
`ACK=301, RWND=600`을 보낸다.


### 송신 측(Client)의 윈도우 갱신

클라이언트는 서버로부터 받은 **ACK** 과 **RWND** 값을 기반으로  
자신의 송신 윈도우를 다시 계산한다.

- 윈도우의 시작점: 받은 ACK 번호(= 301)
    
- 윈도우 크기: 받은 RWND 값(= 600)
    
- 즉, 새로운 전송 가능 구간: **[301 ~ 900]** 
    

이렇게 TCP 윈도우는 **ACK이 올 때마다 앞으로 밀리며(Sliding)**  데이터 전송을 계속 이어간다.


마지막 8번에서 rwnd가 변했다고, ACK 보내주고 있는데 이런 경우는 거의 없다.