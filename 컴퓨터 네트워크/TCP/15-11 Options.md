
## End of option option

![](../../images/Pasted%20image%2020251204213045.png)

옵션 목록의 끝을 알리는 **End of Option 옵션은 단 1바이트만 사용되는 특별한 옵션**으로, 패킷 내에서 더 이상 해석할 옵션이 없음을 명확하게 알려주는 역할을 한다. 이러한 성격 때문에 패킷 안에서 **오직 한 번만 등장할 수 있으며**, 그 위치 이후에는 추가적인 옵션이 존재하지 않는 것으로 간주된다.

---
## No operation option

![](../../images/Pasted%20image%2020251204213027.png)

데이터를 4바이트 단위로 정렬해서 배치할 때, 어떤 옵션은 3바이트처럼 애매하게 끝나는 경우가 있다. 이런 상황에서 **남는 바이트를 강제로 채워 정렬을 맞추기 위해 사용되는 것이 바로 NOP 옵션**이다. 이 옵션은 **아무 기능도 수행하지 않고 단순히 빈 공간을 채우는 역할만** 하기 때문에, 필요하다면 **여러 번 반복해서 사용할 수 있다.** 또한 **1바이트 크기의 옵션**이라는 점에서 End of Option(EOP)과 동일하지만, EOP가 단 한 번만 사용될 수 있는 것과 달리 **NOP는 정렬을 위해 자유롭게 여러 번 등장할 수 있다는 점이 가장 큰 차이점**이다.

## Maximum segment size option

![](../../images/Pasted%20image%2020251204213008.png)

TCP에서 가장 자주 언급되는 옵션 중 하나가 바로 **MSS(Maximum Segment Size)** 이다. MSS는 _TCP 헤더를 제외한 순수 payload가 가질 수 있는 최대 크기_를 의미하며, 연결을 설정하는 과정에서 각 송‧수신 측이 서로에게 원하는 MSS 값을 제안할 수 있다.

예를 들어 3-way handshake 과정에서, 한쪽이 상대방에게 **“내가 받을 수 있는 payload 최대 크기는 700바이트니까, 너도 그 크기에 맞춰 보내줘!”** 라고 요청하는 식이다. 다만 이 값은 **상대방이 반드시 따라야 하는 강제 규칙이 아니기 때문에**, 상대측이 제안한 MSS를 실제로 사용할 수 있는지 **확인하는 과정이 필요하다.**

즉, MSS 옵션은 TCP 연결 설정 단계에서 서로의 데이터 전송 단위를 조율함으로써 네트워크 효율성을 높이기 위한 중요한 협상 도구라고 할 수 있다.

---
## Window scale factor option

TCP 헤더에 포함된 **rwnd(Receive Window)** 값은 16비트로 표현되며, 이는 **수신 측의 현재 버퍼에서 얼마만큼의 여유 공간이 있는지**를 송신 측에게 알려주는 역할을 한다. 즉, 이 값을 통해 송신자는 “상대가 지금 이 정도까지 더 받을 수 있구나”를 판단하고 전송 속도를 조절한다.

하지만 문제는 **16비트로 표현할 수 있는 값의 한계**에 있다. 16비트면 최대 약 **65,535바이트(약 64KB)** 까지밖에 표현하지 못한다. 현대 네트워크 환경에서는 버퍼 크기가 훨씬 큰 경우가 많기 때문에, 이 범위만으로는 실제 수신자의 여유 버퍼 공간을 충분히 표현하기 어렵다.

![](../../images/Pasted%20image%2020251204213530.png)

이 구조적 한계를 해결하기 위해 등장한 것이 **Window Scale 옵션**이다. 이 옵션은 rwnd 값에 **스케일 팩터(scale factor)** 를 곱해 실제 윈도우 크기를 더 크게 표현할 수 있도록 해준다. 예를 들어 scale factor가 7이라면, 실제 윈도우 크기는 `rwnd × 2⁷`이 되어 훨씬 큰 버퍼 크기를 송신자에게 알려줄 수 있다.

이 옵션 역시 앞서 설명한 다른 TCP 옵션들과 마찬가지로 **연결을 설정하는 초기 setup 단계(3-way handshake)** 에서 협상되어 결정되며, **연결이 성립된 이후에는 변경되지 않는다.** 즉, Window Scale 값은 연결이 유지되는 동안 계속 그대로 적용되고, 중간에 스케일 팩터를 다시 조정하거나 수정할 수 없다.

---
## Timestamp option

이 옵션 같은 경우에는 RTT 계산하는데 사용된다. 

![](../../images/Pasted%20image%2020251204213722.png)

TCP 타임스탬프 옵션의 기본적인 동작 원리는 다음과 같이 이해하면 가장 자연스럽다.

![](../../images/Pasted%20image%2020251204214012.png)

송신 측은 **timestamp value(TSval)** 필드에 _자신이 패킷을 보낸 시점의 시간 값을 기록_해 함께 전송한다. 그러면 수신 측은 이 값을 그대로 **timestamp echo reply(TSecr)** 필드에 복사해서 되돌려 보내게 된다. 그리고 수신 측 역시 ACK을 보낼 때 **자신이 ACK을 전송하는 시점의 시간**을 새로운 TSval 값에 넣어 보낸다.

즉, 한쪽이 보낸 **TSval → 상대가 이를 TSecr로 반사 → ACK에 자신의 TSval을 또 포함**하는 구조를 통해, 양측은 서로의 패킷 왕복 시간을 계산하거나 재전송 타이머를 더 정확하게 조정할 수 있게 된다. 이는 RTT를 정확히 측정하고 중복 ACK 문제를 줄여, TCP의 성능과 안정성을 높이는 데 중요한 역할을 한다.


### Protection Against Wrapped Sequence Numbers
RTT 계산뿐만 아니라 TCP 타임스탬프는 **PAWS(Protection Against Wrapped Sequence numbers)** 문제를 해결하는 데에도 중요한 역할을 한다.

TCP의 sequence number는 **32비트**로 구성되어 있기 때문에, 매우 큰 양의 데이터를 전송하거나 고속 네트워크 환경에서는 sequence 번호가 끝까지 도달한 뒤 다시 **0부터 재시작(랩어라운드)** 될 수 있다. 이렇게 번호가 다시 초기화되면, **과거에 전송되다가 지연된 패킷**과 **현재 전송 중인 패킷**의 sequence number가 **겹치는(중복되는)** 문제가 발생할 수 있다. 이 경우 수신 측은 어떤 패킷이 새로운 데이터이고 어떤 것이 오래된 지연 패킷인지 구분할 수 없게 되면서, 데이터 무결성과 연결 안정성이 깨질 위험이 생긴다.

이때 **TCP timestamp 옵션이 PAWS 문제를 해결하는 핵심 도구**가 된다.  

각 패킷에 담긴 timestamp 값은 항상 증가하기 때문에, 수신 측은 **timestamp가 더 큰 패킷은 최신 패킷**,**timestamp가 낮은 패킷은 오래된 패킷(지연된 패킷)** 으로 판단할 수 있다.

---
## SACK

TCP는 기본적으로 **accumulative ACK** 방식을 사용한다. 즉, 중간에 어떤 세그먼트가 유실되면, 수신 측은 “여기까지는 제대로 받았고, 그 이후는 아직 못 받았어”라는 의미로 **가장 처음 빠진 바이트 번호만 ACK으로 돌려보낸다.**  

이 방식 때문에 TCP는 Fast Retransmission을 통해 **유실된 세그먼트만 재전송하는 것이 아니라**, 그 지점 이후로 이미 받았던 데이터까지 _중복해서_ 다시 받는 문제가 발생한다.

![](../../images/Pasted%20image%2020251204214538.png)

이 불필요한 재전송 문제를 해결하는 것이 바로 **Selective Acknowledgment(SACK)** 옵션이다.

![](../../images/Pasted%20image%2020251204214600.png)

SACK을 사용하면 수신 측은 자신이 이미 받아 놓은 세그먼트 구간들을 명시적으로 알려줄 수 있다. 예를 들어 2000까지는 정상 수신했지만 그 이후의 일부 구간만 유실된 상태에서, 수신 측은 “4001~5000 구간은 받았고, 5001~6000도 받았으며, 8001~9000도 받았다”처럼 정확한 범위를 TCP 옵션에 기록해 송신자에게 전달할 수 있다. 이렇게 현재 수신한 구간을 명시적으로 알려주면 송신자는 유실된 특정 범위만 재전송하면 되므로, 이미 받은 데이터를 다시 받는 비효율을 크게 줄일 수 있다.

SACK 블록은 하나를 기록할 때마다 시작 지점과 끝 지점을 적어야 하므로 8바이트가 필요하다. 하지만 TCP 헤더의 옵션 필드는 최대 40바이트까지만 사용할 수 있기 때문에, 기록할 수 있는 SACK 블록의 개수에도 제한이 생긴다. 그럼에도 불구하고 SACK은 누적 ACK 기반의 TCP가 가진 중복 재전송 문제를 상당 부분 완화해주는 중요한 기능이다.

또한 SACK 역시 다른 TCP 옵션들과 마찬가지로 3-way handshake 단계에서 “이 옵션을 사용해도 된다”는 식의 상호 합의를 통해 사용 여부가 결정된다. 한 번 연결이 성립되면 그 설정은 변경되지 않으며, 해당 연결 동안 계속 동일한 방식으로 동작하게 된다.