---

---

---
## Persistence Timer 

교착 상태를 해결하기 위하여 사용
영속타이머가 만료되면, probe 세그먼트 전송

## Keepalive Timer

일반적으로 우리가 사용하는 인터넷 웹 페이지는 **TCP 연결이 유지되지 않는 방식**으로 동작한다. 예를 들어, 사용자가 웹 페이지의 버튼을 클릭할 때마다 **새로운 TCP 연결이 생성**되고, 요청이 완료되면 연결이 끊어진다.

하지만 **상대방(클라이언트)이 하드웨어적으로 종료되었을 경우**, 서버는 즉시 그 사실을 알 수 없다. 즉, TCP 연결이 끊겼는지 아닌지를 서버가 바로 감지하지 못한다.

이런 상황을 방지하기 위해 TCP는 **Keep-Alive 타이머**를 사용한다.  

서버가 **오랜 시간 동안(기본적으로 약 2시간)** 클라이언트로부터 어떤 세그먼트(segment)도 받지 못하면, 연결이 여전히 유효한지 확인하기 위해 **probe 세그먼트(탐색 패킷)** 를 전송한다.

이를 통해 **장시간의 idle(유휴) 상태를 방지**하고, **끊어진 연결을 감지하여 자원을 효율적으로 관리**할 수 있다.

---
## RTO timer
### Smoothed RTT 계산

초기에는 Smoothed RTT 값이 없다.

#### 첫 RTT 측정 후

```
RTTs = RTTm
```

#### 두 번째 측정부터 반복

지수평활 방식으로 업데이트함:

```
RTTs = (1 - α) · RTTs + α · RTTm
```

- α = 1/8

→ 새 RTT가 나오더라도 **갑자기 값이 튀지 않고 완만하게 따라가도록** 설계됨.

---

### RTT Deviation 계산

초기에는 편차 값도 없다.

#### 첫 RTT 측정 후

```
RTTd = RTTm / 2
```

#### 이후부터 반복

예측값(RTTs)과 실제 측정값(RTTm)의 차이를 반영하여 갱신함:

```
RTTd = (1 - β) · RTTd + β · | RTTs - RTTm |
```

- β = 1/4

→ RTT 편차가 클수록 RTO가 더 넉넉해지도록 반영.

---

### RTO 계산

초기 상태에서는 구현마다 지정된 **초기값**을 사용한다.

#### 이후부터는 매 RTT 측정 후 갱신

```
RTO = RTTs + 4 · RTTd
```

→ 예측 RTT에 편차를 여유 있게 4배 반영하여 네트워크 변동을 커버할 수 있도록 설정.

---
## Karn's Algorithm

TCP에서는 RTT 값을 기반으로 RTO를 조정하는데, 여기에는 중요한 제약이 하나 있다. **재전송된 패킷에 대해서는 RTT를 갱신하지 않는다**는 것이다. 그 이유는 재전송 상황에서는 ACK이 어떤 전송에 대한 응답인지 명확히 알 수 없기 때문이다.

![](../../images/Pasted%20image%2020251207152335.png)

예를 들어 (a)와 같은 경우를 보자. 최초 전송한 패킷에 대한 ACK이 오지 않아 재전송을 수행했고, 이후 ACK이 도착했다. 실제 RTT는 재전송 시점부터 ACK이 도착할 때까지의 시간이어야 한다. 하지만 송신자는 원래 전송한 시점부터 ACK이 오기까지의 시간을 RTT로 계산할 수밖에 없고, 이렇게 측정된 값은 실제보다 더 크게 나타난다. 즉, 재전송이 사용된 상황에서는 **측정된 RTT 값이 오염되어 신뢰할 수 없게 된다.**

또 다른 경우 (b)를 보면 문제가 더 분명해진다. 원래 패킷에 대한 ACK이 단지 늦게 도착했을 뿐인데, 송신자는 이를 기다리지 못하고 재전송을 수행했다. 그런데 그 타이밍에 원본 패킷에 대한 ACK이 도착했다고 하자. 이때 송신자는 이 ACK이 원래 전송의 응답인지, 아니면 재전송 패킷에 대한 응답인지 알 수 없다. 특히 재전송 패킷이 손실된 상황이라면 더욱 구분할 방법이 없다. 결국 송신자는 RTT를 어떤 기준으로 계산해야 하는지 판단할 수 없게 된다.

이러한 모호성을 피하기 위해 TCP는 **재전송된 패킷에 대해서는 RTT 갱신을 하지 않고**, RTT 측정은 **재전송 없이 성공적으로 ACK을 받은 경우에만 수행한다**는 원칙을 사용한다. 즉, 재전송이 한번 일어나면 그 전송 관련 RTT 샘플은 버리고, 다음 정상적인 전송에 대한 ACK이 도착할 때 RTT 갱신을 재개한다. 이런 방식이 바로 Karn’s Algorithm의 핵심이며, 잘못된 RTT 학습을 막아 TCP 타이밍 동작을 안정시키기 위한 설계이다.

---
## Example

TCP는 재전송 상황에서 RTT 측정을 하지 않는 대신, **RTO는 지수적 백오프 방식으로 단순히 두 배씩 증가시키는 전략**을 사용한다. 

![](../../images/Pasted%20image%2020251207152901.png)

예를 들어 최초 전송 시점(Start)에서 데이터를 보냈지만 패킷이 유실되어 ACK이 도착하지 않았다고 하자. 이때 송신자는 설정된 RTO(예: 4.74초)를 기준으로 일정 시간을 기다린 뒤 재전송을 수행한다. 그런데 이 재전송 시점에서는 새 RTT를 측정하여 RTO를 계산하지 않고, 단순히 기존 RTO 값을 두 배로 늘려 9.48로 설정하고 전송을 시도한다. 즉, 재전송 구간에서는 RTO 계산을 멈추고 **기존 타이머 값에 대해 지수적 백오프만 적용하는 것**이다.

그 후 재전송한 패킷에 대한 ACK이 도착하면, TCP는 이 ACK을 이용해 RTT를 갱신하지 않는다. 대신, 다음 데이터 전송 시 사용할 RTO는 **재전송 이전에 유지되던 RTTs와 RTTd 값에 기반하여 다시 계산**한다. 즉, 재전송이 있었던 구간에서 발생한 왕복 지연은 알고리즘에 반영되지 않고 “훈련 데이터에서 제외”된다. 이 방식은 재전송 구간에서 측정된 RTT 값이 오염되었을 가능성을 고려하여, **기존의 안정적인 RTT 추정값을 그대로 유지한 채 이후 갱신에 활용하는 전략**이다. 결국 TCP는 재전송 동안 RTT을 측정하지 않고, 대신 RTO만 증가시키며, 정상적인 ACK이 도착한 이후에야 기존 RTTs와 RTTd를 바탕으로 다시 안전하게 RTO를 조정하게 된다.