일단 Transport Layer에서 TCP를 사용한다면 segment 라는 단위로서 데이터를 보내게 된다. 이 segment는 헤더와 데이터, 즉 페이로드로 이어져있다. 헤더는 기본 20byte이지만 옵션을 사용하면 최대 60byte까지 데이터가 들어갈 수 있다.

![](../images/Pasted%20image%2020250917005728.png)


![](../images/Pasted%20image%2020250917005804.png)

- 가로 32bit = 4byte
- 세로 5줄
- 총 크기 : 4 * 5 = 20byte

헤더는 가로 32비트(4바이트) 단위로 구성되며, 기본적으로 5줄(=20바이트) 크기를 가진다. 따라서 이 20바이트 안에 TCP의 핵심 정보들이 모두 포함된다.

### Port Address
가장 먼저 확인할 부분은 포트 주소다. 송신자와 수신자의 포트 번호가 들어가는데, 데이터를 보낼 때는 운영체제가 자동으로 송신 포트를 지정해 준다. 이 과정에서 한 가지 의문이 생길 수 있다. 컴퓨터에는 총 2¹⁶개(65,536개)의 포트가 있고, 특정 번호를 직접 지정할 수도 있다. 그렇다면 어떻게 수신 측 컴퓨터가 데이터를 받을 ‘입구 포트’를 정확히 알 수 있을까?

그 답은 애플리케이션 계층에서 사용하는 **프로토콜의 약속**에 있다. 우리가 애플리케이션 계층에서 데이터를 메시지 형태로 표현할 때, HTTP·FTP 같은 프로토콜은 각각 정해진 형식을 따르고, 이 프로토콜마다 기본적으로 사용하는 포트 번호가 미리 약속되어 있다. 예를 들어 HTTP라면 80번 포트, HTTPS라면 443번 포트가 사용된다. 이렇게 전 세계적으로 약속된 규칙 덕분에 송신자는 목적지의 프로토콜에 맞는 포트 번호를 TCP 헤더에 넣어 보낼 수 있고, 수신 측은 해당 포트를 통해 데이터를 정확히 받아 처리할 수 있는 것이다.

### Sequence Number
TCP는 **스트림 전달(stream delivery)** 방식을 사용한다. 즉, 상위 계층(예: 애플리케이션 계층)에서 내려온 데이터를 고정된 블록 단위로 자르는 것이 아니라, TCP가 상황(네트워크 상태, 혼잡 정도, 윈도우 크기 등)에 맞게 임의의 크기로 잘라낸다. 이렇게 잘라낸 각 조각에는 TCP 헤더가 붙고, 이 헤더에는 데이터의 순서를 식별할 수 있는 **Sequence Number(순서 번호)** 가 포함된다.

이 Sequence Number는 **데이터 스트림 내에서 현재 세그먼트의 첫 번째 바이트가 원래 전체 데이터 흐름에서 몇 번째 위치인지**를 나타낸다. 예를 들어, 전체 데이터 스트림이 10,000바이트라고 할 때, 처음 보낸 세그먼트의 Sequence Number가 1000이라면, 이 세그먼트의 첫 바이트는 전체 스트림에서 1000번째 바이트라는 뜻이다.

특히, **연결을 시작할 때 최초의 Sequence Number(ISN, Initial Sequence Number)는 랜덤하게 선택**된다. 이는 보안상의 이유(예상 불가능하게 하여 세션 하이재킹 공격 방지)와 동시에 중복된 연결을 방지하기 위함이다. 이후 송신자는 보낸 바이트 수만큼 Sequence Number를 증가시키면서 전송을 이어간다.

### Acknowledgement Number
이번에는 **응답 번호(Acknowledgment Number, ACK Number)** 에 대해 보자.
TCP는 단순히 데이터를 보내는 데서 끝나는 것이 아니라, **상대방이 데이터를 잘 받았는지 확인**까지 한다. 그래서 송신 측은 보낸 데이터를 곧바로 버리지 않고, **버퍼에 임시로 저장**해 둔다. 이후 수신 측으로부터 “데이터를 잘 받았다”는 신호(ACK)가 오면 그제서야 해당 데이터를 버퍼에서 제거한다.

여기서 ACK는 **누적 확인(cumulative acknowledgment)** 방식을 사용한다. 즉, “내가 지금까지 받은 데이터는 모두 정상이고, 이제 다음 Sequence Number부터 보내라”는 식으로 알려준다. 이 말은 ACK Number는 단순히 “다음에 받을 것으로 기대하는 바이트 번호”를 의미한다. 

예를 들어, 송신자가 **Sequence Number = 10000**인 세그먼트를 보냈다고 하자. 수신자가 이 세그먼트를 문제없이 받았다면, 응답으로 **ACK Number = 10001**을 보낸다. 이 말은 “10000번 바이트까지 다 받았으니, 이제 10001번부터 보내라”라는 뜻이다. 만약 10000~10099까지 총 100바이트를 보냈다면, 수신자는 잘 받았다는 의미로 **ACK Number = 10100**을 보낼 것이다.

### HLEN
TCP 헤더의 길이를 나타내는 필드는 **Header Length (Data Offset)** 이라고 부른다.

기본 TCP 헤더는 **20바이트**이고, 옵션 필드가 붙으면 최대 **60바이트**까지 늘어난다. 문제는 실제 전송 시 데이터는 `010101...` 같은 이진수 형태로 전송되기 때문에, 수신 측은 “어디까지가 헤더이고 어디부터가 데이터인지”를 구분할 수 있어야 한다. 이를 위해 TCP 헤더 안에 **헤더의 길이를 표시하는 필드**를 둔다.

이 필드는 단순히 바이트 단위가 아니라 **4개의 비트**로 길이를 기록한다.

예를 들어, 기본 헤더는 20바이트 → `20 ÷ 4 = 5` → 필드 값은 `0101(=5)`
만약 헤더가 60바이트라면 → `60 ÷ 4 = 15` → 필드 값은 `1111(=15)`

즉, **송신 측은 헤더 길이를 4로 나눈 값을 기록**하고, **수신 측은 그 값을 4배 해서 실제 헤더 길이를 계산**한다. 이렇게 하면 헤더 길이를 나타내는 데 필요한 비트를 줄일 수 있다. 실제로는 **4비트**(2⁴ = 16가지 값)만 있으면 충분하다. 그 결과 헤더 길이는 최소 20바이트(5 × 4)부터 최대 60바이트(15 × 4)까지 표현할 수 있다.

### Reserved
혹시 추가 데이터가 있을 경우 TCP에 예비 공간으로 빼놓은 공간이다. 근데 지금까지 사용되지 않는다. 
### Control field

TCP 세그먼트에는 **Control Field(제어 필드)** 라는 부분이 있다. 이 필드는 총 **6개의 비트**로 구성되어 있으며, 각 비트는 해당 TCP 세그먼트가 **어떤 역할과 의미를 가지고 있는지**를 나타낸다.  
즉, 이 세그먼트가 단순한 데이터 전송용인지, 연결 요청이나 종료, 혹은 예외 상황 처리용인지를 구분하는 역할을 한다.

![](../images/Pasted%20image%2020251014134259.png)

#### 주요 제어 비트 (Control Bits)

| 비트 이름   | 의미    | 설명                                                                                          |
| ------- | ----- | ------------------------------------------------------------------------------------------- |
| **ACK** | 확인 응답 | 이 세그먼트가 **유효한 ACK 번호**를 포함하고 있음을 의미한다. 즉, 수신자가 이전 데이터를 잘 받았다는 신호이다.                         |
| **SYN** | 연결 요청 | TCP 연결 설정(3-way handshake) 시 사용된다. 클라이언트와 서버가 **초기 Sequence Number(ISN)** 를 교환하는 단계에서 전송된다. |
| **FIN** | 연결 종료 | TCP 연결을 **정상적으로 종료**하기 위해 사용된다. 더 이상 보낼 데이터가 없음을 의미한다.                                      |


#### 보조 제어 비트 (덜 자주 쓰이지만 의미 있는 비트)

| 비트 이름            | 의미     | 설명                                                                           |
| ---------------- | ------ | ---------------------------------------------------------------------------- |
| **URG (Urgent)** | 긴급 데이터 | “이 데이터는 중요하니 **우선적으로 처리하라**”는 신호이다. TCP 헤더의 **Urgent Pointer** 필드와 함께 사용된다.  |
| **PSH (Push)**   | 즉시 전달  | 데이터를 **지연시키지 말고 바로 상위 애플리케이션으로 전달**하라는 의미이다. 예를 들어, 실시간 입력(터미널, 채팅 등)에 사용된다. |
| **RST (Reset)**  | 연결 초기화 | 잘못된 연결 상태나 비정상 세션이 감지될 때 **즉시 연결을 종료하고 재설정(reset)** 할 때 사용된다.                |

---
### Pseudoheader

이제 살펴볼 **Pseudo Header** 는 TCP 헤더의 일부는 아니지만, **IP 계층의 정보**를 포함하고 있다는 점이 핵심이다. 간단히 말해서, **Pseudo Header는 TCP 헤더에 직접 포함되지는 않지만**, TCP가 동작할 때 **IP 헤더의 특정 정보(예: 출발지 IP, 목적지 IP, 프로토콜 번호 등)** 를 임시로 함께 사용한다.

이 정보는 실제 전송되는 패킷 안에는 포함되지 않고, **TCP 체크섬(Checksum)** 을 계산할 때만 일시적으로 사용된다.  TCP 체크섬이 뭔지는 다시 설명하겠다.

즉, TCP가 데이터의 무결성을 검증하기 위해 **IP 계층 정보를 잠시 끌어다 쓰는 임시 구조체**라고 이해하면 된다.

![](../images/Pasted%20image%2020251014134959.png)

---
### Checksum

데이터를 전송할 때는 결국 **0과 1의 비트(bit)** 형태로 변환되어 네트워크를 통해 전송된다. 그런데 전송 과정에서 **노이즈, 충돌, 신호 감쇠** 등 여러 요인으로 인해 일부 비트가 바뀔 수도 있다.  

이렇게 데이터가 변형되면 원래 의도한 정보와 달라지기 때문에, TCP는 이를 감지하기 위해 **Checksum 필드**를 사용한다.

![](../images/Pasted%20image%2020251014135234.png)


TCP는 전송하려는 데이터 전체를 **16비트 단위로 나누어 모두 더한 뒤**, 그 결과에 **1의 보수(One’s Complement)** 를 취한다. 이렇게 얻어진 값이 바로 **Checksum** 이다.

이 값을 **TCP 헤더의 Checksum 필드에 넣어 전송**한다. 수신 측에서는 데이터를 받은 후 같은 방식으로 Checksum을 다시 계산하고, 송신 측이 보낸 Checksum과 비교한다.

두 값이 같다면 데이터가 전송 중 손상되지 않았음을 의미한다. 값이 다르다면 데이터가 손상되었다고 판단하고, **ACK(확인 응답)** 을 보내지 않는다.  


여기서 **Pseudo Header(의사 헤더)** 개념이 등장한다. 


TCP의 Checksum은 단순히 TCP 세그먼트 내부의 데이터만 확인하는 것이 아니라, **IP 계층의 정보 일부**도 함께 포함시켜 계산한다. 즉, TCP는 데이터의 신뢰성뿐 아니라 **패킷이 올바른 출발지와 목적지로 전달되었는지**까지 확인하려는 것이다.

Pseudo Header에는 다음과 같은 **IP 헤더의 일부 정보**가 들어간다:

- 출발지 IP 주소 (Source IP Address)
    
- 목적지 IP 주소 (Destination IP Address)
    
- 프로토콜 번호 (Protocol Number, TCP는 6)
    
- TCP 길이 (TCP Length)


이 정보들은 실제 TCP 세그먼트에 포함되지는 않지만, **Checksum 계산 시에만 임시로 덧붙여 계산에 사용**된다. 따라서 이 과정은 TCP와 IP가 협력해서 수행되는 것이다.


그래서 TCP/IP에서는 **Checksum 계산이 두 계층에서 각각 수행된다.**

1. **IP 계층:** IP 헤더에 대해서만 Checksum 계산 → IP 헤더의 무결성 검증
    
2. **TCP 계층:** TCP 헤더 + 데이터 + Pseudo Header를 포함하여 Checksum 계산 → 전체 전송 신뢰성 보장
    

즉, Checksum이 “두 번” 적용되는 것은 각 계층이 **자신의 책임 범위 안에서 오류를 감지하기 위한 것**이다.


#### TCP가 IP 정보를 어떻게 알까?

TCP는 독립적으로 IP 헤더를 “가지고 있는” 것이 아니라, **전송 시점에 OS의 네트워크 스택(Network Stack)** 내부에서 **IP 계층이 TCP에게 필요한 정보를 임시로 전달**해준다.

TCP는 이 정보를 이용해 **Pseudo Header** 를 만들고, Checksum 계산이 끝나면 그 정보를 **버린다**.  
즉, TCP는 IP 정보를 “항상 알고 있는” 게 아니라, **Checksum 계산을 위해 일시적으로 참조**하는 것이다.