웹 페이지는 단일 파일이 아니라 여러 종류의 객체로 구성된 하나의 화면이다. 이러한 객체는 HTML 파일일 수도 있고, JPEG 이미지, 자바 애플릿, 오디오 파일 등 다양한 형태를 가질 수 있다. HTML 문서는 이러한 객체들의 위치를 URL 형태로 포함하고 있으며, 브라우저는 HTML을 받아 해석하고 내부에 참조된 객체들을 추가로 요청하여 전체 페이지를 완성한다.

---
## HTTP
HTTP(HyperText Transfer Protocol)는 웹에서 사용하는 애플리케이션 계층 프로토콜로, 클라이언트–서버 모델을 기반으로 한다. 일반적으로 클라이언트는 HTTP 요청을 통해 서버에 웹 객체를 요구하고, 서버는 그 요청에 대한 응답을 반환하여 브라우저가 화면을 구성하도록 한다. HTTP는 TCP 위에서 동작하므로, 클라이언트가 서버에 연결을 시도하면 TCP 3-way handshake가 먼저 수행되고, 이후 HTTP 메시지가 교환된다. 데이터 전송이 끝나면 TCP 연결이 종료된다. HTTP는 무상태 프로토콜이기 때문에 서버는 과거 요청의 상태를 저장하지 않고, 단순히 들어오는 요청에 대해 독립적으로 응답할 뿐이다.

---
## HTTP connections

HTTP 연결 방식에는 비지속(non-persistent) 방식과 지속(persistent) 방식 두 가지가 존재한다. 

비지속 HTTP에서는 하나의 객체를 주고받기 위해 TCP 연결을 생성하고, 응답을 받은 뒤 즉시 연결을 끊는다. 따라서 HTML 파일 하나를 받은 뒤, 그 안에 포함된 이미지나 다른 리소스를 다운로드해야 한다면 객체별로 TCP 연결을 새로 만들고 닫는 과정을 반복해야 한다. 

반면, 지속 HTTP에서는 TCP 연결을 한 번 맺으면 여러 객체를 같은 연결을 통해 주고받을 수 있다. 즉, HTML을 받고 난 뒤 그 안에 포함된 객체들도 동일한 연결을 통해 요청할 수 있어 비지속 방식보다 더 효율적이다.

또한 지연 관점에서 보면 비지속(non-persistent) 방식은 더 큰 비용을 요구한다. 비지속 HTTP에서는 객체 하나를 전송할 때마다 새로운 TCP 연결을 열고 닫아야 하기 때문에, 실제로 파일을 받기 전에 TCP 연결을 설정하는 과정이 먼저 필요하다. TCP 연결 설정에는 1 RTT(왕복 시간)가 소요되고, 그 다음 클라이언트가 HTTP 요청을 보내고 서버가 응답을 전달하기까지 또 1 RTT가 필요하다. 따라서 하나의 객체를 받아오기 위해서는 최소 **2 RTT와 파일 전송 시간(file transmission time)이 추가로 필요**하게 된다. 이러한 특성 때문에 RTT가 큰 네트워크 환경에서는 비지속 HTTP 방식이 상당히 비효율적일 수밖에 없다.

---
## Persistent HTTP (HTTP 1.1)

HTTP/1.0 은 기본적으로 비지속(non-persistent) 방식이었기 때문에, 객체 하나를 요청할 때마다 TCP 연결을 새로 만들고 끊는 과정을 반복해야 했다. 하지만 이러한 방식은 RTT가 큰 환경에서 불필요한 연결 설정 비용을 초래하므로 비효율적이었다. 이를 개선하기 위해 HTTP/1.1에서는 **지속(persistent) 연결이 기본값으로 적용**되었다. 이 방식에서는 서버가 응답을 전송한 뒤에도 TCP 연결을 당장 종료하지 않고 잠시 유지하여, 동일한 클라이언트가 추가 객체를 요청할 수 있도록 만든다.

이 덕분에 클라이언트는 HTML 문서를 받은 후, 그 안에 참조된 이미지나 스크립트 같은 객체가 보이면 즉시 같은 TCP 연결을 이용해 요청을 보낼 수 있다. 즉, 객체마다 새 연결을 만드는 대신 하나의 열린 연결에서 연속적인 HTTP 메시지가 교환되는 것이다. 이러한 방식은 필요한 객체들을 가져오는 데 걸리는 RTT를 크게 줄여서, **참조된 여러 객체를 가져오 는 시간이 최소 1 RTT 수준까지 감소할 수 있다.** 결국 persistent HTTP는 네트워크 지연을 절반 수준으로 줄이고, 페이지 로딩 속도를 크게 개선하는 효과를 가져왔다.

---
## HTTP 2

HTTP/1.1 의 persistent 연결은 TCP 연결 하나로 여러 객체를 주고받을 수 있다는 점에서 큰 발전이었지만, 여전히 한계가 존재했다. 대표적인 문제가 **HOL(Head-of-Line) Blocking)** 현상이다. HTTP/1.1 에서는 요청들이 순차적으로 처리되었기 때문에, 용량이 큰 객체를 전송하는 동안 뒤에 있는 다른 요청들은 처리되지 못하고 대기해야 했다. 즉, 하나의 큰 응답이 앞을 막으면 그 뒤에 있는 모든 객체 요청이 줄줄이 지연되는 문제가 발생한 것이다.

HTTP/2 는 이 문제를 해결하기 위해 **멀티플렉싱(multiplexing) 기법을 도입**했다. HTTP/2 에서는 객체 하나를 통째로 전송하는 대신, 데이터를 내부적으로 작은 프레임 단위로 쪼개어 전송한다. 그리고 같은 TCP 연결 내에서도 서로 다른 요청들의 프레임을 섞어서 보낼 수 있도록 했다. 그 결과 용량이 큰 객체가 전송 중이라도, 작은 객체들은 그 사이사이로 함께 전송될 수 있으며 이전처럼 기다릴 필요가 없게 되었다.

즉, HTTP/2 는 기존 HTTP/1.1 의 직렬적인 전송 방식을 프레이밍 기반 병렬 처리 구조로 바꾸어 **HOL Blocking 문제를 효과적으로 완화했고, 웹 페이지 로딩 속도와 네트워크 자원 활용 효율을 크게 향상시켰다.**

