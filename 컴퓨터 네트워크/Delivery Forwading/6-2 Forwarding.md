forwarding은 패킷을 최종 목적지로 보내기 위해 **라우터가 패킷을 적절한 경로로 넘겨주는 과정**을 의미한다. 쉽게 말해, “이 패킷이 어디로 가야 하는가?”를 결정하고, 그에 따라 **다음 hop(next hop)** 으로 패킷을 전달하는 동작이다.

오늘날의 인터넷은 다양한 링크와 네트워크가 서로 조합되어 연결된 구조이기 때문에, forwarding은 최종 목적지까지 한 번에 보내는 개념이 아니라 **각 구간마다 다음 hop으로 패킷을 계속 넘겨주는 방식**으로 이루어진다. 즉, 라우터는 전체 경로를 모두 따라가는 것이 아니라, routing 정보에 기반해 “이 패킷은 다음에 어느 장치로 가야 한다”를 판단하고, 그 다음 지점으로 패킷을 전달하는 역할을 수행한다.

결국 forwarding은 **라우터가 패킷을 목적지로 향하도록 올바른 위치로 이동시키는 동작**, 그리고 인터넷 구조에서는 **각 단계의 next hop으로 패킷을 넘기는 핵심 동작**이라고 이해할 수 있다.


![](../../images/Pasted%20image%2020251204220237.png)

라우터 끼리는 정보를 주고 받아서 full pathㄹ르 알고 있긴 하지만 full path를 알고 있는 상태에서 next hop만 테이블에 기록한다. 

---
## Network-specific method
예시처럼 N2 네트워크가 클래스 A 대역을 사용해 약 1,600만 개의 주소를 가진다고 가정해보면, 모든 라우터가 이 네트워크에 포함된 **모든 호스트 주소를 일일이 라우팅 테이블에 기록**하는 것은 사실상 불가능하다. 그렇게 하려면 테이블의 행 수가 기하급수적으로 늘어나고, 라우터의 메모리와 검색 속도에도 심각한 부담이 된다.

![](../../images/Pasted%20image%2020251204220417.png)

그래서 라우팅 테이블에는 개별 호스트 주소를 저장하지 않고, **여러 호스트가 공유하는 공통 구간**, 즉 해당 네트워크의 **네트워크 주소(prefix)**만 저장한다. 이는 “이 범위에 속하는 IP라면 모두 이쪽으로 보내라”는 의미로, 많은 개별 주소들을 하나의 범위로 묶어 관리할 수 있게 해준다.

---
## Host-specific routing

하지만 라우팅 테이블이 항상 이렇게 네트워크 주소만 포함하는 것은 아니다. 특정 경우에는 **특별히 지정된 개별 호스트 주소(host route)** 가 저장될 수도 있다. 예를 들어 아주 중요한 특정 서버로 가는 경로를 별도로 관리해야 한다거나, 네트워크 구조상 해당 호스트를 개별적으로 구분해야 하는 상황 등이 있을 수 있다.

![](../../images/Pasted%20image%2020251204220701.png)

---
## Default Routing

모든 라우터가 **모든 목적지 주소를 라우팅 테이블에 가지고 있을 필요는 없다.** 현실적으로 인터넷은 수많은 네트워크와 라우터가 연결된 거대한 구조이기 때문에, 모든 목적지에 대한 경로를 각 라우터가 모두 저장한다는 것은 비효율적일 뿐만 아니라 사실상 불가능하다.

![](../../images/Pasted%20image%2020251204220829.png)

그래서 라우터는 **주변(인접) 네트워크나 자주 사용하는 주요 네트워크 정보만** 라우팅 테이블에 저장하고, **나머지 목적지에 대해서는 다음 hop 라우터에 위임**하는 방식으로 동작한다. 즉, 자신이 정확한 경로를 몰라도, **다음 라우터는 알 수도 있다는 전제 하에** 패킷을 넘기는 것이다.

이러한 구조에서 활용되는 것이 바로 **default route(기본 경로)** 이다. 만약 특정 목적지에 대한 정보가 라우팅 테이블에 없다면, 라우터는 패킷을 **default route에 정의된 라우터(게이트웨이)** 로 전달한다. 이를 통해 **경로를 알 수 없는 목적지에 대해서도 무작정 폐기하지 않고, 마지막 희망처럼 기본 경로로 넘겨보는 것**이다.

---
## Simplified Forwarding module in classful address
classful 환경에서의 forwarding 과정은 비교적 단순한 구조로 이루어진다. 

![](../../images/Pasted%20image%2020251204221119.png)

먼저 패킷이 라우터에 도착하면, 라우터는 가장 먼저 **목적지 IP 주소를 확인**한다. 그 다음 이 주소가 **클래스 A, B, C 중 어느 범주에 속하는지**를 판단한다. classful 주소 체계에서는 클래스에 따라 네트워크 부분과 호스트 부분이 고정되어 있기 때문에, 클래스만 알면 네트워크 주소를 쉽게 분리할 수 있다.

예를 들어 클래스 A라면 앞의 8비트가 네트워크 주소고, 클래스 B라면 16비트, 클래스 C라면 24비트가 네트워크 부분이다. 따라서 라우터는 이 규칙에 따라 목적지 주소에서 네트워크 주소를 추출하며, 이는 클래스에 맞는 **비트 마스크를 AND 연산**하여 계산할 수 있다.

이렇게 얻은 네트워크 주소를 라우팅 테이블에서 검색하여 **일치하는 항목이 있으면 해당 next hop으로 패킷을 전달**한다. 만약 라우팅 테이블에 해당 네트워크 주소가 없다면, classful 환경에서는 **default route**로 패킷을 보내게 된다. 결국 classful forwarding은 “클래스를 통해 네트워크 부분을 고정적으로 추출하고, 테이블에서 찾으면 그쪽으로, 없으면 기본 경로로 보낸다”라는 단순한 흐름으로 동작한다. 

---
## Configuration for routing

또 다른 예시를 보자. 지금 170.14.5.165 를 가지는 곳에서 192.16.7.5 로 전송하고자 한다. 

![](../../images/Pasted%20image%2020251204221435.png)

170.14.5.165 호스트가 192.16.7.5로 패킷을 보내면 이 패킷은 먼저 R1의 m2 인터페이스로 들어오게 된다. R1은 패킷의 목적지 주소인 192.16.7.5를 확인한 뒤, 자신의 라우팅 테이블에서 이 주소가 어느 네트워크에 속하는지 가장 길게(prefix가 가장 구체적으로) 일치하는 항목을 찾는다. 

![](../../images/Pasted%20image%2020251204222216.png)

먼저 Class B 엔트리(145.80.0.0/16, 170.14.0.0/16)는 목적지와 전혀 일치하지 않기 때문에 제외된다. Class A 엔트리인 111.0.0.0/8도 주소 범위가 111._._.* 이기 때문에 192.16.7.5와 맞지 않는다.

그러나 Class C에 있는 192.16.7.0/24 엔트리는 목적지 주소(192.16.7.5)와 정확히 같은 네트워크에 속하므로 일치하게 된다. 특히 /24는 다른 엔트리보다 가장 길고 구체적인 prefix이기 때문에, R1은 이 엔트리를 최종적으로 선택하게 된다. 이 엔트리에는 다음 홉(next-hop) 주소로 111.15.17.32가 적혀 있으며, 인터페이스는 m0로 되어 있다. 따라서 R1은 패킷을 m0 인터페이스를 통해 111.15.17.32 방향으로 내보내게 된다. 이때 새로운 프레임을 만들면서 목적지 MAC은 next-hop(111.15.17.32)의 MAC 주소로 바뀌고, IP 헤더는 그대로 유지된다.

이러한 과정 덕분에 패킷은 R1을 떠나 111.15.17.32 라우터(그림 중앙의 파란 박스)로 전달되며, 이후 R3를 거쳐 최종 목적지인 192.16.7.5까지 도달하게 된다.

---
## Subnetting

이번 경우에는 subnet이 잇는 경우다. 사실 기본은 똑같다. 패킷 받으면 목적지 주소 추출해서 mask를 통해 서브넷 주소 찾고 테이블에서 찾기 

![](../../images/Pasted%20image%2020251204222706.png)

순서도 똑같다 .mast d
![](../../images/Pasted%20image%2020251204222803.png)
