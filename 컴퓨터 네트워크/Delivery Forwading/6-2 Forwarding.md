forwarding은 패킷을 최종 목적지로 보내기 위해 **라우터가 패킷을 적절한 경로로 넘겨주는 과정**을 의미한다. 쉽게 말해, “이 패킷이 어디로 가야 하는가?”를 결정하고, 그에 따라 **다음 hop(next hop)** 으로 패킷을 전달하는 동작이다.

오늘날의 인터넷은 다양한 링크와 네트워크가 서로 조합되어 연결된 구조이기 때문에, forwarding은 최종 목적지까지 한 번에 보내는 개념이 아니라 **각 구간마다 다음 hop으로 패킷을 계속 넘겨주는 방식**으로 이루어진다. 즉, 라우터는 전체 경로를 모두 따라가는 것이 아니라, routing 정보에 기반해 “이 패킷은 다음에 어느 장치로 가야 한다”를 판단하고, 그 다음 지점으로 패킷을 전달하는 역할을 수행한다.

결국 forwarding은 **라우터가 패킷을 목적지로 향하도록 올바른 위치로 이동시키는 동작**, 그리고 인터넷 구조에서는 **각 단계의 next hop으로 패킷을 넘기는 핵심 동작**이라고 이해할 수 있다.


![](../../images/Pasted%20image%2020251204220237.png)

라우터 끼리는 정보를 주고 받아서 full pathㄹ르 알고 있긴 하지만 full path를 알고 있는 상태에서 next hop만 테이블에 기록한다. 

---
## Network-specific method
예시처럼 N2 네트워크가 클래스 A 대역을 사용해 약 1,600만 개의 주소를 가진다고 가정해보면, 모든 라우터가 이 네트워크에 포함된 **모든 호스트 주소를 일일이 라우팅 테이블에 기록**하는 것은 사실상 불가능하다. 그렇게 하려면 테이블의 행 수가 기하급수적으로 늘어나고, 라우터의 메모리와 검색 속도에도 심각한 부담이 된다.

![](../../images/Pasted%20image%2020251204220417.png)

그래서 라우팅 테이블에는 개별 호스트 주소를 저장하지 않고, **여러 호스트가 공유하는 공통 구간**, 즉 해당 네트워크의 **네트워크 주소(prefix)**만 저장한다. 이는 “이 범위에 속하는 IP라면 모두 이쪽으로 보내라”는 의미로, 많은 개별 주소들을 하나의 범위로 묶어 관리할 수 있게 해준다.

---
## Host-specific routing

하지만 라우팅 테이블이 항상 이렇게 네트워크 주소만 포함하는 것은 아니다. 특정 경우에는 **특별히 지정된 개별 호스트 주소(host route)** 가 저장될 수도 있다. 예를 들어 아주 중요한 특정 서버로 가는 경로를 별도로 관리해야 한다거나, 네트워크 구조상 해당 호스트를 개별적으로 구분해야 하는 상황 등이 있을 수 있다.

![](../../images/Pasted%20image%2020251204220701.png)

---
## Default Routing

모든 라우터가 **모든 목적지 주소를 라우팅 테이블에 가지고 있을 필요는 없다.** 현실적으로 인터넷은 수많은 네트워크와 라우터가 연결된 거대한 구조이기 때문에, 모든 목적지에 대한 경로를 각 라우터가 모두 저장한다는 것은 비효율적일 뿐만 아니라 사실상 불가능하다.

![](../../images/Pasted%20image%2020251204220829.png)

그래서 라우터는 **주변(인접) 네트워크나 자주 사용하는 주요 네트워크 정보만** 라우팅 테이블에 저장하고, **나머지 목적지에 대해서는 다음 hop 라우터에 위임**하는 방식으로 동작한다. 즉, 자신이 정확한 경로를 몰라도, **다음 라우터는 알 수도 있다는 전제 하에** 패킷을 넘기는 것이다.

이러한 구조에서 활용되는 것이 바로 **default route(기본 경로)** 이다. 만약 특정 목적지에 대한 정보가 라우팅 테이블에 없다면, 라우터는 패킷을 **default route에 정의된 라우터(게이트웨이)** 로 전달한다. 이를 통해 **경로를 알 수 없는 목적지에 대해서도 무작정 폐기하지 않고, 마지막 희망처럼 기본 경로로 넘겨보는 것**이다.

---
## Simplified Forwarding module in classful address
classful 환경에서의 forwarding 과정은 비교적 단순한 구조로 이루어진다. 

![](../../images/Pasted%20image%2020251204221119.png)

먼저 패킷이 라우터에 도착하면, 라우터는 가장 먼저 **목적지 IP 주소를 확인**한다. 그 다음 이 주소가 **클래스 A, B, C 중 어느 범주에 속하는지**를 판단한다. classful 주소 체계에서는 클래스에 따라 네트워크 부분과 호스트 부분이 고정되어 있기 때문에, 클래스만 알면 네트워크 주소를 쉽게 분리할 수 있다.

예를 들어 클래스 A라면 앞의 8비트가 네트워크 주소고, 클래스 B라면 16비트, 클래스 C라면 24비트가 네트워크 부분이다. 따라서 라우터는 이 규칙에 따라 목적지 주소에서 네트워크 주소를 추출하며, 이는 클래스에 맞는 **비트 마스크를 AND 연산**하여 계산할 수 있다.

이렇게 얻은 네트워크 주소를 라우팅 테이블에서 검색하여 **일치하는 항목이 있으면 해당 next hop으로 패킷을 전달**한다. 만약 라우팅 테이블에 해당 네트워크 주소가 없다면, classful 환경에서는 **default route**로 패킷을 보내게 된다. 결국 classful forwarding은 “클래스를 통해 네트워크 부분을 고정적으로 추출하고, 테이블에서 찾으면 그쪽으로, 없으면 기본 경로로 보낸다”라는 단순한 흐름으로 동작한다. 

---
## Configuration for routing

또 다른 예시를 보자. 지금 170.14.5.165 를 가지는 곳에서 192.16.7.5 로 전송하고자 한다. 

![](../../images/Pasted%20image%2020251204221435.png)

170.14.5.165 호스트가 192.16.7.5로 패킷을 보내면 이 패킷은 먼저 R1의 m2 인터페이스로 들어오게 된다. R1은 패킷의 목적지 주소인 192.16.7.5를 확인한 뒤, 자신의 라우팅 테이블에서 이 주소가 어느 네트워크에 속하는지 가장 길게(prefix가 가장 구체적으로) 일치하는 항목을 찾는다. 

![](../../images/Pasted%20image%2020251204222216.png)

먼저 Class B 엔트리(145.80.0.0/16, 170.14.0.0/16)는 목적지와 전혀 일치하지 않기 때문에 제외된다. Class A 엔트리인 111.0.0.0/8도 주소 범위가 111._._.* 이기 때문에 192.16.7.5와 맞지 않는다.

그러나 Class C에 있는 192.16.7.0/24 엔트리는 목적지 주소(192.16.7.5)와 정확히 같은 네트워크에 속하므로 일치하게 된다. 특히 /24는 다른 엔트리보다 가장 길고 구체적인 prefix이기 때문에, R1은 이 엔트리를 최종적으로 선택하게 된다. 이 엔트리에는 다음 홉(next-hop) 주소로 111.15.17.32가 적혀 있으며, 인터페이스는 m0로 되어 있다. 따라서 R1은 패킷을 m0 인터페이스를 통해 111.15.17.32 방향으로 내보내게 된다. 이때 새로운 프레임을 만들면서 목적지 MAC은 next-hop(111.15.17.32)의 MAC 주소로 바뀌고, IP 헤더는 그대로 유지된다.

이러한 과정 덕분에 패킷은 R1을 떠나 111.15.17.32 라우터(그림 중앙의 파란 박스)로 전달되며, 이후 R3를 거쳐 최종 목적지인 192.16.7.5까지 도달하게 된다.

---
## Subnetting

이 경우에도 라우터가 패킷을 전달하는 과정은 동일하다. 패킷이 라우터에 도착하면 라우터는 먼저 IP 헤더에서 목적지 주소를 꺼낸다. 

![](../../images/Pasted%20image%2020251204222706.png)

이후 자신이 알고 있는 서브넷 마스크(/18)를 적용하여 목적지 주소가 속한 **서브넷(network address)**을 계산한다. 서브넷 마스크가 /18이라는 것은 주소의 앞 18비트가 네트워크 부분이라는 의미이며, 나머지 14비트는 호스트 부분이 된다. 즉, 라우터는 목적지 주소의 처음 18비트만 보고 어떤 서브넷에 속하는지를 판단할 수 있다.

![](../../images/Pasted%20image%2020251204222803.png)
145.14.0.0/16이라는 큰 사이트 전체가 다시 /18씩 잘려 총 네 개의 서브넷으로 나누어져 있기 때문에, 라우터는 다음과 같은 네 개의 가능한 서브넷을 미리 알고 있다:

- 145.14.0.0/18
    
- 145.14.64.0/18
    
- 145.14.128.0/18
    
- 145.14.192.0/18

패킷이 들어오면 라우터는 목적지 주소에 마스크를 적용하여 서브넷 주소를 계산하고, 이 계산된 서브넷 주소를 자신의 라우팅 테이블과 비교해 가장 정확하게 일치하는 엔트리를 찾는다. 예를 들어 목적지 주소가 145.14.192.123 같은 형식이라면, /18 마스크를 적용하면 145.14.192.0이 나오고, 라우팅 테이블에서 “145.14.192.0 → m3”라는 항목을 찾게 된다. 그러면 라우터는 패킷을 m3 인터페이스를 통해 해당 서브넷으로 전달한다.

만약 목적지 주소가 이 네 개 서브넷 중 어느 곳에도 속하지 않으면, 라우터는 테이블 맨 아래의 default 엔트리를 사용하여 패킷을 기본 라우터(m4)로 내보낸다. 즉, 서브넷이 존재하는 환경에서도 라우터의 동작은 매우 단순하고 일관적인데, 목적지 주소를 마스크 처리하여 서브넷 주소를 찾고, 그 주소가 테이블의 어떤 항목과 가장 잘 맞는지를 찾은 뒤, 그 인터페이스로 패킷을 내보내는 방식이다. 이렇게 서브넷이 많아져도 라우팅은 구조적으로 변하지 않고, 단지 테이블의 항목이 더 세분화될 뿐이다.

---
## Classless address
과거에는 classful 주소 체계를 사용했는데, 이 방식에서는 주소의 클래스(A, B, C)에 따라 네트워크 부분이 고정되어 있었다. 즉, 네트워크 마스크가 자동으로 결정되었기 때문에 라우터의 라우팅 테이블에는 **네트워크 주소, 다음 홉, 인터페이스**처럼 세 개의 열만 있으면 충분했다. 하지만 classful 주소 체계에는 주소 공간 낭비, 유연성 부족 등의 여러 문제점이 있었다. 

이런 이유로 현대의 인터넷은 classless 주소 체계(CIDR)를 사용하게 되었고, 이 방식에서는 각각의 네트워크가 `/n` 형태의 프리픽스를 통해 명시적으로 네트워크 범위를 지정한다. 따라서 라우터가 정확한 네트워크를 판단하기 위해서는 마스크 정보까지 포함해야 하므로, 라우팅 테이블에도 **네트워크 주소, 서브넷 마스크, 다음 홉, 인터페이스**처럼 적어도 네 개의 열이 필요하게 되었다.

라우팅 테이블에 있는 mask에 따라 가는 곳이 달라진다.

![](../../images/Pasted%20image%2020251204224116.png)

패킷이 라우터에 도착하면, 라우터는 먼저 IP 헤더에 있는 목적지 IP 주소만을 확인한다. 이때 패킷 안에는 네트워크 마스크가 포함되지 않기 때문에, 목적지 주소가 어떤 서브넷에 속하는지 판단하려면 라우터가 가지고 있는 **라우팅 테이블의 mask** 정보를 사용해야 한다. 라우터는 테이블의 엔트리들을 위에서 아래로 보면서, 각 엔트리의 mask를 목적지 주소에 적용해 어떤 네트워크에 해당하는지를 계산한다. 그리고 계산된 네트워크 주소가 테이블의 Network Address와 일치하면 그 엔트리를 선택해 패킷을 해당 인터페이스로 전달한다.

![](../../images/Pasted%20image%2020251204224155.png)

#### Example 1
예를 들어 목적지 주소가 **180.70.65.140**이라고 하자. 라우터는 먼저 가장 긴 prefix인 **/26**을 적용해본다. /26 마스크를 씌우면 주소는 **180.70.65.128**이 된다. 라우팅 테이블을 확인해보면 /26 엔트리의 네트워크 주소는 **180.70.65.192**이므로 일치하지 않는다. 그럼 이 엔트리는 사용되지 않는다.

다음으로 길이가 더 짧은 **/25** 마스크를 적용해본다. /25로 마스크를 씌우면 목적지 주소는 **180.70.65.128**이 되고, 이 값은 라우팅 테이블의 /25 항목의 네트워크 주소와 정확히 일치한다. 따라서 라우터는 이 엔트리를 사용해 해당 인터페이스(m0)를 선택하여 패킷을 다음 홉으로 전달한다.

#### Example 2
한번 더 해보자 이번 예시는 201.4.22.35 라고 하자 라우팅 테이블에 있는 마스크를 하나씩 위에서부터 적용해본다. /24 되어야 netwrok address와 동일하게 나온다 그런 경우 그냥 거기로 보낸다.

#### Example 3
18.24.32.78인 경우에 지금 라우팅 테이블에 있는 