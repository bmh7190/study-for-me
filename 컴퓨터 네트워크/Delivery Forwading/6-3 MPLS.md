MPLS, 즉 Multiprotocol Label Switching은 간단히 말해 **패킷에 고정 길이(label)를 붙여서 빠르게 포워딩하는 기술**이다. 기존의 IP 라우팅에서는 라우터가 패킷을 받을 때마다 IP 주소에 여러 마스크를 적용하면서 가장 긴 프리픽스를 찾고, 그 결과에 따라 포워딩 결정을 내렸다. 이러한 방식은 매 홉마다 비교 작업이 반복되고 계산량이 많기 때문에, 고속 네트워크에서는 성능이 떨어질 수 있다.

MPLS는 이 문제를 해결하기 위해 **IP 주소 대신 “고정 길이의 라벨(label)”을 사용하여 포워딩**한다. 라우터는 들어온 패킷에서 복잡한 주소 계산을 할 필요 없이, 붙어 있는 라벨 값을 보고 단순한 테이블 조회만으로 다음 홉을 결정할 수 있다. 그 결과 forwarding 속도가 크게 향상된다.

![](../../images/Pasted%20image%2020251204231434.png)

이 라벨은 **프레임 헤더와 IP 헤더 사이**에 삽입되며, 기존의 IP 패킷 구조에 추가되는 방식이라 패킷 형식이 완전히 달라진다. 따라서 한 라우터만 라벨을 붙인다고 해결되는 것이 아니라, 라벨을 주고받을 모든 라우터가 동일한 규칙과 구조를 이해하고 있어야 한다. 즉, MPLS 환경에서는 라우터들이 미리 정한 “라벨 스위칭 방식”을 통해 서로 협력하며 패킷을 처리하게 된다.

결과적으로 MPLS는 IP 라우팅의 느린 longest prefix match 과정을 대체하여, **간단한 라벨 기반 포워딩으로 고속 네트워크 환경에서 높은 처리 성능을 제공**하는 기술이다.

---
## MPLS Forwarding Tables 

MPLS에서는 패킷을 빠르게 포워딩하기 위해, 목적지 네트워크마다 하나의 **라벨(label)** 을 붙여서 전달한다. 이 라벨은 IP 주소 기반의 복잡한 longest prefix match를 대신하게 때문에, 라우터 간에는 서로 이해할 수 있도록 **라벨이 유일해야 하고**, 라우터들이 서로 라벨 정보를 주고받으며 테이블을 맞추어 나간다.

예시에 등장하는 목적지는 **A**라고 가정하자. 

![](../../images/Pasted%20image%2020251204231738.png)

A가 속한 가장 끝단의 MPLS 라우터(LER, Label Edge Router)는 자신의 라우팅 테이블을 기반으로 “A로 가려면 label 6을 사용하라”는 정보를 만든다. 그리고 이 라우터는 이 정보를 인접한 라우터, 즉 R3에게 전달한다.

R3은 이 정보를 받으면 자신의 LFIB(Label Forwarding Information Base)를 업데이트한다. R3의 입장에서는 “A로 가는 라벨은 out label = 6이다”라는 정보가 생긴 것이다. 하지만 MPLS 라우터들은 단순히 out label만 저장하는 것이 아니라, **자기에게 들어오는(incoming) 라벨도 정의**한다. 그래서 R3은 “A로 오려면 나에게 label 10으로 들어와라”라고 새로운 in-label을 지정한다. 즉, R3은 A로 향하는 경로에 대해 다음과 같은 매핑을 만든다:

- **in label = 10 → out label = 6**, out interface = 1

이 정보는 다시 R4로 전달되고, R4는 동일한 방식으로 자신에게 유일한 in-label을 생성해 A 경로에 대한 LFIB를 업데이트한다. 이 과정을 라우터들이 차례로 반복하면서, 목적지 A로 향하는 **end-to-end 라벨 스위치 경로(LSP)** 가 완성된다.

이 과정에서 중요한 점은, MPLS 라벨은 **각 라우터 지역(local)에서만 유일하면 된다.** 즉, 전 구간에서 동일할 필요는 없다.

라벨을 붙이고 읽을 수 있는 것은 **MPLS-capable 라우터**뿐이다. 일반 라우터는 MPLS 라벨을 이해하지 못하기 때문에 MPLS 영역 밖에서는 라벨이 제거된다.

결과적으로 MPLS 네트워크 내부에서는 복잡한 IP 주소 계산 대신 간단한 라벨 교환만으로 패킷을 전달할 수 있고, 이것이 MPLS가 빠른 이유이다.