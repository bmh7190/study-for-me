
**ACK에 대한 ACK은 없다.**

**데이터가 네트워크 전송 과정에서 순서가 뒤바뀌어 도착할 수는 있지만, TCP는 수신 측에서 임시로 저장(buffering) 해 두었다가 올바른 순서로 정렬한 뒤에만 상위 애플리케이션(프로세스)에 전달한다.**

**TCP의 가장 큰 장점은 신뢰성 보장이다.**

---
### TCP의 ACK 전송 규칙 (Delayed ACK Rules)

![](../images/Pasted%20image%2020251014001241.png)

**규칙 1.**  
보낼 데이터가 **Sending Buffer**에 이미 존재한다면, **ACK을 단독으로 보내지 않고 데이터와 함께 전송**한다.  
→ 즉, 응답(ACK)과 송신 데이터를 하나의 세그먼트로 합쳐서 전송하여 효율성을 높인다.

**규칙 2.**  
보낼 데이터가 없다면, **즉시 ACK을 보내지 않고 약 50ms 정도 기다린다.**  
→ 혹시 그 사이에 보낼 데이터가 생기면 ACK과 함께 보낼 수 있도록 하기 위함이다.

**규칙 3.**  
기다리는 동안 **새로운 데이터가 전송 버퍼로 들어오면**, **지체 없이 즉시 ACK을 보낸다.**  
→ 대기 시간을 최소화하면서도 네트워크 효율을 유지하기 위한 동작이다.

---
### 예외 상황에서는 Delay 없이 ACK 보내기

![](../images/Pasted%20image%2020251014001548.png)

**규칙 4.**  
수신한 **Sequence Number(순서 번호)** 가 예상한 번호보다 크다면,  
즉 **중간 번호가 건너뛰어 도착했다면**, 그 사이의 데이터가 **유실된 것으로 간주**한다.  

이때 수신 측은 **유실된 데이터의 다음에 해당하는 ACK 번호**를 즉시 보낸다.  
이 과정을 통해 송신 측이 누락된 세그먼트를 재전송하도록 유도한다.  

예: 1001 이후 1201이 오면, 1001~1200 구간이 사라졌다고 판단하고 **ACK=1001**을 계속 보냄.


**규칙 5.**  
만약 나중에 **유실되었던 세그먼트**가 도착하면, 수신 측은 **버퍼의 중간 부분을 채워서 전체 데이터 순서를 복원**한다. 그리고 **지금까지 연속적으로 받은 데이터의 마지막 번호 + 1**을 ACK 번호로 넣어 **즉시 ACK을 전송**한다.  

→ 이렇게 함으로써 송신 측은 수신 측이 어느 지점까지 데이터를 완전하게 받았는지를 알 수 있다.


따라서 **TCP는 전송 도중 데이터가 일부 유실되더라도 이를 자체적으로 복구하여 순서에 맞게 재조립한 뒤 Application 계층으로 전달한다.**  

그 결과, **Application 계층은 TCP가 전달한 데이터가 완전하고 순서가 올바르다고 믿을 수 있다.**

---
### Fast retransmission

데이터 전송 중 일부 세그먼트가 유실되면,  
**수신자는 이를 바로 감지하고 규칙 4에 따라 유실된 데이터의 다음 번호(즉, 기대하는 Sequence Number)** 를 **ACK 번호로 보내게 된다.**  

예를 들어, `Seq=1,2,4`만 도착하고 `3`이 사라졌다면, 수신자는 계속 `ACK=3`을 반복해서 보낸다.

![](../images/Pasted%20image%2020251014002120.png)

그러나 송신자 입장에서는 **Window Size가 허락하는 한**, 아직 ACK이 오지 않아도 데이터를 연속으로 전송할 수 있다.  이 과정에서 수신자는 계속 **같은 ACK 번호(예: ACK=3)** 를 반복해서 보내게 된다.

TCP는 **같은 ACK이 3번 연속 도착하면**,  “아, 그 구간(예: Seq=3)에 문제가 생겼구나”라고 판단하고, **RTO 타이머가 만료되기 전에 즉시 해당 세그먼트를 재전송한다.**  

이 메커니즘을 **Fast Retransmission(빠른 재전송)** 이라고 한다.

> 즉, **RTO 타이머를 기다리지 않고** 중복 ACK을 기반으로 신속하게 손실을 복구하는 방법이다.

---
### ACK 유실 시의 동작

지금까지는 **데이터 손실**의 경우만 다뤘지만,  이번엔 반대로 **ACK 자체가 전송 중 유실된 경우**를 생각해보자.

![](../images/Pasted%20image%2020251014003526.png)

일반적으로 큰 문제는 발생하지 않는다.  

왜냐하면 TCP는 **누적 확인(Acknowledgment, cumulative ACK)** 방식을 사용하기 때문이다.  이전 ACK이 손실되더라도 **그 다음 ACK**이 오면  “이전까지의 데이터도 다 잘 받았구나”라고 송신자는 해석할 수 있다.

![](../images/Pasted%20image%2020251014003514.png)

하지만, 만약 송신자가 **데이터를 한 번만 보내고 그 뒤로 추가 데이터를 보내지 않았다면**,  그 이후에는 새로운 ACK이 발생하지 않는다.  이 경우 송신자는 RTO 타이머가 만료될 때까지 기다리다가  “문제가 있다”고 판단하고 **해당 데이터를 다시 재전송**한다.

그때 수신자는 이미 그 데이터를 받은 상태이므로,  “아, 내가 보낸 ACK이 도중에 유실됐구나!”라고 인식하고 **즉시 새로운 ACK을 다시 보내게 된다.**

이 동작이 바로 **규칙 6**이다.

---
### ACK 유실로 발생하는 DeadLock

TCP에서 수신 측은 데이터를 받을 때마다 **ACK 패킷**을 보낸다.  
이때 단순히 “데이터 잘 받았어요”라는 응답(ACK 번호)뿐만 아니라,  
**자신의 수신 버퍼 여유 공간(rwnd: Receive Window)** 크기도 함께 보낸다.  
이 정보는 송신 측이 **얼마만큼의 데이터를 더 보낼 수 있는지** 판단하는 데 사용된다.

만약 수신 측의 버퍼가 꽉 차서 **rwnd = 0**이 되면,  수신 측은 “지금은 공간이 없으니 잠시 보내지 마세요”라는 의미의 ACK을 송신 측에 보낸다. 그 이후 버퍼에 여유가 생기면 다시 **rwnd > 0**인 ACK을 보내  “이제 데이터 전송해도 됩니다!”라고 알려줘야 한다.

하지만 이 ACK이 **전송 도중 유실되면**, 송신자는 여전히 “상대 버퍼가 꽉 찼다”고 믿고 대기 상태에 머물고, 수신자는 “공간이 생겼으니 상대가 보내주겠지” 하고 기다리게 된다.

이처럼 **서로 기다리는 교착 상태(Deadlock)** 가 발생할 수 있다.

#### 해결방법
이 문제를 해결하기 위해 TCP는 **Persistence Timer(지속 타이머)** 를 사용한다. 송신 측은 **rwnd = 0**인 ACK을 받으면 이 타이머를 작동시킨다. 만약 일정 시간이 지나도 수신 측으로부터 새로운 **rwnd 업데이트**가 오지 않으면, 송신 측은 “혹시 상대의 ACK이 유실된 건 아닐까?”를 확인하기 위해 **아주 작은 데이터(보통 1바이트 정도)** 를 담은 **Probe Segment** 를 보낸다.

Probe Segment가 수신 측에 도착하면, 수신 측은 즉시 다음 중 하나로 응답한다. **버퍼가 여전히 꽉 차 있다면** rwnd=0인 ACK을 다시 보낼 것이고, **버퍼에 여유가 생겼다면** 갱신된 rwnd 값을 포함한 ACK을 보낸다.

이 과정을 통해 송신 측은 상태를 다시 파악하고, 데이터 전송을 재개하거나 대기를 이어간다.

