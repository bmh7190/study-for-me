
## Bellman-Ford algorithm

“어떤 경로로 가야 최단 경로가 되는가?”를 찾기 위한 알고리즘이다.

간단하게 정리하면 한 번에 **1 hop** 이동했을 때 드는 비용을 확인하고, 그 **1 hop 이후부터 목적지까지의 최단 거리**를 더해서 전체 비용이 가장 작아지는 방향으로 경로를 선택하는 방식이다.

즉, **각 간선을 기반으로 계속 거리 값을 갱신(relaxation)** 하며,  
“이쪽을 통해 가면 더 짧게 갈 수 있는가?”를 반복적으로 확인해서  
최종적으로 가장 짧은 경로를 찾아내는 알고리즘이다.

![](../../images/Pasted%20image%2020251201220422.png)

업데이트된 예시 테이블을 보면, 각 노드마다 **목적지(To)**, **해당 목적지까지의 비용(Cost)**, 그리고 **그 목적지로 가기 위해 다음에 어떤 노드로 이동해야 하는지(Next)** 가 정리되어 있다.

직접 연결된 목적지의 경우에는 중간 단계가 필요 없기 때문에 **Next가 비어 있는 것**을 확인할 수 있다.

![](../../images/Pasted%20image%2020251201221243.png)

예를 들어 **A의 테이블**에서 E로 가는 항목을 보자.  

Cost가 **6**, 그리고 Next가 **C**로 적혀 있다. 즉, A에서 E로 가려면 먼저 **C로 이동해야 한다**는 의미다.

그렇다면 실제로 C에서 E까지 비용이 얼마인지 C 테이블에서 확인해 보면, E에 대한 Cost가 **4**, 그리고 Next가 비어 있다. 이는 **C → E가 직접 연결되어 있고 비용이 4**라는 뜻이다.

따라서 A에서 C로 가는 비용이 2이고, C에서 E로 가는 비용이 4이므로,

**A → C → E = 총 비용 6**

이 값이 A 테이블에서 E까지 가는 최소 비용으로 적혀 있는 것을 확인할 수 있다.

---
## Initialization of tables in distance vector routing

처음부터 모든 Cost 값이 채워져 있는 것은 아니다. 초기 상태에서는 **직접(direct) 연결된 목적지들만 Cost가 채워져 있고**,  그 외의 목적지는 비용도, Next도 알 수 없는 상태로 시작한다.


![](../../images/Pasted%20image%2020251201221658.png)

예를 들어 B를 보면, B는 D와 직접 연결되어 있지 않기 때문에 초기에는 **D로 가는 Cost도 모르고 Next도 비어 있다.** 

하지만 B가 **직접 연결된 A의 테이블 정보**를 전달받을 수 있다면 상황이 달라진다. A의 테이블에 “A가 D로 가는 방법과 비용”이 적혀 있다면, B는 **B → A → D**로 가는 경로를 계산할 수 있게 된다. 즉, A를 거쳐서 D로 갈 수 있다는 사실을 새롭게 배우는 것이다.

이 과정이 Bellman–Ford의 핵심이다:

1. **각 노드는 직접 연결된 이웃에게 자신의 라우팅 테이블을 보낸다.**
    
2. **이웃의 테이블을 받은 노드는, 그 정보를 기반으로 자신의 Cost와 Next를 업데이트한다.**
    
3. 만약 업데이트가 발생하면, 그 노드는 **변경된 내용을 다시 자신의 이웃들에게 전파**한다.
    
4. 이러한 과정이 반복되면서 네트워크 전체에 정보가 확산되고, 결국 모든 노드의 테이블이 **최소 비용으로 수렴**하게 된다.

즉, 테이블은 처음부터 완성되어 있는 것이 아니라 **이웃 간 정보 교환을 반복하며 점점 완성되어 가는 구조**이다.

---
## Updating in distance vector routing

자, 이제 **업데이트가 어떻게 이루어지는지**를 좀 더 자세히 살펴보자.

위 그림은 **C의 테이블 정보를 바탕으로 A의 테이블이 업데이트되는 상황**을 나타낸 것이다.

![](../../images/Pasted%20image%2020251201222349.png)

먼저 A는 C로부터 “C에서 각 목적지까지 가는 비용 정보”를 전달받는다. A에서 C로 가는데 필요한 비용을 모두 더한다. 그다음 A는 **C로부터 받은 테이블의 각 항목에 대해 Next를 모두 C로 채워 둔 뒤**, 이 값을 A가 기존에 가지고 있던 테이블과 하나씩 비교한다.

만약 **C를 거쳐서 가는 비용이 더 적거나**, A가 **아직 가지고 있지 않았던 새로운 경로라면**, 그 항목은 A의 테이블에서 **새로운 최단 경로로 갱신**된다. 이때 우리는 이미 Next를 C로 채워둔 상태이기 때문에, 그 **한 줄을 그대로 A의 테이블에 옮겨 적기만 하면 된다.**

그리고 이렇게 테이블이 한 번 업데이트되고 나면, 그걸로 끝나는 것이 아니라 **A도 다시 자신과 직접 연결된 이웃 노드들에게 변경된 정보를 전파**하게 된다.  

이런 식으로 정보가 계속 퍼져 나가면서 전체 네트워크의 경로 정보가 점점 더 정확해진다.

---
### 만약 C테이블에서 Cost가 높아졌다면?
A가 C로부터 전달받은 정보를 바탕으로 테이블을 비교하는 상황을 생각해보자. 보통은 **C를 거쳐 가는 비용이 더 낮을 때만** A 테이블을 업데이트한다.  

그런데 만약 **C 테이블의 기존 경로 비용이 갑자기 높아진다면** 어떻게 될까?

A 입장에서 보면 이렇게 된다. C가 보낸 Cost가 **원래 자신이 가지고 있던 값보다 더 크기 때문에**,
일반적인 업데이트 규칙으로는 **A가 이 정보를 반영할 수 없다.**

즉, 기존 규칙대로라면 “비용이 더 크니까 업데이트할 이유가 없다”고 판단해 버리는 것이다.  
하지만 이렇게 되면 문제가 생긴다. **경로가 실제로 사라졌거나 비용이 증가한 상황을 A가 알지 못하게 되기 때문이다.**

그래서 “누가 이 업데이트를 보냈는가”를 알고 있어야 한다.

즉, **Next(다음 hop)** 가 **C**인 경로를 업데이트할 때는, 그 업데이트가 **바로 C로부터 온 정보**라면 Cost가 커졌더라도 **무조건 반영**해야 한다.

왜냐하면 C를 통해 E로 가고 있었는데 C가 “이제 E까지 가는 비용이 더 커졌다”고 알려주면 A는 **그 정보를 신뢰하고 기존의 경로 값을 바꿔야 한다.** 그렇지 않으면 A는 **옛날의 잘못된 최단 경로**를 계속 유지하게 된다.

---
## Two node instability

Distance Vector 라우팅에서 흔히 발생하는 문제가 바로 **two-node instability**, 즉 두 노드 간의 불안정한 루프가 생기는 상황이다. 

![](../../images/Pasted%20image%2020251202202817.png)
위의 예시를 보면 X–A–B가 연결되어 있고, 처음에는 A만 X까지의 경로를 알고 있다가 주기적인 라우팅 정보 교환을 통해 B도 A를 경유한 X 경로를 알게 된다. 이때 B 입장에서는 A까지 비용이 1이고 A에서 X까지 비용이 1이므로 총 비용이 2, 경로의 next-hop은 A가 된다. 


문제는 X와 A의 연결이 끊어졌을 때 시작된다. 
![](../../images/Pasted%20image%2020251202203324.png)

A는 더 이상 X로 갈 수 없기 때문에 X까지의 비용을 무한대로 표시하고, 이 변화가 발생했음을 B에게 알리기 위해 업데이트를 전송하려 한다. 하지만 이 타이밍에 B가 먼저 주기적 업데이트를 보내면서 상황이 꼬인다. B의 테이블에는 여전히 “A를 통해 X로 갈 수 있다”는 이전의 정보가 남아 있기 때문에 B는 A에게 그 정보를 다시 전송한다. A는 자신의 테이블에서는 X로 갈 수 없지만 B의 테이블에는 여전히 유효한 경로가 있는 것처럼 보이기 때문에, 그 정보를 믿고 X 경로를 B를 통해 복구해 버린다.


![](../../images/Pasted%20image%2020251202203357.png)

이렇게 잘못된 갱신이 한 번 일어나면 A와 B는 서로를 next-hop으로 삼으며 X까지의 비용을 계속 증가시키는 루프에 빠진다. A는 “B를 통해 X 갈 수 있다”고 믿고, B는 다시 “A를 통해 X 갈 수 있다”고 믿는 식이다. 두 노드는 서로에게 업데이트를 전송하며 비용을 계속 1씩 증가시키고, 결국 프로토콜에서 정의한 무한대 값(예: RIP의 경우 16)에 도달해야 겨우 루프가 멈춘다.

![](../../images/Pasted%20image%2020251202203503.png)

이처럼 두 노드가 서로의 오래된 정보를 신뢰하며 경로를 계속 재구성하기 때문에, 단순한 전파 방식만으로는 이 오류를 막을 수 없다. 이것이 바로 two-node instability이자 count-to-infinity 문제의 핵심이다.

---
이런 two-node instability 상황을 방지하기 위해 Distance Vector 라우팅에서는 세 가지 대표적인 대응 기법을 사용한다.

### 무한대를 16으로 설정하기
첫 번째 방법은 **무한대 값을 16으로 설정하는 것**이다. 라우팅 테이블에서 무한대는 해당 목적지로 갈 수 없음을 의미하는데, RIP과 같은 프로토콜에서는 이 값을 16으로 정의한다. 일반적으로 하나의 AS 내에서 3~4개의 라우터만 지나도 다른 AS로 넘어가는 경우가 많기 때문에, 16이라는 숫자는 실제 네트워크 규모에 비해 상당히 큰 값으로 취급된다. 이는 count-to-infinity 문제를 완전히 해결하지는 못하지만, 비용이 끝없이 증가하는 반복을 제한해 악화되는 속도를 줄여 준다는 의미가 있다.

### Split Horizon
두 번째 방법은 **Split Horizon**이다. 위 예시에서 문제가 생긴 핵심 원인은 B가 A로부터 배운 경로(X까지 A를 통해 갈 수 있다는 경로)를 다시 A에게 광고했기 때문이다. Split Horizon은 바로 이 점을 차단한다. 즉, _어떤 이웃을 통해 배운 경로는 그 이웃에게 다시 보내지 않는다_는 원칙이다. 이렇게 하면 A는 B가 준 잘못된 업데이트를 받을 일이 없기 때문에 두 노드 간의 루프가 자연스럽게 방지된다.

### Split Horizon with Poison Reverse
세 번째 방법은 **Split Horizon with Poison Reverse(독약 반전)** 이다. 기본 Split Horizon은 정보를 “안 보내는 것”이지만, 이 방식은 그보다 한 단계 더 적극적이다. 단순히 보내지 않는 대신, 그 이웃에게는 해당 경로를 **일부러 ‘무한대’(즉, 갈 수 없음)으로 표시하여 보내는 방식**이다. 이렇게 하면 상대 라우터는 “이 경로를 안 알려주는 게 아니라, 명시적으로 갈 수 없다고 말하는구나”라고 명확히 이해할 수 있다. 따라서 위와 같은 상황에서도 A는 B가 보내온 ‘X까지 비용 = ∞’ 값을 보고 절대 그 경로를 다시 살리려 하지 않으며, 결과적으로 두 라우터가 서로 잘못된 정보를 주고받는 루프가 근본적으로 차단된다.

---
## Three node instability

그렇다면 앞에서 언급한 세 가지 기법을 사용하면 모든 경우를 완벽히 방지할 수 있을까? 아쉽지만 그렇지는 않다. 두 노드만 있을 때는 Split Horizon이나 Poison Reverse가 상당히 효과적인데, **세 개 이상의 노드가 연결된 상황에서는 여전히 count-to-infinity 문제가 발생할 수 있다.**

![](../../images/Pasted%20image%2020251202204729.png)

예를 들어 A–B–C 세 라우터가 있고, A는 X까지의 실제 경로를 알고 있다고 하자. 이때 X와 A의 연결이 끊어지면 A는 이를 B와 C 양쪽에 전파한다. B는 정상적으로 업데이트를 받았지만, C로 가는 패킷이 유실되었다고 가정하면 문제가 시작된다.

C는 A로부터 “X는 더 이상 갈 수 없다”는 메시지를 받지 못했기 때문에 여전히 자신의 테이블에 기존의 X 경로를 유지하고 있다. Split Horizon with Poison Reverse 때문에 C는 A에게는 무한대(cost=∞)로 광고하므로 A와의 루프는 발생하지 않는다. 하지만 문제는 C가 **B**에게 보내는 갱신이다. C의 라우팅 테이블에서 X의 next-hop은 여전히 A였기 때문에, C는 B에게 X에 대한 **원래 비용 그대로** 광고를 보내게 된다.

![](../../images/Pasted%20image%2020251202205711.png)

이를 받은 B는 “내가 갖고 있던 X 경로보다 C를 통해 가는 게 더 낫네?”라고 판단하고 자신의 라우팅 테이블을 C 경유로 갱신한다. 갱신이 일어났으니 B는 다시 A에게 이를 전파하고, A는 또다시 “B를 통해 X로 갈 수 있구나”라고 오판하여 테이블을 갱신해 버린다. 이렇게 A가 갱신하면 다시 C에게 전파하고, C는 또 그 정보를 기반으로 B에게 보내고… 이런 루프가 계속 반복되면서 ABC 세 노드는 X까지의 비용을 서로 조금씩 증가시키며 전파하게 된다.

![](../../images/Pasted%20image%2020251202210153.png)

결국 이 비용은 라우팅 프로토콜에서 정의한 최대값, 즉 무한대(예: RIP의 경우 16)까지 증가한 뒤에야 루프가 멈춘다. 즉 Split Horizon이나 Poison Reverse는 **두 노드 간의 직접적인 경로 오해를 막는 데에는 강력하지만**, 세 노드 이상이 연쇄적으로 잘못된 정보를 유지할 경우에는 완벽한 해결책이 되지 못한다는 한계가 여기에 있다.

이처럼 여러 노드가 얽힌 경우에는 라우팅 테이블이 자동적으로 돌아가는 특성 때문에 문제가 한 번 꼬이면 스스로 복구되기 어려운 상황이 생기기도 한다. 특히 count-to-infinity가 진행되는 동안에는 비용이 계속 증가하며 잘못된 정보가 라우터 사이를 순환하기 때문에, 프로토콜의 정상적인 동작만으로는 빠르게 안정화되기 힘들다. 그래서 정말 급한 상황에서는 **라우터를 강제로 껐다 켜서 라우팅 테이블을 초기화하는 방법**을 쓰는 경우도 있다. 초기화가 이루어지면 모든 경로 정보가 리셋되고, 라우터는 다시 이웃과 테이블을 교환하며 올바른 상태로 수렴할 수 있게 된다. 물론 이는 근본적인 해결책이라기보다 최후의 수단에 가깝고, 장기적으로는 Split Horizon, Poison Reverse, Hold-Down과 같은 보조 메커니즘을 적절히 조합해 루프가 생기지 않도록 설계하는 것이 중요하다.