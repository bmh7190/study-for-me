Distance Vector와는 달리, 인트라 도메인에서 사용되는 또 다른 방식인 **Link State Routing**은 네트워크를 바라보는 관점 자체가 다르다. 이 방식에서는 각 라우터가 자신과 _직접 연결된 링크_에 대한 정보만큼은 정확히 알고 있다고 가정한다. 즉, “내가 누구와 연결되어 있고 비용은 얼마인지”에 대한 로컬 정보는 확실하다.

![](../../images/Pasted%20image%2020251202210729.png)

이 로컬 정보를 각 라우터는 네트워크 전체에 **flooding** 방식으로 전파한다. 하나의 라우터가 자신의 링크 상태 정보를 생성하면, 이웃 라우터는 이를 그대로 다른 라우터에게 전달하고, 또 그 이웃이 다시 전달하는 식으로 네트워크 전역으로 퍼져나간다. 결국 모든 라우터는 네트워크 내 모든 링크에 대한 정보를 완전히 동일하게 갖게 된다.

이렇게 모든 라우터가 _전체 네트워크의 지도_를 공유하게 되면, 이제 각 라우터는 자신의 관점에서 네트워크를 하나의 그래프로 보고, 그 그래프 위에서 자신을 루트로 삼아 **최단 경로 트리(Shortest Path Tree)** 를 계산할 수 있다. 이때 사용하는 알고리즘이 바로 **다익스트라(Dijkstra) 알고리즘** 이다. 따라서 Link State 방식에서는 각 라우터가 동일한 전체 정보를 기반으로 독립적으로 최단 경로를 계산하기 때문에, Distance Vector 방식에서 나타나는 루프나 count-to-infinity 문제를 원천적으로 피할 수 있다.

---
## Dijkstra Algorithm 
다익스트라 알고리즘에서는 두 가지 리스트가 핵심적으로 사용된다. 하나는 **confirmed list**로, 여기에는 _최종적으로 최단 경로가 확정된 노드_들이 들어간다. 다른 하나는 **tentative list**로, _아직 확정되지 않았지만 후보로 올라온 경로들_이 임시로 저장된다.

![](../../images/Pasted%20image%2020251202212509.png)

예시에서 루트 노드는 D이므로, 시작 단계에서 D는 이미 confirmed list에 포함되어 있다. 그 다음으로는 D와 직접 연결된 B와 C에 대한 비용과 next-hop 정보를 tentative list에 가져온다. 이 후보들 중에서 비용이 가장 작은 노드, 즉 C가 먼저 확정되므로 C를 confirmed list에 추가한다.

이제 C를 통해 갈 수 있는 새로운 경로들을 다시 tentative list에 등록한다. C를 거쳐서 들어온 값들이므로 이들의 next-hop은 모두 C가 된다. 이 과정에서 중요한 점은, 이미 tentative list에 올라와 있던 경로와 새로 들어온 경로를 **비용 기준으로 비교해 갱신해야 한다는 것**이다. 예를 들어 이미 “B까지 비용 11, next=D”라는 정보가 있었는데, 새로 “B까지 비용 5, next=C”라는 후보가 들어왔다면, 더 작은 비용인 후자를 선택하며 기존 정보는 삭제된다.

이렇게 tentative list에서 가장 비용이 작은 후보를 차례대로 confirmed list에 확정하고, 확정된 노드를 통해 확장된 경로들을 다시 후보로 넣는 과정을 반복하면, 결국 모든 노드에 대해 D에서 출발하는 최단 경로가 결정된다. 이 방식이 바로 다익스트라 알고리즘의 핵심 작동 방식이다.

---
## Forming shortest path three for router A in a graph

다익스트라 알고리즘의 또 다른 예시를 살펴보자. 아래 그림이 전체 네트워크의 링크 상태를 나타내는 토폴로지라고 가정하자. 우리는 노드 A에서 출발해 각 노드까지의 최단 경로를 구하는 과정을 단계별로 추적해보려고 한다.

![](../../images/Pasted%20image%2020251202213022.png)

먼저 A와 직접 연결되어 있는 노드들을 후보 리스트에 올린다. 이 경우 A와 바로 연결된 노드는 B와 D이므로, 두 노드를 tentative 상태로 등록한다. 

![](../../images/Pasted%20image%2020251202213123.png)

두 노드의 비용을 비교해보면 B의 비용이 더 작기 때문에 가장 먼저 B를 확정(confirmed) 리스트에 넣는다.

![](../../images/Pasted%20image%2020251202213231.png)

B가 확정되면, 이제 B와 직접 연결된 노드들을 통해 확장된 경로를 다시 후보 리스트에 추가한다. B와 연결된 E와 C가 새롭게 후보군에 들어오게 되며, 이때 비용은 “A→B까지의 비용 + B→해당 노드까지의 비용”을 누적하여 계산한다. 이렇게 해서 후보군에는 D, E, C 세 노드가 있게 된다.

![](../../images/Pasted%20image%2020251202213413.png)

이제 후보군에서 가장 비용이 낮은 노드를 선택해야 하는데, 현재 비용이 가장 작은 노드는 D이다. 따라서 D를 두 번째로 확정한다. 그 뒤에는 D와 연결된 E를 다시 고려하게 되고, 필요하다면 기존 후보군에 있는 노드들과 비용을 비교하여 더 작은 경로가 발견되면 갱신한다.

![](../../images/Pasted%20image%2020251202213601.png)

이 과정을 반복하다 보면, 각 노드까지의 최단 거리와 그 경로에 포함되는 다음 홉(next-hop)이 차례차례 확정된다. 결국 A를 루트로 하는 최단 경로 트리(Shortest Path Tree)가 완성되며, 이는 Link State Routing에서 실제 라우팅 테이블의 기초가 된다.

똑같은 cost라면 아무거나 선택해서 확정하면 된다! 