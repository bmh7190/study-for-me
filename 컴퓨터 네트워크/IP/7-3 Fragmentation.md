데이터그램은 여러 종류의 네트워크를 거쳐 전달될 수 있다. 각 라우터는 먼저 자신이 받은 프레임에서 **IP 데이터그램을 decapsulation** 하여 꺼낸 뒤, IP 헤더를 검사하고 필요한 처리를 수행한다. 이후 해당 데이터그램을 다음 네트워크로 보내기 위해 **새로운 프레임으로 다시 encapsulation** 한다.

이때 **수신한 프레임의 형식과 크기**는 방금 지나온 물리 네트워크의 프로토콜에 따라 달라진다. 반대로 **라우터가 다시 전송하는 프레임의 형식과 크기**는 앞으로 이 데이터그램이 이동할 물리 네트워크가 어떤 프로토콜을 사용하는지에 따라 결정된다.

즉, 데이터그램은 동일하지만, 이를 담는 ‘프레임’의 구조와 크기는 네트워크마다 서로 다르며, 라우터는 매 구간마다 이러한 재캡슐레이션 과정이 반드시 필요하다.

---
## MTU
각 physical network(물리 네트워크)는 자신만의 **MTU(Maximum Transmission Unit)**, 즉 _전송할 수 있는 프레임의 최대 크기_를 가지고 있다. 이 값은 네트워크 기술(Ethernet, Wi-Fi, PPP, 광케이블 등)에 따라 서로 다르다.

문제는, **송신 측과 수신 측이 사용하는 네트워크의 MTU가 동일할 필요가 없다는 점**이다. 어떤 구간은 MTU가 4500바이트일 수도 있고, 다른 구간은 1500바이트일 수도 있다. IP 데이터그램은 여러 네트워크를 거쳐 전달되기 때문에, 특정 구간에서 허용되는 MTU보다 데이터그램이 더 크면 **그 구간에서는 그대로 보낼 수 없다.**

예를 들어,

- 송신자의 네트워크 MTU: **4500바이트**
    
- 중간 라우터 혹은 수신자의 MTU: **1500바이트**

송신자가 4500바이트짜리 데이터그램을 만들어도, MTU가 1500바이트인 네트워크 구간에서는 이를 한 번에 전송할 수 없다. 따라서 IP는 **데이터그램을 잘라서(fragmentation)** 여러 조각으로 나누어 보내게 된다.

요약하면, **네트워크 구간마다 MTU가 다르기 때문에** 원본 데이터그램이 너무 크면 반드시 나누어서 전송해야 하며, 이것이 바로 IP fragmentation이 발생하는 이유다.

![](../../images/Pasted%20image%2020251124231603.png)

---
## Flags field

MTU 때문에 데이터그램을 나누어 보낼 필요가 있는 경우, IP 헤더의 **Flag 필드(3비트)** 는 해당 패킷이 분할되었는지, 그리고 더 이어지는 조각이 있는지를 알려준다.

Flag 필드는 총 3비트이며 구성은 다음과 같다:

![](../../images/Pasted%20image%2020251124232243.png)

1. **비트 0 (Reserved bit)**
    
    - 항상 0이어야 하고 사용되지 않는다.
        
2. **비트 1 (DF: Don’t Fragment)**
    
    - 값이 **1이면: “분할하지 마라(Do Not Fragment)”**
        
    - 값이 **0이면: 필요하면 분할해도 된다**

3. **비트 2 (MF: More Fragments)**
    
    - 값이 **1이면: “이 뒤에 더 많은 조각이 있다” → 아직 분할 중인 fragment**

만약 **분할 금지** 로 설정된 패킷이 네트워크를 지나가는데, 그 구간의 MTU가 패킷 전체 길이보다 작다면 원래는 패킷을 쪼개서 보내야 한다. 하지만 DF가 1이므로 분할할 수 없다는 뜻이다. 

이 경우 라우터는 해당 패킷을 **그 자리에서 폐기(drop)** 한다.
일반적으로는 ICMP “Fragmentation Needed” 메시지를 송신자에게 보낸다(IPv4 기준).

---
## Fragmentation example

IP 패킷이 MTU보다 클 경우, 라우터는 패킷을 여러 조각(fragment)으로 쪼개어 보낸다. 이때 **모든 fragment는 원래 IP 헤더를 그대로 복사해서 사용**하고, **데이터 부분만 나누어** 전송한다.

문제는, 목적지에 도착하는 fragment들이 **항상 순서대로 도착하지는 않는다**는 점이다.  
따라서 수신 측은 “각 조각이 원래 데이터의 어디에 해당하는지”를 알아야 조합할 수 있다.

![](../../images/Pasted%20image%2020251124232428.png)

이 문제를 해결하기 위해 IP 헤더에는 **Fragmentation Offset(조각 오프셋)** 필드가 존재한다.

이 필드는 “현재 조각의 데이터가 원래 패킷의 **몇 번째 위치부터 시작하는지**”를 알려준다. 수신 측은 Offset 정보를 바탕으로 조각들을 원래 자리 순서대로 재배치하여 하나의 완전한 데이터그램을 복원한다.

### 왜 13비트인가? 그리고 왜 8로 나누는가?

Fragmentation Offset은 **13비트**로 구성되어 있다.  하지만 13비트로 표현할 수 있는 최대 숫자는 2¹³ = **8192 단위** 로오프셋의 최대 표현 범위가 제한되어 있다.

그런데 IP 패킷의 실제 데이터는 훨씬 더 큰 크기가 될 수 있기 때문에, 옵셋을 그대로 1바이트 단위로 넣으면 **13비트 공간이 부족해지는 경우가 생긴다.**

이를 해결하기 위해 IP는 **8바이트 단위(block)** 로 오프셋을 기록한다.

즉, 보내는 쪽(sender)은 시작 위치를 **8바이트로 나누어** Offset 필드에 저장한다. 그리고 받는 쪽(receiver)은 Offset 필드의 값을 다시 **8을 곱해서** 원래의 바이트 위치를 계산한다.

이 방식은 헤더 길이를 IHL에서 4바이트 단위로 기록하는 방식과 비슷한 개념이다.

예시를 보면 원래 4000바이트 크기의 데이터그램이 MTU 때문에 총 세 조각으로 분할된 상황이다.

![](../../images/Pasted%20image%2020251124233359.png)


먼저 **첫 번째 fragment**는 0번 바이트부터 1399번 바이트까지, 총 **1400바이트의 데이터**를 포함한다. 이 조각은 원본 데이터의 맨 처음 부분이므로 시작 위치가 0이다. 따라서 fragmentation offset 값도 **0/8 = 0**이 되어 **offset = 0**이 기록된다.

두 번째 fragment는 **1400번 바이트부터 2799번 바이트까지** 역시 1400바이트의 데이터를 포함한다. 이 조각은 원본 데이터의 1400바이트 지점에서 잘린 것이므로, fragmentation offset에는 _1400 ÷ 8 = 175_가 저장된다. 즉, **offset = 175**이다.

마지막 fragment는 **2800번 바이트부터 3999번 바이트까지**의 데이터를 담고 있다. 이 fragment는 2800바이트 위치에서 시작되므로, fragmentation offset은 _2800 ÷ 8 = 350_이 되어 **offset = 350**로 기록된다.

### 분할은 한번이 아닐 수도 있다!
또 하나 중요한 점은, 데이터 전송이 한 번에 이루어지지 않는다는 것이다. 앞에서 본 3개의 fragment는 반드시 동일한 경로로 이동하지 않으며, 네트워크 상황에 따라 서로 다른 라우터와 다른 네트워크 구간을 통해 목적지로 도착할 수도 있다.

이렇게 경로가 달라지면 각 네트워크 구간마다 **MTU가 서로 다르기 때문에**, 패킷이 전송되는 동안 한 번만 쪼개지는 것이 아니라 **여러 번 추가로 분할(fragmentation)될 수도 있다.** 어떤 구간에서는 1500바이트를 허용해 분할이 3개로 끝나지만, 다음 구간에서는 MTU가 더 작아져 이 조각들이 또다시 더 작은 단위로 여러 번 쪼개질 수도 있다는 의미다.

이러한 다중 fragmentation 상황에서는 앞서 설명한 **Flag 필드(DF, MF)** 의 역할이 더욱 중요해진다. 특히 **MF(More Fragments)** 값이 1이면 아직 뒤에 더 많은 fragment가 존재한다는 뜻이며,여러 단계에 걸쳐 나눠졌더라도 마지막 조각은 **MF = 0**으로 표시되어 최종 fragment임을 알려준다. 수신 측은 이 **Fragmentation Offset**과 **MF 비트** 정보를 활용해, 여러 경로에서 도착하는 다양한 크기의 fragment들을 정확한 순서로 재조립할 수 있게 된다.

### 원래 동일한 datagram 이라는 것을 어떻게 알아낼까?
하나였던 IP 데이터그램이 MTU 때문에 여러 조각(fragment)으로 분리되면, 수신 측에서는 이 조각들이 **원래 어떤 데이터그램에서 나온 것인지**를 반드시 알아야 한다. 그래야 fragment offset을 사용해 조각들을 올바른 순서로 재배치하고, 최종적으로 하나의 완전한 데이터그램으로 복원할 수 있기 때문이다. 하지만 지금까지 등장한 두 가지 정보만으로는 “이 조각들이 서로 같은 데이터그램에서 나온 것인지”를 판단할 수 없다.

이 문제를 해결하는 것이 바로 IP 헤더의 **Identification 필드**다.

Identification 필드는 **16비트 값으로 구성**되어 있고, 송신자가 데이터그램 하나를 보낼 때마다(또는 OS 정책에 따라 일정 기준으로) 고유한 값이 부여된다. 이 값은 해당 데이터그램이 여러 개의 fragment로 나뉘더라도 **모든 fragment가 동일한 Identification 값을 공유하도록** 구성된다.


정리하면, MTU 제한 때문에 하나의 데이터그램을 여러 개로 분리해야 할 때 IP는 세 가지 필드를 이용해 이 문제를 해결한다.

- **Flag 필드**는 현재 데이터그램이 분리된 상태인지, 그리고 더 이어지는 조각이 있는지를 나타낸다. 즉, “분리가 진행 중이다 / 마지막 조각이다”를 알려주는 역할을 한다.
    
- **Fragmentation Offset**은 각 조각이 원래 데이터그램의 어느 위치에서 잘려 나왔는지를 알려준다. 수신 측은 이 값을 통해 조각들의 순서를 유추하고 올바르게 재조립할 수 있다.
    
- **Identification 필드**는 여러 조각이 모두 동일한 원본 데이터그램에서 나온 것임을 식별하는 값이다. 수신 측은 이 ID를 기준으로 fragment들을 같은 그룹으로 묶는다.
    

결국,  **Flag + Fragmentation Offset + Identification** 이 세 가지 정보가 함께 작동해, 분할된 IP 데이터그램을 목적지에서 정확하게 하나로 복원할 수 있게 된다.

---
## Example

##### 1. 패킷이 M 비트가 0으로 도착했다,  이 패킷은 처음 fragment 나중 fragment 혹은 중간 fragment인가?  
패킷의 **M 비트(MF 비트)** 가 0으로 도착했다는 것은, 이 패킷 뒤에 더 이상의 fragment가 없다는 의미다. 따라서 이 패킷은 **마지막 fragment이거나**, 애초에 **분리되지 않은 단일 패킷**일 수 있다. 처음 fragment나 중간 fragment일 가능성은 없다.

##### 2. 패킷 M 비트가 1이라면?
패킷의 **M 비트(MF 비트)** 가 1이라면, 이 패킷은 **마지막 fragment가 아니며**, 뒤에 이어지는 fragment가 더 있다는 뜻이다. 다만 이 값만으로는 이 패킷이 **첫 번째 fragment인지**, 아니면 **중간 fragment인지**는 구별할 수 없다.

##### 3. M 비트가 1이고, fragmentation offset이 0이라면?
**M 비트가 1이고 fragmentation offset이 0이라면**, **M = 1** → 뒤에 더 많은 fragment가 존재한다는 의미이고 **Offset = 0** → 이 fragment가 원래 데이터그램의 **가장 앞부분에서 시작**했다는 뜻이다.

##### 4. offset value가 100이다. first byte와 last byte는 무엇인가? 
offset 값이 **100**이라면, 실제 데이터가 시작되는 위치는 **offset × 8 = 100 × 8 = 800바이트** 지점이다. 즉, 이 fragment는 **원래 데이터그램의 800번째 바이트부터** 시작된 조각이라는 의미다.

offset 값으로는 **시작 위치만 알 수 있을 뿐**, 해당 fragment가 **어디에서 끝나는지(마지막 byte)** 는 알 수 없다. 마지막 byte는 **데이터 길이(total length – header length)** 와 결합해서만 계산할 수 있으므로, offset만으로는 추정이 불가능하다.

##### 5. 패킷이 도착했는데 offset value가 100이다. HLEN이 5다. 그리고 total length는 100이다. first byte와 last byte는 무엇인가?

패킷의 HLEN 값이 5라는 것은 헤더 길이가 20바이트라는 뜻이고, total length가 100이므로 실제 데이터(payload)는 80바이트가 된다. 여기에 offset 값이 100이 주어졌다면, offset은 8바이트 단위로 기록되므로 100 × 8 = 800바이트가 이 fragment의 데이터가 시작되는 위치이다. 따라서 first byte는 원래 데이터그램의 800번째 바이트가 된다. 데이터가 총 80바이트이므로 마지막 위치는 800부터 79바이트를 더한 879가 되고, 결국 last byte는 879번째 바이트가 된다.

---
