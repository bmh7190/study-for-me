네트워크 레이어에서 패킷은 **데이터그램(datagram)** 이라고 부른다. 데이터그램은 _헤더 + 데이터(payload)_ 로 구성되며, 길이가 고정되어 있지 않은 가변 크기 구조를 갖는다. IP 헤더는 **최소 20바이트에서 최대 60바이트까지** 확장될 수 있으며, TCP 헤더와 마찬가지로 라우팅·전달에 필요한 핵심 정보를 담고 있다.

아래 IP 헤더를 기준으로 각 필드를 살펴보자.

![](../../images/Pasted%20image%2020251124224235.png)

먼저, `Version` 필드는 사용 중인 IP 버전을 나타낸다. 현재는 IPv4와 IPv6가 존재하며, 이 값으로 수신 측은 어떤 방식으로 헤더를 해석해야 하는지 판단한다.

그 다음 `Header Length(IHL)` 필드에는 헤더의 실제 길이가 들어간다. IP 헤더 역시 옵션이 포함될 수 있어 가변적이므로, 헤더 길이를 명시해야 한다. TCP와 동일하게, **4바이트 단위로 표현**되기 때문에 송신 시 4로 나누어 저장하고, 수신 시 4를 곱해 실제 바이트 길이를 계산한다.

`Service Type`(혹은 DSCP/ECN)은 패킷의 우선순위나 서비스 품질(QoS)을 지정하는 필드이지만, 실제로는 일반 인터넷 환경에서는 크게 활용되지 않는 편이다.

`Total Length`는 데이터그램 전체 길이(헤더 + 데이터)를 나타내며, 16비트로 구성되어 있다. 이 값으로 수신 측은 데이터가 어디까지인지 판단하고, 패킷 단편화(fragmentation)가 되어 있을 경우 재조립에도 활용된다. 이는 뒤에서 세부적으로 알아보자 

---
## Encapsulation of a small datagram in a Ethernet frame

Ethernet 프레임에는 **데이터(payload)의 최소 길이**가 정해져 있다.  Ethernet의 최소 페이로드 크기는 **46바이트**이며, 이는 프레임 전체가 정상적으로 전송·감지될 수 있도록 하기 위한 규칙이다.

![](../../images/Pasted%20image%2020251124224534.png)

하지만 IP 패킷은 상황에 따라 매우 작을 수 있다.  

예를 들어, IP 헤더: 20 bytes + TCP 헤더: 20 bytes + 실제 데이터: 1 byte 인 경우에 IP 패킷 전체 길이는 41바이트에 불과하다. 이는 Ethernet이 요구하는 최소 페이로드(46바이트)에 미치지 못한다.

그래서 송신 측에서는 Ethernet의 최소 페이로드 길이를 맞추기 위해 **padding(패딩)** 을 추가한다. 앞서 예처럼 IP 패킷 크기가 41바이트라면, 최소 46바이트를 만족하도록 **5바이트의 패딩**을 IP 패킷 뒤에 강제로 덧붙인다.

수신 측은 이러한 패딩이 실제 데이터가 아니라는 것을 알고 있으며, Ethernet 헤더의Length/Type 또는 상위 계층의 **IP Total Length 필드**를 참고해 IP 패킷의 실제 길이까지만 읽는다. 나머지 패딩 바이트는 모두 무시된다.

결과적으로, 송신 측은 Ethernet의 최소 프레임 규격을 맞추기 위해 패딩을 넣고, 수신 측은 IP 헤더에 포함된 Total Length 정보를 기준으로 패딩을 제외한 순수한 데이터만 정확하게 해석한다.

---
## Time to Live
IP 헤더는 TCP처럼 **타이머 기반의 시간값을 직접 포함하지 않는다.** 대신 이를 **hop 카운터** 방식으로 대체한 것이 바로 _TTL(Time to Live)_ 필드이다.

네트워크 계층의 패킷(IP datagram)은 전송 과정에서 여러 개의 라우터를 차례로 거치게 된다. 이러한 전송 방식을 **hop-to-hop 전달**이라고 한다. TTL 필드는 패킷이 라우터를 지날 때마다 **값이 1씩 감소**하며, TTL이 **0이 되는 순간** 패킷은 더 이상 유효하지 않다고 판단되어 해당 라우터에서 **폐기(drop)** 된다.

이 필드가 존재하는 이유는, 라우팅 오류나 루프가 발생했을 때 패킷이 네트워크를 무한정 떠돌지 않도록 하기 위해서다. TTL이 없다면, 잘못된 경로에서 패킷이 계속 라우터 사이를 순환하며 **네트워크 자원을 소모**하고, 장애까지 일으킬 수 있다.

따라서 TTL은 패킷의 "최대 생존 거리"를 정의하는 보호 장치 역할을 한다.


---
## Multiplexing

![](../../images/Pasted%20image%2020251124224748.png)

IP 헤더는 **네트워크 계층**에서 붙는 헤더이다. 그런데 IP 패킷의 상위 계층인 **전송 계층(Transport Layer)** 에서는 TCP, UDP 등 서로 다른 프로토콜을 사용한다. 이 프로토콜들은 각자 **헤더 구조와 데이터 해석 방식이 다르기 때문에**, 수신 측에서 어떤 전송 계층 프로토콜을 사용했는지를 알아야 올바르게 처리할 수 있다.

이 정보를 제공하기 위해 IP 헤더에는 **Protocol 필드(8비트)** 가 존재한다. 여기에는 상위 계층 프로토콜을 식별할 수 있는 번호(TCP = 6, UDP = 17 등)가 들어가며, 이를 통해 IP 패킷을 받은 호스트는 네트워크 계층 이후 어떤 프로토콜로 넘겨야 할지를 정확히 알 수 있다.

즉, 전송 계층 프로토콜마다 데이터 해석 방식이 다르기 때문에,  
IP 헤더에 **Protocol 필드(8비트)** 를 두어 상위 계층 프로토콜 종류를 명시해 주는 것이다.

---
## Example 1

IP 패킷이 도착했을 때, 처음 8비트가 `0100 0010`이라고 하자.  
이때 어떤 일이 발생할까?

IP 헤더의 **앞 4비트(0100)** 는 IP 버전을 뜻하며, 이는 **IPv4**임을 의미한다.  
그 다음 **뒤 4비트(0010)** 는 HLEN(Header Length)이다.  
HLEN 값은 4바이트 단위이므로, 2 × 4 = **8바이트**가 된다.

그러나 IP 헤더의 최소 길이는 **20바이트**이다.  
따라서 HLEN이 8바이트라고 표시된 이 패킷은 **헤더 길이가 비정상인 잘못된 패킷**이며,  
라우터 또는 수신 호스트는 **이 패킷을 폐기(drop)** 한다.

---

## Example 2

IP 패킷에서 HLEN 값이 `1000`일 때, 옵션 필드(option field)는 몇 바이트일까?

`1000`은 2진수로 **8**을 의미한다.  
HLEN은 4바이트 단위이므로 8 × 4 = **32바이트**가 전체 헤더 길이가 된다.

기본 IP 헤더는 20바이트이므로,

- 전체 헤더: 32바이트

- 기본 헤더: 20바이트

→ 옵션(option) 필드는 **12바이트** 포함되어 있음을 알 수 있다.

---

## Example 3

IP 패킷에서 HLEN = `5₁₆`, Total Length = `0028₁₆` 일 때, 포함된 데이터의 길이는?

우선 16진수라는 점을 고려한다.

- HLEN = 5 → 5 × 4 = **20바이트 헤더** → 옵션 없음
    
- Total Length = 0x0028 → 16진수 0x28 = 40 → **40바이트 전체 길이**
    

전체 길이에서 헤더 길이를 빼면,

40바이트 − 20바이트 = **20바이트 데이터(payload)**

또한 Ethernet의 최소 페이로드 크기인 46바이트보다 작기 때문에,  
실제로 전송된 Ethernet 프레임에는 **패딩(padding)** 이 추가되었을 가능성이 높다.

## Example 4
처음 몇 바이트가 `45000028000100000102`인 IP 패킷이 도착했다. 이 패킷은 앞으로 몇 번의 라우터(hop)를 더 지나갈 수 있으며, 이 안에 실린 데이터는 어떤 상위 계층 프로토콜에 속하는가?

16진수로 주어졌기 때문에 2자리씩 끊어서 읽으면 되고, 이 2자리는 1byte에 해당한다.

TTL을 가리키는 필드의 값을 찾아보면 01 을 확인할 수 있고, 이는 1hop 더 갈 수 있다는 것을 의미한다.


---
