ICMP 메시지는 크게 두 가지 범주로 나눌 수 있다. 첫 번째는 오류가 발생했을 때 그 이유를 알려주는 **error reporting messages(오류 보고 메시지)** 이고, 두 번째는 특정 정보를 요청하거나 교환하기 위한 **query messages(질의 메시지)** 이다.

오류 보고 메시지는 라우터나 호스트가 IP 패킷을 처리하던 중 문제를 발견했을 때, 그 원인을 원래 패킷의 송신자에게 알려주는 역할을 한다. 반면 query 메시지는 호스트나 네트워크 관리자가 다른 라우터나 호스트로부터 필요한 정보를 얻기 위해 사용된다. 이를 통해 호스트는 자신의 네트워크 내에서 어떤 라우터가 존재하는지 발견하고 학습할 수 있으며, 라우터는 경우에 따라 특정 노드에게 더 효율적인 경로로 패킷을 보내도록 안내할 수도 있다.

![](../../images/Pasted%20image%2020251126171319.png)

---
## General format of ICMP messages

![](../../images/Pasted%20image%2020251126171648.png)

ICMP 메시지는 위와 같은 형태로 구성되어 있다. 

가장 먼저 포함되는 **Type 필드**는 어떤 종류의 오류나 메시지인지 나타내며, 그 옆의 **Code 필드**는 같은 타입 안에서 더 세부적인 오류 원인을 구분하는 역할을 한다. 

ICMP의 중요한 특징 중 하나는 **항상 원래 패킷의 송신자에게 에러 메시지를 되돌려 보낸다는 점**이다. 예를 들어 A에서 F로 패킷을 보내는 중간에 D 라우터에서 문제가 발생했다면, ICMP 오류 메시지는 F가 아니라 **원본 송신자인 A로 전달**된다. 이를 통해 송신자는 패킷이 도중에 어떤 이유로 실패했는지를 알 수 있게 된다.

![](../../images/Pasted%20image%2020251126174744.png)

ICMP 메시지의 구조를 자세히 보면, 가장 먼저 **원래의 IP 데이터그램 일부가 포함된다는 점**을 알 수 있다. 이 데이터그램의 IP 헤더에는 “어디에서 어디로 가려고 했는지”에 대한 정보가 담겨 있으므로, ICMP 메시지를 만들 때 **오류를 누구에게 전달해야 하는지(원본 송신자)** 를 판단할 수 있게 된다. 여기에 ICMP 헤더를 붙이면 하나의 **ICMP 패킷**, 즉 ICMP 메시지가 완성된다.

이후 이 메시지 앞에는 새로운 **IP 헤더가 다시 붙게 되는데**, 이 IP 헤더에는 ICMP 메시지를 보내는 쪽—즉 **오류가 발생한 라우터 또는 호스트의 주소**가 기록된다. 덕분에 원래 송신자는 “어느 지점에서 문제가 발생했는지”까지 알 수 있게 된다.

또한 원래 데이터그램에서 **IP 헤더를 제외한 8바이트의 데이터 부분도 함께 포함**되는데, 이것은 매우 중요한 역할을 한다. 예를 들어 원래 전송이 TCP였다면, 포함된 8바이트는 TCP 헤더의 앞부분이 되며, 이 안에는 **포트 번호와 시퀀스 번호**가 들어 있다. 포트 번호를 통해 “어떤 애플리케이션으로 가던 패킷이었는지”를 알 수 있고, 시퀀스 번호를 통해 “어떤 패킷이 손실되었는지”도 정확히 파악할 수 있다.

즉 ICMP 메시지는

- 원본 송신자가 누구인지?
    
- 오류 위치가 어디인지?
    
- 어떤 패킷이 사라졌는지?
    
- 어느 애플리케이션이 영향을 받았는지
    

이 모든 정보를 알 수 있도록 **필수적인 헤더 조각들을 포함한 구조**로 만들어진다.


---
## Error Reporting Message

![](../../images/Pasted%20image%2020251126173756.png)


### Destination-unreachable format
ICMP 오류 보고 중 가장 먼저 살펴볼 수 있는 형식이 바로 **Destination Unreachable**이다. 말 그대로, 데이터그램이 목적지까지 도달할 수 없을 때 사용되는 타입이다. ICMP의 Destination Unreachable 메시지는 여러 세부 코드(code)로 구분되며, 각각 어떤 단계에서 문제가 발생했는지를 알려준다.

### 1) 네트워크 도달 불가 (Code 0)

목적지 네트워크까지 가는 경로가 전혀 없을 때 발생한다.  
라우터가 목적지 주소에 대한 라우팅 정보를 찾지 못하면 기본적으로 **디폴트 라우트(default route)** 를 사용하려고 한다. 하지만 디폴트 라우트조차 없다면 더 이상 전달할 수 없으므로 패킷을 폐기하고 송신자에게 ICMP 오류 메시지를 보낸다.

### 2) 호스트 도달 불가 (Code 1)

네트워크에는 도달했지만, **최종 목적지 호스트**에는 도달하지 못한 경우 사용된다.  
이 오류는 일반적으로 목적지 네트워크의 최종 라우터나 목적지 호스트가 직접 생성한다.

### 3) 프로토콜 도달 불가 (Code 2)

목적지 시스템까지 도달했지만, 데이터그램이 사용하려는 **프로토콜(예: TCP/UDP/ICMP 등)** 을 해당 시스템이 지원하지 않는 경우 발생한다.  
즉, 목적지 시스템이 해당 프로토콜을 처리할 수 없음을 송신자에게 알려주는 것이다.

### 4) 포트 도달 불가 (Code 3)

프로토콜도 지원하고 호스트에도 도달했지만, 목적지 호스트 내에서 해당 **포트 번호를 사용하는 프로세스가 없을 때** 발생한다.  
예를 들어, UDP 포트로 패킷을 보냈는데 해당 포트를 열어둔 애플리케이션이 없다면 호스트는 Port Unreachable 메시지를 반환한다.

### 5) 단편화 필요 / DF 비트 설정 (Code 4)

라우터가 패킷을 전달하려고 하는데, 링크의 MTU보다 패킷이 커서 **fragmentation** 가 필요하다.  
그러나 IP 헤더의 DF(Don’t Fragment) 비트가 설정되어 있다면 단편화를 할 수 없으므로 패킷을 폐기하고 송신자에게 이 사실을 통보한다. 

이 오류는 Path MTU Discovery 과정에서도 중요한 역할을 한다.

### 6) 통신이 관리적으로 금지됨 (Code 13)

정책적인 이유로 목적지와의 통신이 금지되어 있는 상황에서 발생한다.  
예를 들어 방화벽이나 보안 장비가 정책 위반 패킷을 차단하는 경우가 대표적이다.  
이 오류 메시지는 보안 정책에 따라 송신자에게 전달될 수도 있고, 그냥 내부적으로 폐기될 수도 있다.

---

2번과 3번 오류는 목적지 호스트가 직접 생성하는 경우이고, 그 외의 코드들은 일반적으로 **중간 라우터**에서 발생한다. 하지만 라우터가 모든 문제를 감지할 수 있는 것은 아니다. 그 이유는 **IP 프로토콜 자체가 단순한 비연결형 서비스**이기 때문이다.

IP는 패킷을 최선을 다해 전달하는 “best-effort” 방식으로 동작하며, 그 과정에서 다음과 같은 기능들이 없다.

- **혼잡 제어(congestion control)**  
    네트워크가 과부하 상태에 빠져도 IP는 속도를 줄이거나 흐름을 조절하는 기능을 제공하지 않는다. 혼잡 때문에 패킷이 손실되는 상황을 라우터가 정확히 “문제”로 인식하는 것도 불가능하다.
    
- **플로우 컨트롤(flow control)**  
    송신자와 수신자 사이의 처리 속도 차이를 조절해 주지 않기 때문에, 목적지 호스트가 패킷을 감당하지 못하는 상황을 라우터가 알아낼 수 없다.

이 때문에 라우터가 파악할 수 있는 오류는 구조적으로 제한적이다.  

예를 들어:

- 경로가 아예 없어서 **forward 자체가 불가능한 경우**
    
- MTU 제한 때문에 **단편화가 필요한데 DF가 켜져 있는 경우**
    
- 보안 정책 때문에 **강제로 차단해야 하는 경우**
    

와 같이 **순수한 라우팅·전달 과정에서 즉시 판별 가능한 문제들만** 라우터가 감지하고 Destination Unreachable 메시지를 생성할 수 있다.

반면, 목적지 호스트에 도달해야만 알 수 있는 문제들(예: 프로토콜 미지원, 포트 미사용)은 라우터가 감지할 수 없기 때문에 결국 목적지 호스트가 직접 ICMP 메시지를 생성하게 된다.

---
## Source quench format

Source Quench 메시지는 네트워크 상에서 **혼잡(congestion)** 이 발생했음을 송신자에게 알려주는 ICMP 메시지이다. 의미는 간단하다.  

“너 지금 너무 빠르게 보내고 있어. 속도를 좀 줄여라!”

이 메시지는 라우터나 목적지 호스트가 혼잡 때문에 데이터그램을 처리하지 못해 **버리게(drop)** 되었을 때 생성된다. 송신자는 이 메시지를 받으면 혼잡이 완화될 때까지 데이터그램 전송 속도를 낮춰야 한다.

다만 오늘날에는 **TCP 자체에 혼잡 제어(congestion control) 알고리즘**이 잘 구현되어 있기 때문에, Source Quench 메시지는 사실상 역할이 사라졌고 실제 네트워크에서도 거의 사용되지 않는다. RFC에서도 폐기된(deprecated) 기능로 분류된다.

라우터 또는 목적지 호스트가 **혼잡으로 인해 패킷을 버릴 때**, 버려진 **각 패킷마다** Source Quench 메시지를 원래 송신자에게 보낸다.  즉, 어떤 데이터그램이 처리 불가 상태로 drop되면 그때마다 “속도 줄여라” 메시지를 따로 보내는 구조이다.

---
## Time exceeded message format

time exceeded 메세지를 보내는 경우는 2가지가 있다. 

라우터는 time to live 값을 하나씩 감소하게 되는데, 이게 0이 되면 datagram은 버리게 되고 원래 source에게 time exceed message를 보내게 된다.

마지막 목적지에서 설정한 시간 안에 나뉜 값들을 모두 받지 못한다면 받은 fragments는 전부 머리고 원래 source에게 tiem exceeded message를 보내게 된다. 

time exceeded message에서 code 0 이 ttl이 0이 된 경우를 나타내고, code가 1이라면 fragmentation 된 packet들이정해진 시간에 다 오지 못 했기 때문에 icmp를 발송한 것이라고 알려준다.

---
## Parameter-problem message format
다음은 데이터그램을 받은 라우터나 목적지의 host에게서 생성되는데, 자신이 받은 데이터그램 안에 내용물이 이상하니까 버릴게! 하고 알려주는 것이다. 

---
## Redirection concept
Redirect는 쉽게 말하면 **“다른 곳으로 보내라”** 라는 의미다.  
라우터가 호스트에게 더 좋은(next hop이 더 최적인) 경로가 있다고 알려줄 때 사용하는 ICMP 메시지이다.

일반적으로 호스트는 **아주 작은 라우팅 테이블**을 가지고 시작한다.  예를 들어, 기본 게이트웨이(디폴트 라우터) 정보만 있는 상황이 흔하다. 그러다 네트워크 안에서 더 효율적인 경로가 발견되면, 이를 **ICMP Redirect 메시지**를 통해 호스트가 스스로 라우팅 테이블을 업데이트할 수 있게 해 준다.

Redirect 메시지는 반드시 **라우터가 같은 로컬 네트워크에 있는 호스트에게만** 보낼 수 있다.  
(라우터 ↔ 라우터 간에 보내는 것이 아니라, 라우터 → 호스트로 보내는 메시지임)

아래 그림을 기준으로 설명해보자.

![](../../images/Pasted%20image%2020251127165136.png)

A host는 목적지 B로 IP 패킷을 전송하려고 한다.  

A의 라우팅 테이블에 따르면, 기본적으로 **R1으로 보내라**고 되어 있어서 A는 패킷을 R1 라우터에게 보낸다.

그런데 그림을 자세히 보면, R1과 같은 네트워크 안에 **R2 라우터도 함께 존재**한다. 그리고 R1은 B로 패킷을 전달하려면 결국 **R2를 통해서** 다른 네트워크로 보내야 한다. 즉 A → R1 → R2 → B 로 가는 경로보다는 A → R2 → B 로 직접 가는 경로가 **더 효율적**인 상황이다.

R1 라우터는 A로부터 패킷을 받는 순간 “A는 이 패킷을 굳이 나에게 먼저 보내고 있네…” 하고 상황을 바로 파악할 수 있다. 그래서 패킷 자체는 정상적으로 R2에게 넘겨주지만, 동시에 A에게 **ICMP Redirect** 메시지를 보낸다.

Redirect 메시지의 의미는 다음과 같다.

> “이 목적지(B)로 가는 최적 경로는 나(R1)가 아니라 R2야. 이제부터 R2를 next hop으로 써라.”

A는 이 메시지를 받아 자신의 라우팅 테이블을 업데이트한다.  
그 후부터는 A는 B로 패킷을 보낼 때 더 이상 R1이 아니라 곧바로 **R2에게 패킷을 전달**하게 된다.

---
## Echo-request and Echo-reply message

**Echo Request 메시지**는 *호스트(host)* 와 _라우터(router)_ 모두가 보낼 수 있다.  
반대로 **Echo Reply 메시지**는 Echo Request를 받은 _호스트나 라우터_가 응답 형태로 전송한다.

이 두 메시지는 **IP 네트워크가 정상적으로 동작하는지 확인하기 위한 진단용 메시지** 로, 네트워크 관리자가 자주 사용한다. 특히 특정 목적지(호스트 또는 라우터)에 도달할 수 있는지 테스트할 때 활용되며, 이 기능이 바로 우리가 익숙한 **ping 명령어**이다.

![](../../images/Pasted%20image%2020251201211813.png)

ping은 다음과 같은 흐름으로 작동한다:

1. 송신자가 **Echo Request**를 전송한다.
    
2. 목적지(호스트 또는 라우터)가 이를 수신한다.
    
3. 정상적으로 도달했다면 **Echo Reply**를 되돌려 보낸다.

즉, _Request → Reply_의 간단한 왕복 구조를 통해  
“이 목적지까지 도달 가능한가?”, “지연 시간은 어느 정도인가?” 등을 확인하는 것이다.

---
## Timestamp-request and Timestamp-reply message

RTT(Round-Trip Time)를 측정할 때는 보통 패킷을 보내고, 상대방이 그 패킷을 **받아서 처리한 뒤**, 다시 응답을 보내고, 그 응답을 **내가 다시 받을 때까지의 전체 시간**을 RTT라고 한다.  

하지만 이 과정에서 _상대방이 패킷을 처리하는 데 걸린 시간_은 RTT에 포함되어 있어 분리해서 알 수 없다.

![](../../images/Pasted%20image%2020251201211927.png)

**Timestamp Request/Reply 메시지**는 바로 이 **처리 시간(processing time)** 을 따로 구분할 수 있도록 설계된 메시지다.

- 송신자는 패킷에 **보낸 시간(Originate Timestamp)** 을 기록해 보낸다.
    
- 수신자는 패킷을 받는 순간의 **Receive Timestamp**, 그리고 응답을 보낼 때의 **Transmit Timestamp**를 기록해 **Timestamp Reply**로 돌려보낸다.


이 세 가지 시간 정보를 비교하면  상대방이 패킷을 처리하는 데 걸린 시간과 전체 RTT에서 처리 시간을 제외한 순수 왕복 이동 시간을 따로 계산할 수 있게 된다.

Timestamp 메시지는 **내 시계와 상대방 시계의 차이**를 계산하는 데도 사용할 수 있다.  
만약 네트워크의 지연 시간이 **편도 지연(one-way delay)** 을 알고 있거나 매우 안정적이라면,  
송신자와 수신자의 시계를 서로 맞추는 용도로도 활용할 수 있다.

다만, 실제 환경에서는 **편도 지연을 정확히 알기가 매우 어렵기 때문에** 시계 동기화 용도로 실질적으로 사용되기는 쉽지 않다.

---
## The Traceroute program operation

IP 헤더에는 **TTL(Time To Live)** 이라는 값이 있다. 이 값은 패킷이 **라우터를 최대 몇 번까지 지나갈 수 있는지**를 의미한다. 패킷이 라우터를 하나 지날 때마다 TTL 값은 **1씩 감소**하고, TTL이 **0이 되는 순간**, 해당 라우터는 그 패킷을 버린 뒤 원래 송신자에게 **ICMP Time Exceeded 메시지**를 보내게 된다. 이 ICMP 메시지 안에는 **TTL이 0이 된 라우터의 주소**가 포함된다.

Traceroute는 바로 이 TTL 메커니즘을 이용한다.

![](../../images/Pasted%20image%2020251201213827.png)

1. 처음에는 TTL=1인 패킷을 목적지로 보낸다.  
    → 첫 번째 라우터에서 TTL=0이 되어 ICMP Time Exceeded 메시지를 송신자에게 돌려보냄  
    → 즉, 1번째 라우터 주소를 알아냄
    
2. 다음은 TTL=2로 패킷을 보낸다.  
    → 두 번째 라우터에서 TTL=0이 됨 → 두 번째 라우터 주소 획득
    
3. 이런 식으로 TTL을 1, 2, 3… 점점 증가시키며 보내  
    최종적으로 목적지까지 가는 **모든 라우터들의 경로를 역순으로 파악**할 수 있게 된다.

이 방식 덕분에 Traceroute는 “내 패킷이 어떤 경로를 통해 목적지까지 가는가?” 를 hop-by-hop으로 보여줄 수 있다.

Traceroute는 **ICMP Time Exceeded 메시지**가 정상적으로 돌아와야만 동작한다. 하지만 많은 기업/기관의 내부 사설망은 **외부에서 들어오는 ICMP 메시지를 차단**한다. 그 결과 중간 라우터가 응답을 주지 않거나 특정 구간이 `* * *` 형태로 표시되거나 전체 traceroute가 실패할 수도 있다. 즉, traceroute는 **네트워크의 정책(ICMP 허용 여부)** 에 따라 결과가 달라질 수 있다.