
---
## **Basic Concepts**

인덱싱 메커니즘은 데이터베이스에서 **원하는 데이터를 빠르게 접근**할 수 있도록 도와주는 구조이다. 예를 들어, 도서관의 **저자 색인(author catalog)** 처럼, 사용자가 특정 속성 값을 기준으로 자료를 빠르게 찾을 수 있도록 한다.

여기서 인덱싱에 사용되는 속성을 **Search Key(검색 키)** 라고 하며, 이는 하나 이상의 속성들로 구성될 수 있다. 즉, 파일 내에서 원하는 레코드를 찾아보기 위한 기준이 되는 속성이다.

**인덱스 파일(index file)** 은 실제 데이터를 저장하는 파일과는 별도로 존재하며, 이 파일은 다음과 같은 형식의 레코드(인덱스 엔트리)를 포함한다:

![](../images/Pasted%20image%2020250529231930.png)

`(Search Key Value, Pointer to Actual Record)`

이러한 인덱스 파일은 **실제 데이터 파일보다 훨씬 크기가 작기 때문에**, 디스크 I/O를 줄이면서 빠른 검색을 가능하게 한다.

인덱스는 크게 **두 가지 기본 유형**으로 나눌 수 있다:

1. **Ordered Indices (정렬 인덱스)**  
    검색 키들이 **정렬된 순서**로 저장되어 있으며, 범위 검색이나 순차 탐색에 유리하다. 일반적으로 B+ Tree 같은 구조가 사용된다.
    
2. **Hash Indices (해시 인덱스)**  
    해시 함수를 이용해 검색 키를 **균등하게 여러 bucket에 분산**시킨다. 특정 값을 **정확하게 찾는 질의(=point query)** 에 매우 빠르지만, 정렬이나 범위 질의에는 적합하지 않다.
    
이러한 인덱스 메커니즘은 데이터 접근 성능을 크게 향상시켜 주며, 쿼리 처리 속도를 좌우하는 핵심 구성 요소 중 하나이다.

---
## **Ordered Indices**

**Ordered index**에서는 인덱스 엔트리들이 **검색 키(search key)** 값에 따라 **정렬된 순서로 저장**된다. 이는 예를 들어 **도서관의 저자 색인(author catalog)** 과 같이 특정 속성을 기준으로 데이터를 빠르게 탐색할 수 있도록 하는 구조이다.

---

##### ✅ Primary Index (기본 인덱스, Clustering Index)

- **Sequentially ordered file**(정렬된 파일)에서, 해당 파일의 **정렬 순서를 결정하는 속성**을 검색 키로 사용하는 인덱스를 **Primary Index**라고 한다.
    
- 예: 학번 순으로 정렬된 학생 레코드 파일에 대해 학번을 검색 키로 만든 인덱스
    
- **Clustering index**라고도 불리며, 이 인덱스는 보통 **검색 키 순서와 파일의 물리적 저장 순서가 일치**한다.
    
- **Primary key**를 사용할 때가 많지만, **반드시 primary key일 필요는 없다.**
    

---

##### ✅ Secondary Index (보조 인덱스, Non-Clustering Index)

- 파일의 정렬 순서와 **무관한 속성**을 검색 키로 사용하는 인덱스는 **Secondary Index**라고 한다.
    
- 예: 학번 순으로 정렬된 학생 파일에서 이름(name)을 기준으로 만든 인덱스
    
- **데이터 파일은 정렬되지 않았고**, 인덱스만 해당 속성 기준으로 정렬됨
    
- 따라서 **하나의 키 값이 여러 레코드와 매칭될 수 있으며**, 레코드들은 흩어져 있다
    

---

##### ✅ Index-Sequential File

- **정렬된 순서의 데이터 파일**과 그 위에 구축된 **Primary Index**가 함께 존재하는 구조
    
- 즉, **정렬된 데이터 파일 + Primary Index** = Index-Sequential File
    
- 이 구조는 범위 질의나 순차 탐색에 매우 효율적이다

---
## **Dense Index Files**
Dense index는 파일 내 **모든 검색 키 값마다** 하나의 인덱스 레코드가 존재하는 인덱스 구조이다.

![](../images/Pasted%20image%2020250530150848.png)

`ept_name`에 대한 **dense index**는 instructor 파일이 `dept_name` 기준으로 정렬되어 있을 때, **동일한 `dept_name`에 해당 레코드를 가리키는 인덱스 엔트리가 존재**하는 구조이다.

![](../images/Pasted%20image%2020250530151237.png)

---
## **Sparse Index Files**

**Sparse index**는 **일부 검색 키 값에 대해서만 인덱스 레코드를 포함하는 구조**이다.  즉, 모든 레코드에 대해 인덱스를 유지하는 **dense index**와 달리, **간격을 두고 선택된 키 값만 인덱싱**한다.

이 방식은 파일이 **검색 키 기준으로 정렬되어 있는 경우**에만 적용 가능하다.  따라서 인덱스 엔트리가 없는 키 값을 찾기 위해서는 다음과 같은 절차를 따른다:

1. **검색 키 값 K보다 작은 값 중에서 가장 큰 인덱스 엔트리**를 찾는다.
    
2. 그 인덱스가 가리키는 레코드에서부터 **파일을 순차적으로 탐색**하여 K를 가진 레코드를 찾는다.

이 방식은 **인덱스 파일의 크기를 줄일 수 있는 장점**이 있지만, 검색 시에는 **일부 순차 탐색 비용**이 추가로 발생할 수 있다.

![](../images/Pasted%20image%2020250530151535.png)

**Sparse index**는 **dense index**에 비해 다음과 같은 장단점이 있다:

> [!note] Compared to dense indices
> - **장점**:
>     
>     - 인덱스 레코드 수가 적기 때문에 **공간을 덜 차지**한다.
>         
>     - 새로운 레코드 삽입이나 삭제 시, 인덱스를 갱신해야 할 일이 적어서 **유지 관리 비용이 낮다.**
>         
> - **단점**:
>     
>     - 모든 검색 키에 대한 인덱스가 존재하지 않기 때문에, **레코드를 찾는 데 dense index보다 느릴 수 있다.**
>         
>     - 검색 시 파일 내에서 **순차 탐색**이 필요한 경우가 많다.

---

##### ✅ 좋은 절충안: **"블록마다 하나의 인덱스 엔트리"를 두는 sparse index**

- 각 인덱스 엔트리가 **파일의 블록 하나를 대표**하며, 그 블록에서 **가장 작은 검색 키 값**을 가진 레코드를 가리킨다.
    
- 검색할 때는 인덱스를 통해 해당 블록의 시작 위치까지만 빠르게 찾아가고, 그 후에는 **해당 블록 내에서만 탐색**하면 되므로 디스크 접근 횟수가 매우 줄어든다.
    
- **공간은 sparse index 수준으로 절약**하면서, **검색 성능은 dense index와 유사**하게 유지할 수 있기 때문이다. 전체 파일을 탐색하는 것이 아니라, **단 한 블록만 순차 탐색**하면 되므로 성능 저하가 크지 않다.

![](../images/Pasted%20image%2020250530151928.png)
---
dense index : O(N/B) block
dense index와 레코드의 수와 항상 같을 필요는 없다! 중복 제거 가능? 
sparse index :  O (N/B<sup>2</sup>) block 
어차피 블록 단위로 접근하기 때문에 블록 당 하나의 레코드를 인덱싱한다면 효과적일 수도?

N data = 20000000
B data = 20 recordes a block 

N data / B data = 1M
B index = 100 entries in a block 

1 M entries = N index
N index / B index = 1000000 / 100 = 10000 inner index blocks 

10000/ 100 outer index blocks 

log(N/B) N/ 2^i = B



---

**Sparse index**는 일반적으로 **블록 단위**로 인덱싱하며, 하나의 인덱스 엔트리가 하나의 **블록 내 최소 검색 키 값**을 대표한다.

총 레코드 수가 N=20,000,000개이고, 한 블록에 들어가는 레코드 수 B<sub>data</sub>=20이라면,  
**전체 블록 수**는:

$$\frac{N}{B_{\text{data}}} = \frac{20,000,000}{20} = 1,000,000 \text{ (데이터 블록)}$$

이제 인덱스 구조를 위계적으로 설계할 수 있다:

##### ✅ 1단계 인덱스 (Level 1)

- 각 인덱스 블록에는 B<sub>index</sub>=100개의 인덱스 엔트리를 저장할 수 있다고 가정
    
- 1,000,000개의 데이터 블록을 인덱싱하려면:
    
$$\frac{1,000,000}{100} = 10,000 \text{ (1단계 인덱스 블록 수)}
$$
---

### ✅ 2단계 인덱스 (Level 2)

- 위의 10,000개 1단계 인덱스 블록들을 인덱싱하기 위해 다시:
    

$$\frac{10,000}{100} = 100 \text{ (2단계 인덱스 블록 수)}$$

---

### ✅ 3단계 인덱스 (최상위 루트)

- 최상위 인덱스 블록은 100개의 2단계 블록을 인덱싱하면 충분하므로, 1개의 블록으로 가능
    

---

### ✅ 정리

- 전체 구조는 **3단계 인덱스 구조**
    
- 블록 단위 접근이 기본이므로, sparse index에서는 **"블록당 하나의 엔트리만 인덱싱"**해도 효과적이다
    
- **총 인덱스 블록 수**:
    
    - Level 1: 10,000
        
    - Level 2: 100
        
    - Level 3 (root): 1
        

따라서, 전체적으로 **로그 계층 구조**를 가지며, 이론적으로 인덱스를 통한 탐색 비용은:

log⁡Bindex(NBdata)\log_{B_{\text{index}}} \left( \frac{N}{B_{\text{data}}} \right)logBindex​​(Bdata​N​)

즉, 위의 예에서는 약 log⁡100(1,000,000)=2\log_{100}(1,000,000) = 2log100​(1,000,000)=2, 즉 **세 번의 블록 접근으로 원하는 레코드에 도달 가능**하다.

---

이것이 바로 B+ Tree나 다단계 인덱스에서 **O(log(N/B))**의 I/O 접근이 가능한 원리이다.



----
## Multilevel Index

what is wrong with multilevel index?

데이터가 변하지 않는다면 효과적이지만, 변하기 때문에 문제가 됨

---
