
---
## **Basic Concepts**

인덱싱 메커니즘은 데이터베이스에서 **원하는 데이터를 빠르게 접근**할 수 있도록 도와주는 구조이다. 예를 들어, 도서관의 **저자 색인(author catalog)** 처럼, 사용자가 특정 속성 값을 기준으로 자료를 빠르게 찾을 수 있도록 한다.

여기서 인덱싱에 사용되는 속성을 **Search Key(검색 키)** 라고 하며, 이는 하나 이상의 속성들로 구성될 수 있다. 즉, 파일 내에서 원하는 레코드를 찾아보기 위한 기준이 되는 속성이다.

**인덱스 파일(index file)** 은 실제 데이터를 저장하는 파일과는 별도로 존재하며, 이 파일은 다음과 같은 형식의 레코드(인덱스 엔트리)를 포함한다:

![](../images/Pasted%20image%2020250529231930.png)

`(Search Key Value, Pointer to Actual Record)`

이러한 인덱스 파일은 **실제 데이터 파일보다 훨씬 크기가 작기 때문에**, 디스크 I/O를 줄이면서 빠른 검색을 가능하게 한다.

인덱스는 크게 **두 가지 기본 유형**으로 나눌 수 있다:

1. **Ordered Indices (정렬 인덱스)**  
    검색 키들이 **정렬된 순서**로 저장되어 있으며, 범위 검색이나 순차 탐색에 유리하다. 일반적으로 B+ Tree 같은 구조가 사용된다.
    
2. **Hash Indices (해시 인덱스)**  
    해시 함수를 이용해 검색 키를 **균등하게 여러 bucket에 분산**시킨다. 특정 값을 **정확하게 찾는 질의(=point query)** 에 매우 빠르지만, 정렬이나 범위 질의에는 적합하지 않다.
    
이러한 인덱스 메커니즘은 데이터 접근 성능을 크게 향상시켜 주며, 쿼리 처리 속도를 좌우하는 핵심 구성 요소 중 하나이다.

---
## **Ordered Indices**

**Ordered index**에서는 인덱스 엔트리들이 **검색 키(search key)** 값에 따라 **정렬된 순서로 저장**된다. 이는 예를 들어 **도서관의 저자 색인(author catalog)** 과 같이 특정 속성을 기준으로 데이터를 빠르게 탐색할 수 있도록 하는 구조이다.

---

##### ✅ Primary Index (기본 인덱스, Clustering Index)

- **Sequentially ordered file**(정렬된 파일)에서, 해당 파일의 **정렬 순서를 결정하는 속성**을 검색 키로 사용하는 인덱스를 **Primary Index**라고 한다.
    
- 예: 학번 순으로 정렬된 학생 레코드 파일에 대해 학번을 검색 키로 만든 인덱스
    
- **Clustering index**라고도 불리며, 이 인덱스는 보통 **검색 키 순서와 파일의 물리적 저장 순서가 일치**한다.
    
- **Primary key**를 사용할 때가 많지만, **반드시 primary key일 필요는 없다.**
    

---

##### ✅ Secondary Index (보조 인덱스, Non-Clustering Index)

- 파일의 정렬 순서와 **무관한 속성**을 검색 키로 사용하는 인덱스는 **Secondary Index**라고 한다.
    
- 예: 학번 순으로 정렬된 학생 파일에서 이름(name)을 기준으로 만든 인덱스
    
- **데이터 파일은 정렬되지 않았고**, 인덱스만 해당 속성 기준으로 정렬됨
    
- 따라서 **하나의 키 값이 여러 레코드와 매칭될 수 있으며**, 레코드들은 흩어져 있다
    

---

##### ✅ Index-Sequential File

- **정렬된 순서의 데이터 파일**과 그 위에 구축된 **Primary Index**가 함께 존재하는 구조
    
- 즉, **정렬된 데이터 파일 + Primary Index** = Index-Sequential File
    
- 이 구조는 범위 질의나 순차 탐색에 매우 효율적이다

---
## **Dense Index Files**
Dense index는 파일 내 **모든 검색 키 값마다** 하나의 인덱스 레코드가 존재하는 인덱스 구조이다.

![](../images/Pasted%20image%2020250530150848.png)

`ept_name`에 대한 **dense index**는 instructor 파일이 `dept_name` 기준으로 정렬되어 있을 때, **동일한 `dept_name`에 해당 레코드를 가리키는 인덱스 엔트리가 존재**하는 구조이다.

![](../images/Pasted%20image%2020250530151237.png)

---
## **Sparse Index Files**

**Sparse index**는 **일부 검색 키 값에 대해서만 인덱스 레코드를 포함하는 구조**이다.  즉, 모든 레코드에 대해 인덱스를 유지하는 **dense index**와 달리, **간격을 두고 선택된 키 값만 인덱싱**한다.

이 방식은 파일이 **검색 키 기준으로 정렬되어 있는 경우**에만 적용 가능하다.  따라서 인덱스 엔트리가 없는 키 값을 찾기 위해서는 다음과 같은 절차를 따른다:

1. **검색 키 값 K보다 작은 값 중에서 가장 큰 인덱스 엔트리**를 찾는다.
    
2. 그 인덱스가 가리키는 레코드에서부터 **파일을 순차적으로 탐색**하여 K를 가진 레코드를 찾는다.

이 방식은 **인덱스 파일의 크기를 줄일 수 있는 장점**이 있지만, 검색 시에는 **일부 순차 탐색 비용**이 추가로 발생할 수 있다.

![](../images/Pasted%20image%2020250530151535.png)

**Sparse index**는 **dense index**에 비해 다음과 같은 장단점이 있다:

> [!note] Compared to dense indices
> - **장점**:
>     
>     - 인덱스 레코드 수가 적기 때문에 **공간을 덜 차지**한다.
>         
>     - 새로운 레코드 삽입이나 삭제 시, 인덱스를 갱신해야 할 일이 적어서 **유지 관리 비용이 낮다.**
>         
> - **단점**:
>     
>     - 모든 검색 키에 대한 인덱스가 존재하지 않기 때문에, **레코드를 찾는 데 dense index보다 느릴 수 있다.**
>         
>     - 검색 시 파일 내에서 **순차 탐색**이 필요한 경우가 많다.

---

##### ✅ 좋은 절충안: **"블록마다 하나의 인덱스 엔트리"를 두는 sparse index**

- 각 인덱스 엔트리가 **파일의 블록 하나를 대표**하며, 그 블록에서 **가장 작은 검색 키 값**을 가진 레코드를 가리킨다.
    
- 검색할 때는 인덱스를 통해 해당 블록의 시작 위치까지만 빠르게 찾아가고, 그 후에는 **해당 블록 내에서만 탐색**하면 되므로 디스크 접근 횟수가 매우 줄어든다.
    
- **공간은 sparse index 수준으로 절약**하면서, **검색 성능은 dense index와 유사**하게 유지할 수 있기 때문이다. 전체 파일을 탐색하는 것이 아니라, **단 한 블록만 순차 탐색**하면 되므로 성능 저하가 크지 않다.

![](../images/Pasted%20image%2020250530151928.png)
---
dense index : O(N/B) block
dense index와 레코드의 수와 항상 같을 필요는 없다! 중복 제거 가능? 
sparse index :  O (N/B<sup>2</sup>) block 
어차피 블록 단위로 접근하기 때문에 블록 당 하나의 레코드를 인덱싱한다면 효과적일 수도?

N data = 20000000
B data = 20 recordes a block 

N data / B data = 1M
B index = 100 entries in a block 

1 M entries = N index
N index / B index = 1000000 / 100 = 10000 inner index blocks 

10000/ 100 outer index blocks 

log(N/B) N/ 2^i = B



---

**Sparse index**는 일반적으로 **블록 단위**로 인덱싱하며, 하나의 인덱스 엔트리가 하나의 **블록 내 최소 검색 키 값**을 대표한다.

총 레코드 수가 N=20,000,000개이고, 한 블록에 들어가는 레코드 수 B<sub>data</sub>=20이라면,  
**전체 블록 수**는:

$$\frac{N}{B_{\text{data}}} = \frac{20,000,000}{20} = 1,000,000 \text{ (데이터 블록)}$$

이제 인덱스 구조를 위계적으로 설계할 수 있다:

##### ✅ 1단계 인덱스 (Level 1)

- 각 인덱스 블록에는 B<sub>index</sub>=100개의 인덱스 엔트리를 저장할 수 있다고 가정
    
- 1,000,000개의 데이터 블록을 인덱싱하려면:
    
$$\frac{1,000,000}{100} = 10,000 \text{ (1단계 인덱스 블록 수)}
$$
---

##### ✅ 2단계 인덱스 (Level 2)

- 위의 10,000개 1단계 인덱스 블록들을 인덱싱하기 위해 다시:
    
$$\frac{10,000}{100} = 100 \text{ (2단계 인덱스 블록 수)}$$

---

##### ✅ 3단계 인덱스 (최상위 루트)

- 최상위 인덱스 블록은 100개의 2단계 블록을 인덱싱하면 충분하므로, 1개의 블록으로 가능
    

---

전체 구조는 **3단계 인덱스 구조** 블록 단위 접근이 기본이므로, sparse index에서는 **"블록당 하나의 엔트리만 인덱싱"** 해도 효과적이다

**총 인덱스 블록 수**:
    
    - Level 1: 10,000
        
    - Level 2: 100
        
    - Level 3 (root): 1
        

따라서, 전체적으로 **로그 계층 구조**를 가지며, 이론적으로 인덱스를 통한 탐색 비용은:

$$log_{B_{\text{index}}} \left( \frac{N}{B_{\text{data}}} \right)
$$
즉, 위의 예에서는 약 log⁡<sub>100</sub>(1,000,000)=2, 즉 **세 번의 블록 접근으로 원하는 레코드에 도달 가능**하다.


----
## **Multilevel Index**

만약 **primary index** 자체가 메인 메모리에 들어가지 못할 정도로 크다면, 이를 디스크에서 접근해야 하므로 성능이 크게 저하될 수 있다.

이 문제를 해결하기 위해, **primary index 자체를 하나의 정렬된 파일(sequential file)** 로 간주하고, 그 위에 **sparse index**를 추가로 구축하는 방식이 사용된다.

![](../images/Pasted%20image%2020250530153351.png)

> [!note] 용어 정리
> - **Inner index**: 디스크에 저장된 **primary index 파일** (search-key 순으로 정렬된 인덱스)
>     
> - **Outer index**: inner index 위에 만들어진 **sparse index** (primary index의 일부만 인덱싱)


이렇게 하면 검색 시 outer index를 먼저 탐색하고, 해당 엔트리가 가리키는 위치부터 inner index를 순차적으로 탐색함으로써 전체 접근 비용을 줄일 수 있다.

만약 **outer index조차도 메모리에 적재할 수 없을 정도로 클 경우**, 또 하나의 상위 인덱스를 만들 수 있다. 이렇게 인덱스를 **계층적(multi-level index)** 으로 구성하면, 탐색 성능은 유지하면서 메모리 요구는 줄일 수 있다.

단, 이러한 계층적 인덱스 구조에서는 **데이터 파일에 삽입 또는 삭제가 발생할 때, 모든 인덱스 레벨에 대한 갱신이 필요**하다. 즉, inner index뿐 아니라 outer index, 그보다 더 상위 레벨 인덱스까지도 **정합성을 유지하도록 동기화되어야 한다.**

---
## **Index Update : Deletion**

만약 삭제된 레코드가 해당 **검색 키 값(search-key value)** 을 가진 **유일한 레코드**였다면, 그 검색 키는 더 이상 파일 내에 존재하지 않게 된다.

따라서, 인덱스의 관점에서도 **그 검색 키에 해당하는 인덱스 엔트리 역시 삭제되어야** 한다.


**단일 수준 인덱스(single-level index)** 에서의 인덱스 항목 삭제 방식은 인덱스의 종류에 따라 다르게 처리된다.

##### ✅ Dense Index의 경우

Dense index는 **모든 레코드의 검색 키 값마다 인덱스 엔트리를 가지므로**,  레코드를 삭제하면 **해당 검색 키 값에 대응하는 인덱스 엔트리도 단순히 삭제**하면 된다.  즉, **파일에서 레코드를 지우는 것과 동일한 방식으로 인덱스에서도 처리**된다.

##### ✅ Sparse Index의 경우

Sparse index는 **일부 검색 키 값만 인덱싱**되기 때문에 삭제 시 좀 더 조심스럽게 처리해야 한다.

만약 인덱스에 해당 검색 키 ***K***의 엔트리가 있다면,  삭제 시 해당 인덱스 엔트리는 **다음 검색 키 값 ***K'*** 으로 **대체**된다.  이때 ***K′*** 는 파일 내에서 ***K*** 다음으로 등장하는 검색 키 값이다.
    
그러나 만약  ***K′*** **에 해당하는 인덱스 엔트리가 이미 존재**한다면,  중복된 인덱스 엔트리를 만들지 않기 위해, **단순히 K의 인덱스 엔트리를 삭제**한다.

---
## **Index Update: Insertion**

**단일 수준 인덱스(single-level index)** 에서의 삽입은 레코드의 **search-key 값을 기반으로 인덱스를 갱신**하는 방식이며, 인덱스 유형에 따라 처리 방식이 다르다.

##### ✅ Dense Index에서의 삽입

- 새로운 레코드를 삽입할 때, 그 레코드의 **search-key 값이 인덱스에 존재하지 않는다면**, **해당 search-key 값과 레코드 위치를 인덱스에 추가**해야 한다.
    
- 이미 존재하는 search-key 값이라면, 별도로 인덱스를 수정할 필요는 없다.  
    (Dense index는 동일한 키 값에 여러 레코드가 있을 수 있음)


##### ✅ Sparse Index에서의 삽입

- Sparse index는 일반적으로 **파일의 블록마다 하나의 인덱스 엔트리**를 갖는다.
    
- 따라서 **기존 블록에 삽입되는 경우에는 인덱스를 수정할 필요가 없다.**
    
- 하지만 **새로운 블록이 생성되는 경우**, 해당 블록에 저장된 레코드들 중 **가장 첫 번째 search-key 값**을 인덱스에 **새로운 엔트리로 추가**해야 한다.

##### ✅ 다단계 인덱스(Multilevel Index)의 삽입 및 삭제

- 다단계 인덱스의 삽입과 삭제는 위에서 설명한 **단일 수준 알고리즘을 계층적으로 적용**하면 된다.
    
- 하위 레벨(예: inner index)에 변동이 생기면, 그로 인해 **상위 레벨(outer index)** 에서도 엔트리의 삽입 또는 삭제가 발생할 수 있으며,
    
- 최종적으로는 **루트 인덱스까지 갱신될 수 있다.**

---
## **Secondary Indices**

종종, 사용자는 **primary index의 검색 키가 아닌 필드에 대해 조건을 만족하는 모든 레코드**를 찾고 싶어 하는 경우가 있다.

예를 들어:

- **예시 1**: `instructor` 릴레이션이 **ID 기준으로 정렬되어 저장되어** 있다고 가정할 때, 우리는 특정 **학과(dept_name)**에 소속된 모든 강사를 찾고 싶을 수 있다. 하지만 `dept_name`은 primary index의 키가 아니므로, ID 순 정렬만으로는 효율적인 검색이 어렵다.
    
- **예시 2**: 비슷하게, 특정 **급여(salary)**를 가진 강사들이나, **특정 급여 범위 내에 속한 강사들**을 찾고자 할 수도 있다. 이 역시 `salary`가 primary search-key가 아닌 이상, 정렬 기반 탐색으로는 비효율적이다.
    

이러한 경우에는 해당 필드(예: `dept_name`, `salary`)를 검색 키로 하는 **secondary index(보조 인덱스)**를 만들어 사용할 수 있다.

**Secondary index**는 기본 파일의 정렬 순서와는 무관하게, 원하는 검색 키에 대한 **별도의 인덱스를 구축**하여 레코드 접근을 빠르게 만들어 준다.  
각 인덱스 엔트리는 해당 **검색 키 값과, 그것에 대응하는 레코드(또는 레코드들의 위치)에 대한 포인터**를 포함한다.

이 방식은 특히 **다양한 질의 조건**을 지원해야 하는 데이터베이스에서 매우 유용하게 사용된다.