
---
## **Basic Concepts**

인덱싱 메커니즘은 데이터베이스에서 **원하는 데이터를 빠르게 접근**할 수 있도록 도와주는 구조이다. 예를 들어, 도서관의 **저자 색인(author catalog)** 처럼, 사용자가 특정 속성 값을 기준으로 자료를 빠르게 찾을 수 있도록 한다.

여기서 인덱싱에 사용되는 속성을 **Search Key(검색 키)** 라고 하며, 이는 하나 이상의 속성들로 구성될 수 있다. 즉, 파일 내에서 원하는 레코드를 찾아보기 위한 기준이 되는 속성이다.

**인덱스 파일(index file)** 은 실제 데이터를 저장하는 파일과는 별도로 존재하며, 이 파일은 다음과 같은 형식의 레코드(인덱스 엔트리)를 포함한다:

![](../images/Pasted%20image%2020250529231930.png)

`(Search Key Value, Pointer to Actual Record)`

이러한 인덱스 파일은 **실제 데이터 파일보다 훨씬 크기가 작기 때문에**, 디스크 I/O를 줄이면서 빠른 검색을 가능하게 한다.

인덱스는 크게 **두 가지 기본 유형**으로 나눌 수 있다:

1. **Ordered Indices (정렬 인덱스)**  
    검색 키들이 **정렬된 순서**로 저장되어 있으며, 범위 검색이나 순차 탐색에 유리하다. 일반적으로 B+ Tree 같은 구조가 사용된다.
    
2. **Hash Indices (해시 인덱스)**  
    해시 함수를 이용해 검색 키를 **균등하게 여러 bucket에 분산**시킨다. 특정 값을 **정확하게 찾는 질의(=point query)** 에 매우 빠르지만, 정렬이나 범위 질의에는 적합하지 않다.
    
이러한 인덱스 메커니즘은 데이터 접근 성능을 크게 향상시켜 주며, 쿼리 처리 속도를 좌우하는 핵심 구성 요소 중 하나이다.

---
## **Index Evaluation Metrics**




---
dense index : O(N/B) block
dense index와 레코드의 수와 항상 같을 필요는 없다! 중복 제거 가능? 
sparse index :  O (N/B<sup>2</sup>) block 
어차피 블록 단위로 접근하기 때문에 블록 당 하나의 레코드를 인덱싱한다면 효과적일 수도?

N data = 20000000
B data = 20 recordes a block 

N data / B data = 1M
B index = 100 entries in a block 

1 M entries = N index
N index / B index = 1000000 / 100 = 10000 inner index blocks 

10000/ 100 outer index blocks 

log(N/B) N/ 2^i = B

----
## Multilevel Index

what is wrong with multilevel index?

데이터가 변하지 않는다면 효과적이지만, 변하기 때문에 문제가 됨

---
