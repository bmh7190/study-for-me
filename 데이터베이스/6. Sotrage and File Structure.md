
storage hierarchy
registers 
cache
main memory 

---
## File Organization

데이터베이스는 여러 개의 파일로 구성되어 있으며, 각 파일은 일련의 레코드들로 이루어져 있다.  레코드는 다시 여러 개의 필드들로 구성된다. 또한, 각 파일은 고정된 크기의 저장 단위인 **블록(block)** 으로 분할되어 저장된다.  블록은 저장 공간의 할당 단위이자, 디스크로부터 데이터를 전송할 때의 전송 단위로 사용된다.  하나의 블록에는 여러 개의 레코드가 저장될 수 있다.

RAM은 word 단위로 저장한다. CPU와 RAM 사이에 데이터가 주고받을 때 word 단위로 움직인다는 것! 그럼 메모리에서 데이터를 가져올 때, 하나 씩 가져오는 것도 가능하지만 비효율적이다. 그렇기 때문에 블록 단위로 데이터를 한꺼번에 가져오는 것! 4096바이트! = 4k

레코드를 파일에 어떻게 조직할 것인지를 고민하기 위해, 다음과 같은 가정을 둔다:

- 하나의 파일에는 하나의 특정 타입의 레코드만 저장된다.
    
- 서로 다른 릴레이션에 대해서는 서로 다른 파일이 사용된다.


> [!note] 레코드의 유형
> - **고정 길이 레코드 (Fixed-length records)**: 각 레코드가 동일한 크기를 가지며, 접근이 빠르고 구현이 간단하다.
> 
>
> - **가변 길이 레코드 (Variable-length records)**: 레코드의 크기가 서로 다르며, 공간을 효율적으로 사용할 수 있지만 구현이 복잡하고 관리가 어렵다.

---
## **Externeal-Memory Model**

#### 외부 메모리(EM, External Memory) 모델과 RAM 모델의 차이

**외부 메모리 모델(EM Model)** 은 **RAM(주 기억장치) 기반 모델**과는 다르다.  따라서 두 모델은 **성능을 측정하는 기준**이 다르다.

**RAM 모델에서는 시간 복잡도(Time Complexity)** 가 기준이 된다.  주로 **기본 연산의 횟수**, 예를 들어 **메모리 접근 횟수** 등을 센다.

**EM 모델에서는 I/O 복잡도(I/O Complexity)** 가 기준이 된다.  → **외부 메모리(디스크 등)로부터 데이터를 읽거나 쓰는 횟수**가 핵심이다.


#### 자주 사용되는 표기

- **N**: 데이터 파일에 있는 전체 레코드 수
    
- **M**: 주 기억 장치에 적재 가능한 레코드 수
    
- **B**: 하나의 블록에 들어갈 수 있는 레코드 수

Linear I/O O(N/B) << O(N)

---
## **Fixed-Length Records**

![](../images/Pasted%20image%2020250501140156.png)

##### 단순한 접근 방식

레코드 접근을 단순화하기 위해, **레코드 i는 바이트 오프셋 `n × (i - 1)`부터 저장**한다고 가정할 수 있다.  여기서 `n`은 각 레코드의 크기이다.

이 방식은 레코드 접근이 매우 간단하다는 장점이 있지만, **레코드가 블록 경계를 넘을 수 있는 문제가 발생**한다.  따라서 일반적으로는 **레코드가 블록 경계를 넘지 않도록 하는 것이 기본 조건**이다.


##### 레코드 삭제
레코드는 디스크에서 직접 삭제할 수 없기 때문에, **삭제 작업은 반드시 메모리에서 수행**한 뒤 **결과를 다시 디스크에 반영**해야 한다.


**단순한 방식 (Naïve way)**:
삭제 대상인 레코드 i를 지우기 위해, 그 이후의 모든 레코드(i+1부터 n까지)를 한 칸씩 앞으로 이동시킨다. 이 작업은 **블록 단위로 데이터를 메모리로 불러오고**, 레코드를 수정한 뒤, **다시 디스크에 저장하는 과정**을 반복하게 된다. 결국 **모든 블록을 메모리에 한 번씩 불러와야 하므로**, **I/O 복잡도는 O(N / B)** 이다.  (N: 전체 레코드 수, B: 블록당 레코드 수)

**개선된 방식 (Improved way)**
삭제할 레코드 i를 **파일의 마지막 레코드(n)로 덮어쓰기** 한다. 즉, 레코드 n만 삭제된 위치로 이동시키면 되므로, **불필요한 복사나 이동이 없음**. 또는, 삭제된 공간을 따로 정리하지 않고 **빈 공간을 연결 리스트 형태로 관리**함으로써, 이후 삽입 시 재사용할 수 있게 한다. 이 방식은 **삭제된 공간이 포함된 블록과 마지막 레코드가 있는 블록, 총 두 개만 메모리에 로드**하면 되므로, **I/O 복잡도는 O(1)** 이다.


----
## **Maintaing Free Lists**

삭제된 레코드들을 효율적으로 관리하기 위해, **파일 헤더에 첫 번째 삭제된 레코드의 주소를 저장**한다.  이 첫 번째 삭제 레코드는 **두 번째 삭제 레코드의 주소를 저장하는 공간**으로 사용되고,  
두 번째는 세 번째의 주소를 저장하는 식으로, **삭제된 레코드들이 연결 리스트 형태로 이어지게 된다**.

이러한 주소 정보는 실질적으로 **포인터처럼 동작**하며, 각 삭제된 레코드의 위치를 "가리키는" 역할을 한다.

더 나아가, **공간 효율성을 높이기 위해**,  삭제된 레코드 안에 있는 **일반 속성(attribute) 저장 공간을 포인터 저장 용도로 재활용**할 수 있다.  즉, **사용 중인 레코드는 포인터를 저장하지 않으며**, **삭제된 레코드만 포인터 정보를 갖게 된다.**

이 방식은 별도의 포인터 공간 없이도 삭제된 공간을 효과적으로 추적하고 재사용할 수 있도록 해준다.

![](../images/Pasted%20image%2020250501143621.png)

삭제된 레코드를 **Free List에 넣을 때는 리스트의 맨 앞(head)에 추가**하는 것이 일반적이다.

그 이유는, **Free List는 단순 연결 리스트** 구조로 관리되며, 삽입과 삭제가 빠른 **스택(LIFO) 구조**처럼 동작하기 때문이다.  즉, 새로 삭제된 레코드는 이전 Free List의 head가 가리키는 주소를 자신의 포인터 필드에 저장하고,  **자신을 새로운 head로 만든다.**



헤더를 포함하는 블록 + 빈 공간이 있는 블록(head가 가리키는 블록)이 있는 2개만 불러오면 돼