
## **Storage Hierarchy**

![](../images/Pasted%20image%2020250528233520.png)

##### **Cache**
Cache는 가장 빠르지만 비용이 높은 저장장치로, 하드웨어에 의해 자동으로 관리되며 휘발성이다. 즉, 전원이 꺼지면 그 안의 데이터는 사라진다. 접근 속도는 매우 빠르며, 수 나노초(10⁻⁹초) 수준으로 처리된다. 주로 CPU 안에 존재하며, 자주 사용되는 데이터를 임시로 저장하는 데 사용된다.

##### **Main memory(RAM)**
그 다음 단계는 메인 메모리, 즉 RAM이다. 메인 메모리 역시 휘발성이며, 전원이 꺼지면 그 안의 데이터는 모두 사라진다. 접근 속도는 캐시에 비해 느리지만 수백 나노초(10⁻⁷초) 수준으로, 여전히 빠른 편이다. 현재 실행 중인 프로그램과 그 데이터가 여기에 저장되며, 운영체제와 사용자 프로세스가 주로 사용하는 공간이다.

##### **Flash Memory**
Flash 메모리는 비휘발성 저장장치로, 전원이 꺼져도 데이터를 보존할 수 있다. 접근 속도는 RAM보다 느리지만, 자기 디스크보다는 빠르다. 보통 접근 시간은 수십에서 수백 마이크로초(10⁻⁴ ~ 10⁻⁵초) 정도이며, SSD, USB 드라이브, 스마트폰 저장장치 등이 이에 해당한다.

자기 디스크, 즉 하드디스크는 비휘발성 저장장치 중 가장 일반적인 형태로, 매우 느린 접근 속도를 가진다. 보통 수 밀리초(10⁻³초)의 접근 시간이 걸리며, 데이터를 사용하기 위해선 디스크로부터 메인 메모리로 데이터를 옮긴 후에야 접근이 가능하다. 저장할 때도 메모리에서 디스크로 다시 기록해야 한다.

---
## File Organization

데이터베이스는 여러 개의 파일로 구성되어 있으며, 각 파일은 일련의 레코드들로 이루어져 있다.  레코드는 다시 여러 개의 필드들로 구성된다. 또한, 각 파일은 고정된 크기의 저장 단위인 **블록(block)** 으로 분할되어 저장된다.  블록은 저장 공간의 할당 단위이자, 디스크로부터 데이터를 전송할 때의 전송 단위로 사용된다.  하나의 블록에는 여러 개의 레코드가 저장될 수 있다.

RAM은 word 단위로 저장한다. CPU와 RAM 사이에 데이터가 주고받을 때 word 단위로 움직인다는 것! 그럼 메모리에서 데이터를 가져올 때, 하나 씩 가져오는 것도 가능하지만 비효율적이다. 그렇기 때문에 블록 단위로 데이터를 한꺼번에 가져오는 것! 4096바이트! = 4KB

레코드를 파일에 어떻게 조직할 것인지를 고민하기 위해, 다음과 같은 가정을 둔다:

- 하나의 파일에는 하나의 특정 타입의 레코드만 저장된다.
    
- 서로 다른 릴레이션에 대해서는 서로 다른 파일이 사용된다.


> [!note] 레코드의 유형
> - **고정 길이 레코드 (Fixed-length records)**: 각 레코드가 동일한 크기를 가지며, 접근이 빠르고 구현이 간단하다.
> 
>
> - **가변 길이 레코드 (Variable-length records)**: 레코드의 크기가 서로 다르며, 공간을 효율적으로 사용할 수 있지만 구현이 복잡하고 관리가 어렵다.

---
## **Externeal-Memory Model**

#### 외부 메모리(EM, External Memory) 모델과 RAM 모델의 차이

**외부 메모리 모델(EM Model)** 은 **RAM(주 기억장치) 기반 모델**과는 다르다.  따라서 두 모델은 **성능을 측정하는 기준**이 다르다.

**RAM 모델에서는 시간 복잡도(Time Complexity)** 가 기준이 된다.  주로 **기본 연산의 횟수**, 예를 들어 **메모리 접근 횟수** 등을 센다.

**EM 모델에서는 I/O 복잡도(I/O Complexity)** 가 기준이 된다.  → **외부 메모리(디스크 등)로부터 데이터를 읽거나 쓰는 횟수**가 핵심이다.

> [!note] 자주 사용되는 표기
> - **N**: 데이터 파일에 있는 전체 레코드 수
>     
> - **M**: 주 기억 장치(Main Memory)에 적재 가능한 레코드 수
>     
> - **B**: 하나의 블록에 들어갈 수 있는 레코드 수
> 

Linear I/O O(N/B) << O(N)

---
## **Fixed-Length Records**

![](../images/Pasted%20image%2020250501140156.png)

##### 1️⃣ 단순한 접근 방식
레코드 접근을 단순화하기 위해, **레코드 i는 바이트 오프셋 `n × (i - 1)`부터 저장**한다고 가정할 수 있다.  여기서 `n`은 각 레코드의 크기이다.

이 방식은 레코드 접근이 매우 간단하다는 장점이 있지만, **레코드가 블록 경계를 넘을 수 있는 문제가 발생**한다.  따라서 일반적으로는 **레코드가 블록 경계를 넘지 않도록 하는 것이 기본 조건**이다.


##### 2️⃣ 레코드 삭제
레코드는 디스크에서 직접 삭제할 수 없기 때문에, **삭제 작업은 반드시 메모리에서 수행**한 뒤 **결과를 다시 디스크에 반영**해야 한다.

**단순한 방식 (Naïve way)**:
삭제 대상인 레코드 i를 지우기 위해, 그 이후의 모든 레코드(i+1부터 n까지)를 한 칸씩 앞으로 이동시킨다. 이 작업은 **블록 단위로 데이터를 메모리로 불러오고**, 레코드를 수정한 뒤, **다시 디스크에 저장하는 과정**을 반복하게 된다. 결국 **모든 블록을 메모리에 한 번씩 불러와야 하므로**, **I/O 복잡도는 O(N / B)** 이다.  (N: 전체 레코드 수, B: 블록당 레코드 수)

**개선된 방식 (Improved way)**
삭제할 레코드 i를 **파일의 마지막 레코드(n)로 덮어쓰기** 한다. 즉, 레코드 n만 삭제된 위치로 이동시키면 되므로, **불필요한 복사나 이동이 없음**. 또는, 삭제된 공간을 따로 정리하지 않고 **빈 공간을 연결 리스트 형태로 관리**함으로써, 이후 삽입 시 재사용할 수 있게 한다. 이 방식은 **삭제된 공간이 포함된 블록과 마지막 레코드가 있는 블록, 총 두 개만 메모리에 로드**하면 되므로, **I/O 복잡도는 O(1)** 이다.

![](../images/Pasted%20image%2020250528234703.png)

----
## **Maintaing Free Lists**

삭제된 레코드들을 효율적으로 관리하기 위해, **파일 헤더에 첫 번째 삭제된 레코드의 주소를 저장**한다.  이 첫 번째 삭제 레코드는 **두 번째 삭제 레코드의 주소를 저장하는 공간**으로 사용되고,  
두 번째는 세 번째의 주소를 저장하는 식으로, **삭제된 레코드들이 연결 리스트 형태로 이어지게 된다**.

이러한 주소 정보는 실질적으로 **포인터처럼 동작**하며, 각 삭제된 레코드의 위치를 "가리키는" 역할을 한다.

더 나아가, **공간 효율성을 높이기 위해**,  삭제된 레코드 안에 있는 **일반 속성(attribute) 저장 공간을 포인터 저장 용도로 재활용**할 수 있다.  즉, **사용 중인 레코드는 포인터를 저장하지 않으며**, **삭제된 레코드만 포인터 정보를 갖게 된다.**

이 방식은 별도의 포인터 공간 없이도 삭제된 공간을 효과적으로 추적하고 재사용할 수 있도록 해준다.

![](../images/Pasted%20image%2020250501143621.png)

삭제된 레코드를 **Free List에 넣을 때는 보통 리스트의 맨 앞(head)에 추가**하는 것이 일반적이다. 이는 Free List가 **단순 연결 리스트(Singly Linked List)** 로 구성되며, 주로 **스택(LIFO)** 처럼 동작하기 때문이다.

구체적으로 말하자면, 새롭게 삭제된 레코드는 현재 Free List의 head가 가리키고 있는 블록의 주소를 **자신의 포인터 필드에 저장**하고, 그 후 **자신을 새로운 head로 설정**한다. 이렇게 하면 삽입 연산은 포인터 변경 두 번으로 처리되기 때문에 매우 빠르다.

이 구조의 장점은 삭제된 레코드를 다시 재활용할 때도 **최근에 삭제된 것부터 빠르게 접근**할 수 있다는 점이다. 또한 실제로 필요한 메모리 블록은 **헤더 블록**과, head가 가리키는 **하나의 빈 블록**만 있으면 되므로, 디스크 접근 비용도 최소화된다.

단점은 최악의 경우 특정 위치의 레코드를 탐색해야 한다면 **O(n)**의 시간이 걸릴 수 있다는 점이다. 하지만 일반적으로 삽입과 삭제만 빈번하게 일어나는 구조에서는 매우 효율적이다.

---
## **Variable-Length Records**

Variable-length records, 가변 길이 레코드는 데이터베이스 시스템에서 여러 방식으로 필요된다.

첫째, 하나의 파일에 여러 **다른 유형의 레코드 타입(record types)** 을 저장하는 경우가 있다. 이때 각 레코드의 구조나 필드 수가 다르기 때문에, 레코드의 길이도 고정될 수 없다.

둘째, **문자열 필드(varchar 등)** 처럼 특정 필드의 길이가 가변적인 경우이다. 사용자가 입력한 데이터의 길이에 따라 레코드 전체의 크기가 달라진다.

셋째, **반복 가능한 필드(array, multiset 등)** 를 포함한 레코드 타입에서는 동일한 필드를 여러 번 포함할 수 있기 때문에, 반복 횟수에 따라 레코드의 크기가 달라질 수밖에 없다.

이러한 이유들로 인해 고정 길이 방식으로는 표현하기 어려운 유연한 데이터 구조를 처리하기 위해 가변 길이 레코드가 필요하게 된다.

![](../images/Pasted%20image%2020250528235212.png)

---
##### 어떻게 하면 가변 길이 레코드를 나타낼 수 있을까?

가변 길이 레코드는 일반적으로 두 부분으로 구성된다. 첫 번째는 **고정 길이 속성들(fixed-length attributes)** 이 저장되는 **초기 부분(initial part)** 이고, 두 번째는 **가변 길이 속성(variable-length attributes)** 의 실제 데이터가 저장되는 영역이다.

가변 길이 속성은 직접 값을 저장하는 대신, **(offset, length)** 형태의 고정 크기 메타데이터로 표현된다. 이 메타데이터는 해당 속성의 **데이터가 실제로 어디(offset)에 있으며, 얼마나 긴지(length)** 를 나타낸다. 이 정보는 고정 길이 속성 영역 바로 뒤에 있는 **가변 길이 데이터 영역**을 참조하게 된다.

또한, 필드에 **NULL 값**이 들어갈 수 있으므로, 이를 효율적으로 표현하기 위해 **null-value bitmap**을 사용한다. 이 비트맵은 각 필드가 null인지 아닌지를 비트 단위로 표시하여, NULL 여부를 빠르게 판단할 수 있도록 한다.

![](../images/Pasted%20image%2020250528235614.png)

|위치(Bytes)|내용|의미|
|---|---|---|
|0–3|`21, 5`|첫 번째 가변 길이 필드의 **offset = 21**, **length = 5** (즉, 21~25 위치에 데이터)|
|4–7|`26, 10`|두 번째 가변 길이 필드의 **offset = 26**, **length = 10** (즉, 26~35 위치에 데이터)|
|8–11|`36, 10`|세 번째 가변 길이 필드의 **offset = 36**, **length = 10** (즉, 36~45 위치에 데이터)|
|12–19|`65000` (예: 정수)|고정 길이 필드 (예: salary 같은 정수형 필드)|
|20|`0000`|**Null bitmap** (1 byte): 4개의 필드가 모두 non-null임을 나타냄|
|21–25|`10101`|첫 번째 variable-length 필드의 실제 값|
|26–35|`Srinivasan`|두 번째 variable-length 필드의 실제 값|
|36–45|`Comp. Sci.`|세 번째 variable-length 필드의 실제 값|

---
## **Variable-Length Records: Slotted Page Structure**

##### 어떻게 하나의 blcok에 여러 개의 가변 길이 레코드들을 저장할까? 

**Slotted page 구조**는 데이터베이스 시스템에서 variable-length record를 효과적으로 저장하고 관리하기 위한 방식이다. 이 구조에서 **페이지 헤더(slotted page header)** 는 다음과 같은 정보를 포함한다:

![](../images/Pasted%20image%2020250529000750.png)


> [!note] Slotted Page header(Block Header)
> - **Entry** : 현재 페이지 내에 저장된 **레코드의 개수**
>     
> - 페이지 내 **빈 공간의 끝 위치** (즉, free space가 어디까지인지)
>     
> - 각 레코드에 대한 **슬롯(slot)**이 이어지고, 레코드의 **위치(offset)**와 **크기(size)**에 대한 정보가 슬롯에 저장.


> [!note] Free Space
> 헤더와 레코드 사이에 위치한 공간으로 새로운 레코드가 들어오면 이 공간에 삽입된다. 이 구조의 핵심은 **레코드들을 페이지 내에서 자유롭게 이동시킬 수 있다는 점**이다. 예를 들어 레코드를 삭제하거나 삽입하면서 중간에 빈 공간이 생기면, 레코드들을 앞쪽으로 당겨서 **빈 공간을 없애고 연속된 상태로 정리(compact)** 할 수 있다. 단, 레코드가 이동될 경우 해당 레코드의 **헤더 엔트리**도 함께 갱신되어야 한다.

Records는 실제 데이터가 저장되는 부분으로 페이지 끝 쪽에서부터 거꾸로 채워진다. 
또한 중요한 설계 원칙으로, **포인터는 레코드를 직접 가리키지 않아야 한다.** 대신, 포인터는 **슬롯(slotted header entry)** 를 가리키고, 이 슬롯이 레코드의 실제 위치를 참조하게 해야 한다. 이렇게 하면 레코드가 이동해도 **포인터는 변경할 필요 없이 슬롯 정보만 업데이트**하면 되므로, 유지 보수가 훨씬 간편하고 안전하다.

---
Variable -Length Records: Slotted Page Structure

