
storage hierarchy
registers 
cache
main memory 

---
## File Organization

데이터베이스는 여러 개의 파일로 구성되어 있으며, 각 파일은 일련의 레코드들로 이루어져 있다.  레코드는 다시 여러 개의 필드들로 구성된다. 또한, 각 파일은 고정된 크기의 저장 단위인 **블록(block)** 으로 분할되어 저장된다.  블록은 저장 공간의 할당 단위이자, 디스크로부터 데이터를 전송할 때의 전송 단위로 사용된다.  하나의 블록에는 여러 개의 레코드가 저장될 수 있다.

RAM은 word 단위로 저장한다. CPU와 RAM 사이에 데이터가 주고받을 때 word 단위로 움직인다는 것! 그럼 메모리에서 데이터를 가져올 때, 하나 씩 가져오는 것도 가능하지만 비효율적이다. 그렇기 때문에 블록 단위로 데이터를 한꺼번에 가져오는 것! 4096바이트! = 4k

레코드를 파일에 어떻게 조직할 것인지를 고민하기 위해, 다음과 같은 가정을 둔다:

- 하나의 파일에는 하나의 특정 타입의 레코드만 저장된다.
    
- 서로 다른 릴레이션에 대해서는 서로 다른 파일이 사용된다.


> [!note] 레코드의 유형
> - **고정 길이 레코드 (Fixed-length records)**: 각 레코드가 동일한 크기를 가지며, 접근이 빠르고 구현이 간단하다.
> 
>
> - **가변 길이 레코드 (Variable-length records)**: 레코드의 크기가 서로 다르며, 공간을 효율적으로 사용할 수 있지만 구현이 복잡하고 관리가 어렵다.

---
## **Externeal-Memory Model**

##### 외부 메모리(EM, External Memory) 모델과 RAM 모델의 차이

**외부 메모리 모델(EM Model)** 은 **RAM(주 기억장치) 기반 모델**과는 다르다.  따라서 두 모델은 **성능을 측정하는 기준**이 다르다.

**RAM 모델에서는 시간 복잡도(Time Complexity)** 가 기준이 된다.  주로 **기본 연산의 횟수**, 예를 들어 **메모리 접근 횟수** 등을 센다.

**EM 모델에서는 I/O 복잡도(I/O Complexity)** 가 기준이 된다.  → **외부 메모리(디스크 등)로부터 데이터를 읽거나 쓰는 횟수**가 핵심이다.


### 자주 사용되는 표기

- **N**: 데이터 파일에 있는 전체 레코드 수
    
- **M**: 주기억장치에 적재 가능한 레코드 수
    
- **B**: 하나의 블록에 들어갈 수 있는 레코드 수

---
## **Fixed-Length Records**

![](../images/Pasted%20image%2020250501140156.png)

##### 단순한 접근 방식

레코드 접근을 단순화하기 위해, **레코드 i는 바이트 오프셋 `n × (i - 1)`부터 저장**한다고 가정할 수 있다.  여기서 `n`은 각 레코드의 크기이다.

이 방식은 레코드 접근이 매우 간단하다는 장점이 있지만, **레코드가 블록 경계를 넘을 수 있는 문제가 발생**한다.  따라서 일반적으로는 **레코드가 블록 경계를 넘지 않도록 하는 것이 기본 조건**이다.

##### 레코드 삭제

**단순한 방식 (Naïve way)**:
레코드 i 이후의 모든 레코드(i+1부터 n까지)를 한 칸씩 앞당겨 이동시킨다.  
→ 비효율적이고 비용이 큼.
    
**개선된 방식 (Improved way)**
레코드 i에 **마지막 레코드 n을 복사**하여 덮는다.  
→ 삭제 연산을 단 한 번의 복사로 해결 가능.

삭제된 레코드를 별도로 이동시키지 않고, **빈 공간(Free slot)들을 연결 리스트 형태로 관리**한다. → 삭제된 공간을 나중에 재활용할 수 있도록 구성.

----
