어떤게 좋은 Realational Design 인가?
좋은 Realtional Design은 Normal Form을 가진다! 

1 NF : 관계형 모델에서 어떤 속성의 값이던지 atomic해야 한다. 
2 NF
3 NF
BC NF 

밑 단계로 갈 수록 제약 조건이 많아진다. 
위 단계를 만족한 상태이다.
less redundant

---
## **Combine Schemas?**

중복이 야기하는 2가지 문제점
![](../images/Pasted%20image%2020250415141545.png)

inconsitency
**같은 정보가 여러 곳에 저장**되어 있을 때, **하나만 수정되면 다른 값들과 불일치**가 발생할 수 있다.
예: `department_name = 'Biology'`에 대해 `building`이 'Watson'일 수도, 'Newton'일 수도 있는 상황.

inefficiency
**같은 정보를 반복 저장**함으로써 **저장 공간 낭비**가 발생한다.
데이터 갱신 시 **여러 튜플을 동시에 수정해야** 하므로 **처리 비용 증가**.


department_name 이 정해지면 building 과 budget에 의해 정해진다.  이것도 문제다.

---
## **What About Smaller Schemas?**

예를 들어, 우리가 처음부터 `big_instructor`라는 스키마로 시작했다고 가정해보자.  그렇다면 어떻게 이를 `instructor`와 `department`로 **분해(decompose)** 해야 한다는 것을 알 수 있을까?

##### **함수 종속성(Functional Dependency)을 이용한 분해 판단**

다음과 같은 규칙을 생각해볼 수 있다:

> **“만약 (dept_name, building, budget)이라는 스키마가 존재한다면, `dept_name`은 후보 키(candidate key)가 되어야 한다.”**

이 의미를 함수 종속성으로 표현하면 다음과 같다:

`dept_name → building, budget`  

이 종속성은 **하나의 학과 이름(`dept_name`)에 대해 건물(`building`)과 예산(`budget`)이 결정됨**을 의미한다.  하지만 `big_instructor`에서는 `dept_name`이 **후보 키가 아니기 때문에**,  하나의 학과에 대해 **building과 budget 정보가 반복해서 저장될 수 있다.**

이러한 중복은 **정규화(normalization)** 가 필요함을 의미하며,  따라서 `big_instructor`는 다음과 같이 **두 개의 릴레이션으로 분해**하는 것이 바람직하다:

- `instructor(ID, name, salary, dept_name)`
    
- `department(dept_name, building, budget)`

##### 분해가 항상 바람직한 것은 아니다.
모든 분해가 정당한 것은 아니다. 예를 들어, 다음과 같이 잘못 분해하면 문제가 발생한다:

```sql
employee(ID, name, street, city, salary)
→ employee1(ID, name)
→ employee2(name, street, city, salary)
```

이 경우, name은 유일한 속성이 아니기 때문에, employee1과 employee2를 조인할 때 잘못된 데이터가 결합되거나 손실될 수 있다.


---
## **A Lossy Decomposition**

정보가 손실된다는 것은,  **원래의 `employee` 릴레이션을 정확하게 복원할 수 없다는 것**을 의미한다.  이러한 경우, 해당 분해는 **정보 손실 분해(lossy decomposition)** 라고 한다.

즉, 잘못 분해된 결과는 **원래 릴레이션과 동일한 정보를 담지 못하고**,  **불필요한 튜플이 생기거나, 일부 정보가 사라지는 문제**를 유발할 수 있다.

![](../images/Pasted%20image%2020250415142447.png)

---
## **Example of Lossless-Join Decomposition**

![](../images/Pasted%20image%2020250415193802.png)

릴레이션을 분해할 때,  **공통 속성 중 적어도 하나는 어느 한 릴레이션에서 기본 키 역할을 해야** 원래 릴레이션을 정확히 복원할 수 있다. 그렇지 않으면, **Lossy Decomposition (정보 손실 분해)** 이 발생할 수 있다.


---
## **First Normal Form**

어떤 관계 스키마 `R`이 **제1정규형(1NF)** 에 속한다는 것은, `R`의 모든 속성이 **원자적인 도메인**을 가져야 함을 의미한다. 여기서 **도메인이 원자적(atomic)** 이라는 말은, 해당 도메인의 각 값이 **더 이상 나눌 수 없는 단위**로 간주된다는 뜻이다.

만약 값이 원자적이지 않다면, 즉 하나의 속성 값이 여러 개의 값을 포함하고 있다면, 데이터를 **저장하거나 검색하기가 복잡**해지고,**중복된 정보가 저장**될 가능성이 높아진다.

> [!example]
> 각각의 손님에 대해서 여러 개의 계좌 목록을 저장하고, 각각의 계좌에는 여러 명의 소유자가 저장된다고 해보자. 이 경우 한 속성 안에 리스트나 집합처럼 다수의 값이 포함되면 이는 더 이상 원자적이지 않다. 따라서 제1정규형을 만족하려면, 이러한 복합 정보를 별도의 관계,테이블로 분리하고, 각 속성에는 **단 하나의 원자값만** 저장되도록 해야 한다.


##### 원자성은 **도메인이 실제로 어떻게 사용되는지**에 따라 결정된다.

예를 들어, 문자열(string)은 일반적으로 더 이상 나눌 수 없는 원자값으로 간주된다. 그런데 학생들이 CS0012나 EE1127 같은 형태의 '역할 번호(Role ID)'를 부여받았다고 가정해 보자. 만약 이 문자열에서 앞의 두 문자를 떼어내 학과 정보를 알아내려 한다면, 사실상 이 '역할 번호'라는 도메인은 원자적이지 않은 셈이 된다.

이처럼 하나의 도메인 안에 여러 의미가 ‘인코딩’되어 있으면 관리가 복잡해지고, 데이터베이스 설계에서도 바람직하지 않다. 즉, 도메인이 원자적인지 여부는 단순히 데이터 형태(문자열인지, 숫자인지 등)가 아니라 **그 값을 실제로 어떻게 활용하는지**에 달려 있음을 유념해야 한다.

---
## **Goal - Devise a Theory for the Following**

릴레이션이 **좋은 형태**라는 것은, 일반적으로 적절한 **정규형(normal form)** 을 만족하는지를 의미한다.

- 어떤 릴레이션 `R`이 **좋은 형태(good form)** 인지 판단한다.  
- 만약 릴레이션 `R`이 좋은 형태가 아니라면, `R`을 `R1`, `R2`, ..., `Rn`과 같은 릴레이션들의 집합으로 **분해(decomposition)** 한다.  
- 이때, 각 릴레이션은 **좋은 형태**를 만족해야 하며, 이 분해는 반드시 **손실 없는 조인 분해(lossless join decomposition)** 가 되어야 한다.

우리가 사용하는 이 이론은 **함수적 종속성(functional dependencies)** 에 기반한다.

---
## **Functional Dependencies**

**합법적인 릴레이션들의 집합에 대한 제약 조건**은  
특정 속성 집합의 값이 **다른 속성 집합의 값을 유일하게 결정해야 함**을 요구한다.

이러한 개념을 **함수 종속성(Functional Dependency)** 이라고 하며,  **키(key)** 도 이런 규칙의 특별한 경우이다.  예를 들어, **학번이 이름을 정한다** 같은 것도 함수 종속성이고, **학번이 모든 정보를 정한다**면 그건 키가 된다.

---

릴레이션 스키마 `R`이 있다고 하자.  

`α ⊆ R`이고 `β ⊆ R`일 때,  
>α와 β는 R의 속성들 중 일부를 선택한 집합이다.

**함수 종속성** `α → β`가 `R`에서 **성립한다**는 것은 다음과 같은 의미이다.

> 모든 합법적인 릴레이션 인스턴스 `r(R)`에 대해,  
> 어떤 두 튜플 `t₁`과 `t₂`가 `α` 속성들에 대해 동일한 값을 가진다면,  
> `β` 속성들에 대해서도 반드시 동일한 값을 가져야 한다.

즉 `α`에 해당하는 속성들이 `β`를 결정한다!

```
t₁[α] = t₂[α] ⇒ t₁[β] = t₂[β]
```


릴레이션 `r(A, B)`의 한 인스턴스가 다음과 같다고 하자.  

![](../images/Pasted%20image%2020250416102614.png)

이 경우, **`A → B`는 성립하지 않지만**,  **`B → A`는 성립한다.**
A의 값이 같아도 B는 4와 5로 값이 다르다. 그래서 `A → B` 은 성립하지 않는다.
하지만 B는 중복되지 않고, 유일한 A 값과 연결되므로 **`B → A`는 성립한다.** 라고 할 수 있다. 

---

`K → R`을 만족한다는 것은,  속성 집합 `K`만으로 릴레이션 `R`에 있는 **모든 튜플을 유일하게 식별할 수 있다**는 뜻이다.  즉, `K`는 **슈퍼키(Superkey)** 가 된다.

그런데 `K`의 **어떤 진부분집합 α ⊂ K**에 대해서도 `α → R`이 **성립하지 않는다면**,  
즉, `K`보다 더 작은 집합으로는 `R`의 튜플들을 식별할 수 없다면,  
`K`는 **최소한의 속성으로 이루어진 슈퍼키**, 즉 **후보키(Candidate Key)** 라고 한다.

---

**함수 종속성(Functional Dependency)** 은  
**슈퍼키(Superkey)** 만으로는 표현할 수 없는 **제약 조건**들을 표현할 수 있게 해준다.

예를 들어 다음과 같은 스키마가 있다고 하자:

```
big_instructor(ID, name, salary, dept_name, building, budget)
```

이 스키마에서는 다음과 같은 **함수 종속성**이 **성립할 것으로 기대된다**.

- `dept_name → building`  
    (같은 학과는 항상 같은 건물에 있을 것이다.)
    
- `ID → building`  
    (ID는 유일하므로, 하나의 건물에만 해당된다.)
    

그러나 다음과 같은 종속성은 **성립하지 않을 것으로 기대된다**:

- `dept_name → salary`  
    (같은 학과라고 해서 모두 급여가 같은 것은 아니므로, 성립하지 않는다.)
    

---

## **Use of functional Dependencies**

우리는 **함수 종속성(Functional Dependency)** 을 다음과 같은 방식으로 사용한다.

어떤 **릴레이션이 주어진 함수 종속성 집합 `F`를 만족하는지** 검사한다.
- 만약 릴레이션 `r`이 `F` 아래에서 **타당(valid)** 하다면, 우리는 **`r`이 `F`를 만족한다**고 말한다.
    
합법적인 릴레이션의 집합에 제약 조건을 부여한다.

> 함수 종속성 집합 `F`가 스키마 `R`에서 **성립한다(holds on `R`)** 는 것은,  
> **`R` 위의 모든 합법적인 릴레이션 인스턴스들이 `F`를 만족한다**는 의미이다.

함수적 종속성 집합이란 릴레이션에 대한 여러 개의 함수적 종속성들을 모아둔 것들을 말한다. 
  
> [!example]
> 어떤 릴레이션 스키마 `R(ID, name, dept_name, building)`이 있다고 하자.
> 
> 그리고 우리가 알고 있는 함수 종속성이 다음과 같다면:
> 
> - `ID → name`
>     
> - `ID → dept_name`
>     
> - `dept_name → building`
>     
> 
> 이걸 모아서 정의한 게 함수적 종속성 집합 `F`다.
>` F = { ID → name, ID → dept_name, dept_name → building }`

##### 함수 종속성의 우연성

릴레이션 스키마의 **특정 인스턴스**는,  비록 어떤 **함수 종속성이 해당 스키마의 모든 합법적인 인스턴스에 대해 반드시 성립하지 않더라도**,  **우연히 그 함수 종속성을 만족할 수 있다.**

즉, 어떤 함수적 종속성이 **항상 성립해야 한다면** 그것은 **제약 조건**이지만,  
**일시적으로 특정 인스턴스에서만 성립한다면**, 그것은 **우연히 맞아떨어진 것**일 뿐이다.


> [!example]
> `name → ID`
> 
> **이름으로 모든 ID를 찾을 수 있을 것처럼 보일 수 있다.**  왜냐하면 대부분의 경우 이름이 서로 다르기 때문이다.  그래서 `name → ID`라는 함수적 종속성이 **성립하는 것처럼 보일 수 있다.**
> 
> 하지만 **이름이 같은 경우도 충분히 존재할 수 있다.**  이럴 땐 같은 `name`에 대해 서로 다른 `ID`가 나타날 수 있으므로,  사실상 이 함수적 종속성은 **항상 성립하는 제약 조건은 아니다.**
> 
> 즉, `name → ID`가 어떤 인스턴스에서는 **우연히 만족할 수는 있지만**,  
> 그렇다고 해서 이 종속성이 **릴레이션 스키마 전체에서 항상 성립한다고 볼 수는 없다.**

##### Trivail Functional Dependencies
종속되는 속성(결정되는 값)이 이미 결정하는 속성 집합에 포함되어 있다면, 그건 특별한 제약이 아니라 **당연한 관계**다!


> [!example]
> - `ID, name → ID`
>     
> - `name → name`
>     
> 
> 이런 경우는 **항상** 성립한다. 왜냐하면 오른쪽(`β`)이 왼쪽(`α`)에 **이미 포함되어 있기 때문**이다.

> 함수 종속성 `α → β`는 **β ⊆ α**일 때 **자명하다(trivial)** 고 한다.

---
## **Closure of Functional Dependencies**

**함수 종속성 집합 `F`** 가 주어졌을 때,  이 `F`로부터 **유도될 수 있는 다른 함수 종속성들**이 있을 수 있다.


- 만약 `A → B`이고, `B → C`라면, 우리는 **`A → C`** 를 **유도**할 수 있다.  


이처럼 `F`로부터 **논리적으로 유도될 수 있는 모든 함수 종속성들의 집합**을  우리는 **`F`의 폐쇄(closure)** 라고 부른다.

- `F`의 폐쇄는 `F⁺`로 표기하며,`F⁺`는 `F`의 **상위 집합(superset)** 이다.  

즉, `F`에 있는 종속성은 당연히 포함되고, 그로부터 **추론 가능한 모든 종속성들**도 포함된다.)

a -> r
ar -> rr->r
ar->a
ar->ra

---
## **Boyce-Codd Normal Form**

릴레이션 스키마 `R`이 **함수 종속성 집합 `F`에 대해 BCNF**(Boyce-Codd Normal Form)를 만족하려면,  `F⁺`에 포함된 **모든 함수적 종속성** `α → β`에 대해 다음 조건 중 **하나 이상**이 만족되어야 한다:

- `α ⊆ R`, `β ⊆ R` 이고,
    
- 반드시 다음 중 하나를 만족:
    
    1. `α → β`가 **자명한 종속성(trivial)** 이다. (`β ⊆ α`)
        
    2. `α`가 **R의 슈퍼키(Superkey)** 이다.

키가 아닌 다른게 포함되면 BCNF가 아니다?

> [!example] BCNF가 아닌 예시
> `big_instructor(ID, name, salary, dept_name, building, budget)`
> 
> 이 스키마는 BCNF를 **만족하지 않는다.**  
> 그 이유는 다음과 같다:
> 
> - `dept_name → building, budget` 이라는 함수 종속성이 **성립**하지만,
>     
> - `dept_name`은 **슈퍼키가 아니기 때문**이다.
>     
> 
> 따라서 이 스키마는 BCNF 위반이다.

간단히 말하면, 릴레이션의 모든 결정자는 후보키 이상이어야 된다.

>**제3정규형(3NF)** 에서는 왼쪽이 후보키가 아니더라도 오른쪽이 기본 속성(후보키에 포함된 속성)이면 허용되지만, BCNF에서는 무조건 릴레이션의 모든 결정자는 후보키여야 한다. 

---
## **Decomposing a Schema into BCNF**

스키마 `R`이 주어졌고,  `α → B`라는 **자명하지 않은**(B가 a에 포함되지 않았을 때 ) 함수 종속성이 BCNF를 **위배한다고 가정**하자.  즉, `α`가 **후보키가 아닌 경우**이다.

이럴 때 우리는 `R`을 **BCNF를 만족하는 형태로 분해**할 수 있다.

1. `R₁ = α ∪ B`  
    → 이 릴레이션은 `α → B`를 명시적으로 포함함  
    → 이 안에서는 `α`가 **슈퍼키**가 되므로 BCNF를 만족
    
2. `R₂ = R - (B - α)`  
    → `R`에서 `B - α`에 해당하는 속성들을 제거한 나머지 릴레이션  
    → `α`는 이 릴레이션 안에서도 여전히 의미 있는 결정자가 될 수 있음

> [!example] 예시 상황
> 
> 릴레이션 스키마: `big_instructor(ID, name, salary, dept_name, building, budget)`
> 
> 함수 종속성: `dept_name → building, budget`
> 
> - 여기서 `dept_name`은 **슈퍼키가 아니므로 BCNF를 위배함**
>     
> - 이 함수적 종속성은 **자명하지 않음** (`building`, `budget` ⊈ `dept_name`)
> 
> 
> 우리는 다음과 같이 **BCNF에 따라 R을 분해**할 수 있다.
> 
> ##### 1️⃣ `α ∪ β = dept_name ∪ {building, budget}`
> 
> → **새 릴레이션 R₁**: `(dept_name, building, budget)`
> 
> ##### 2️⃣ `R - (β - α) = R - ({building, budget} - {dept_name})`
> 
> → `= R - {building, budget}`  
> → **새 릴레이션 R₂**: `(ID, name, salary, dept_name)`
> 

---

## **BCNF and Dependency Preservation**

**제약 조건(constraints)**, 특히 **함수 종속성(functional dependency)** 과 같은 제약은  
실제로는 **검사 비용이 많이 들 수 있다**. 특히 이 제약 조건들이 **하나의 릴레이션에만 국한되지 않는 경우**,  즉, **여러 릴레이션에 걸쳐 있는 경우**에는  **검사 과정이 훨씬 복잡하고 비효율적**이 될 수 있다.

만약 어떤 분해에서,  **각 개별 릴레이션에 존재하는 함수 종속성들만 검사** 해도  **전체 함수 종속성들이 모두 만족되는지 확인할 수 있다면**,  우리는 그 분해를 **함수적 종속성 보존 분해(dependency preserving decomposition)** 라고 한다.

> [!note] 개별 릴레이션의 함수 종속성만 검사해도 전체 함수 종속성을 확인할 수 있는 이유
>  **릴레이션 분해 시**, **외래 키(Foreign Key)** 를 통해 **릴레이션 간의 연결 관계**가 유지되기 때문!
> 
> > 외래 키는 다른 릴레이션의 **기본 키만 참조**할 수 있다.  
> > 즉, **릴레이션 간 함수 종속성은 오직 기본키-외래키 형태로만 연결**된다.
> 
> 따라서 릴레이션 내부에서의 함수 종속성만 잘 지키면, 릴레이션 간 연결(외래키)은 PK → FK 관계로 이미 구조화되어 있고, 그 외의 함수 종속성은 발생하지 않도록 분해되어 있기 때문에,**각 릴레이션만 검사해도 전체 함수 종속성 위배를 탐지할 수 있는 것**이다.

**BCNF와 함수 종속성 보존(dependency preservation)** 을 **동시에 만족시키는 것이 항상 가능한 것은 아니기 때문에**,  우리는 **그보다 더 약한 정규형**인 **제3정규형(3NF)** 을 고려하게 된다.

---
## **Third Normal Form**

릴레이션 스키마 R이 **3NF**에 있다면,  모든 함수 종속성 α→β에 대해 **다음 중 하나 이상을 만족**해야 한다.

α→β가 자명(trivial)할 때  즉, β⊆α

α가 릴레이션 R의 **슈퍼키**이면 OK

**결정자 α가 슈퍼키가 아니더라도**,  β에 있는 속성들이 **전부 기본 속성(후보키에 포함된 속성)** 이면 → OK

![](../images/Pasted%20image%2020250417141128.png)

advisor(<u>s_ID</u>, i_ID, <u>dept_name</u>)

```
s_ID , dept_name -> i.ID
s_ID , dept_name -> i.ID, s.ID, dept_name
```

> 둘 중에 하나만 달라도 키가 다름! 

근데 i_ID → dept_name 라는 추가 제약 조건이 생겼다.

`i_ID → dept_name`에서  종속자인 `dept_name`은 후보키인 {s_ID,dept_name}에 포함된 **기본 속성**이므로,  **3NF는 만족**한다. 하지만 `i_ID → dept_name`에서  결정자 `i_ID`는 **슈퍼키가 아니기 때문에**,  **BCNF는 위배**된다.

BCNF를 만족시키기 위해 다음과 같이 분해했다.

- **R1(s_ID, i_ID)**
- **R2(i_ID, dept_name)**

각각의 릴레이션이 **BCNF를 만족**하지만, 원래의 종속성 `s_ID,dept_name→i_ID`를 **직접 표현할 수 없기 때문에**, **Dependency-preserving은 만족하지 않는다.**

위의 경우에서는 3NF와 BCNF를 둘 다 만족할 수 없다. 3NF 을 택할지(중복을 허용하고 Dependency-preserving를  지킬지) BCNF(Dependency-preserving를 포기하고 중복 없이 구성할지) 를 택할지는 선택!

---
## **Goals of Normalization**

R을  함수 종속성 F를 가지는 릴레이션 스키마라고 하자.

**릴레이션 스키마 R가 "좋은 형태(good form)"인지 판단한다.**  여기서  좋은 형태란 일반적으로 **BCNF 혹은 3NF**를 의미한다.
    
**만약 R이 좋은 형태가 아니라면**,  이를 {R<sub>1</sub>,R<sub>2</sub>,…,R<sub>n</sub>}의 **릴레이션 스키마 집합으로 분해한다.**
    
이때 분해는 다음 조건을 만족해야 한다:
    
- 각 릴레이션 R<sub>i</sub>는 **좋은 형태**여야 한다 (보통 BCNF 또는 3NF)    

- 분해는 **무손실 조인(Lossless-join)** 을 보장해야 한다

- 가능하다면, **종속성 보존(Dependency preserving)** 도 만족하는 것이 바람직하다

---
## **Closure of Functional Dependencies**

##### Armstrong’s Axioms

![](../images/Pasted%20image%2020250417144023.png)
![](../images/Pasted%20image%2020250424023624.png)

**Sound (정확함)** → 실제로 성립하는 종속성만 만들어냄
    
**Complete (완전함)**:  → 유도 가능한 모든 종속성을 빠짐없이 만들 수 있음

> [!example]
> **릴레이션**: R=(A,B,C,G,H,I)
> 
> **함수 종속성 집합 F**:
> 
> - $A→B$
> - $A→C$    
> - $CG→H$
> - $CG→I$  
> - $B→H$ 
> 
> 유도된 종속성 
> 
> - $A→H$
> - $AG→I$ 
> 
> - $CG→I$ 
> - $CG→I$ → **확장법칙**으로 $CG→CGI$
> - $CG→H$ → **확장법칙**으로 $CG→CGH$
> 두 확장을 결합해 $CG→HI$


---
## **Procedure for Computing F<sup>+</sup>**

##### 함수 종속성 클로저 F<sup>+</sup>란?

함수 종속성 집합 F로부터 **논리적으로 도출할 수 있는 모든 함수 종속성의 집합**이다. 다시 말해, F에 직접 포함되어 있지는 않지만, 여러 규칙들을 이용해 **새로 만들어낼 수 있는 모든 종속성들**을 포함한다.

> [!note] F+를 구하는 방법
> 1. **처음에는** F의 내용 그대로 F<sup>+</sup>에 넣는다.
>     
> 2. **다음 세 가지 규칙을 반복적으로 적용한다:**
>     
>     - **반사성 (Reflexivity)**  
>         어떤 속성 집합이 자기 자신이나 그 일부를 포함하면, 그것은 스스로를 결정할 수 있다.  
>         예: $AB→A$
>         
>     - **확장 (Augmentation)**  
>         이미 알고 있는 종속성에 같은 속성을 양쪽에 더해도 여전히 성립한다.  
>         예: $A→B$이면 $AC→BC$
>         
>     - **전이 (Transitivity)**  
>         $A→B$, $B→C$ 라면, $A→C$도 성립한다.
>         
> 3. **새로운 종속성이 생기면 F<sup>+</sup>에 추가한다.**
>     
> 4. **더 이상 새로 나올 종속성이 없을 때까지 반복한다.**


---
## **Closure of Attrubute Sets**
##### 클로저 α<sup>+</sup>란?
α<sup>+</sup>는 속성 집합 α가 **함수 종속성 집합 F** 아래에서 **결정할 수 있는 모든 속성들의 집합**이다. 쉽게 말해, α만 알고 있을 때 **함수 종속성들을 따라가며 어떤 속성들까지 알아낼 수 있는지**를 나타낸다.


```c
result += ɑ

while ( changes to result ) do
    for each β → γ in F:     
	    begin
		    if β ⊆ result then result := result ∪ γ
		end
		
```

우선 결과 집합에 속성 집합 α에 있는 모든 속성들을 그대로 넣는다.  그 다음, 함수 종속성 집합 F를 보면서 각 함수 종속성 β → γ에 대해, 만약 β의 **모든 속성**이 결과 집합에 포함되어 있다면,  그에 따라 결정되는 속성 γ도 결과 집합에 추가한다.  이 과정을 더 이상 새로운 속성이 추가되지 않을 때까지 반복한다.

>쉽게 생각하면 좌변의 모든 속성이 결과 값에 있으면, 우변도 포함시킨다.
### Example

![](../images/Pasted%20image%2020250424024009.png)
#### 1️⃣ (AG)<sup>+</sup> 계산 과정

우선 AG의 클로저를 구하고자 하므로, 초기 결과 집합에는 A와 G가 포함된다.

먼저, 함수 종속성 A → B와 A → C에 주목하자.  두 종속성 모두 좌변의 A가 결과 집합에 있으므로, 우변의 B와 C를 결과 집합에 추가할 수 있다.  따라서 현재 결과 집합은 A, B, C, G가 되어 **ABCG**가 된다.

이제 CG → H를 보면, 좌변인 C와 G가 모두 결과 집합에 포함되어 있으므로,  우변의 H도 결과 집합에 추가되어 **ABCGH**가 된다.

같은 방식으로 CG → I도 적용할 수 있다.  좌변 CG는 이미 결과 집합에 있으므로, 우변의 I를 추가하여 **ABCGHI**가 된다.

이렇게 반복한 결과, AG⁺ = **ABCGHI**이다.

#### 2️⃣ AG는 후보 키(candidate key)인가?

후보 키는 **슈퍼 키 중에서 최소 속성 집합**을 가지는 키이므로,  먼저 해당 속성 집합이 **슈퍼 키인지부터 확인**하겠다

 >AG가 슈퍼 키인가?

(AG)<sup>+</sup>=R 이므로, AG의 클로저가 릴레이션 R의 **모든 속성**을 포함한다는 뜻이다.  즉, AG만 알고 있어도 R의 모든 속성 값을 결정할 수 있으므로,  **AG는 슈퍼 키**가 된다.

> **AG의 부분 집합도 슈퍼 키인가?**

만약 AG의 **부분 집합 중 하나라도 슈퍼 키**라면, AG는 **최소성이 보장되지 않으므로 후보 키가 아니다**.  
이를 확인하기 위해 AG의 부분 집합인 A와 G 각각의 클로저를 구해보자.

A<sup>+</sup>={A,B,C,H} → R에 미치지 못함 <sup></sup>
G+={G} → 역시 미치지 못함 

따라서 AG의 **어떤 부분 집합도 슈퍼 키가 아니며**,  결과적으로 **AG는 최소성을 만족하는 후보 키**이다.

---
## **Use of Attrubute Closure**

##### 1. **슈퍼 키 판별**

어떤 속성 집합 α가 슈퍼 키인지 확인하려면, α<sup>+</sup>를 계산하고, α+가 릴레이션 R의 모든 속성을 포함하는지 확인한다. 모든 속성이 포함되면(α<sup>+</sup>⊇R ) α만으로 릴레이션을 구별할 수 있다는, α에 따라 다른 속성 값도 정해진다는 것을 의미하므로, 슈퍼키가 된다. 

##### 2. **함수 종속성 판별**

어떤 함수 종속성 α→β가 유효한지 확인하려면, α<sup>+</sup>를 계산하고, β⊆α<sup>+</sup>인지 확인한다. 즉, α만 알았을 때 β를 **추론할 수 있다면**, 해당 함수 종속성은 성립한다.

##### 3. **함수 종속성 전체 집합 F<sup>+</sup>계산**

릴레이션 R의 **모든 속성 부분 집합 γ⊆R**에 대해, 각각의 클로저 γ<sup>+</sup>를 계산한다.  그 후, γ<sup>+</sup>에 포함된 각 속성 집합 S에 대해 γ→S라는 함수 종속성을 도출할 수 있다.  이러한 과정을 반복하여, **함수 종속성 집합 F**의 전체 클로저인 F<sup>+</sup>를 구할 수 있다.

---
## **Lossless-join Decomposition**

릴레이션 R이 R<sub>1</sub>, R<sub>2</sub>로 분해된다고 할 때,  **Lossless-Join 분해**가 되기 위한 조건은 다음과 같다:
    
$$r = ⨅_{R1}(r) ⨝ ⨅_{R2}(r)$$

즉, 원래 릴레이션 r은 R<sub>1</sub>, R<sub>2</sub>로 분해한 후  다시 조인했을 때 **정보 손실 없이** 복원되어야 한다.

#### ✅ Lossless-Join 분해 판별법

다음 중 **하나라도** 함수 종속성 집합 F<sup>+</sup>에 포함되면 lossless:
   
```
R1 ∩ R2 → R1
R1 ∩ R2 → R2
```

즉, R1과 R2의 **공통 속성**이  R1 또는 R2를 **결정할 수 있다면**, **lossless 분해**가 된다.
<sub></sub>
> [!example] 예시1
> R = ( A, B, C )
> F = { A → B, B → C }
> 
> R<sub>1</sub> = ( A, B )
> R<sub>2</sub> = ( B, C )
> 
> R1과 R2의 공통된 속성, B가 R1 전체를 결정하거나, R2를 결정할 때 lossless다.
> B → C에서  B → BC 종속성을 얻을 수 있고, B가 R<sub>2</sub> ( B, C )를 결정하므로 Lossless 한 분해다. 

> [!example] 예시2
> $R_2 = (A, C)$, $R2​=(A,C)$로 릴레이션을 분해했다고 하자.  
> 
> 이때 두 릴레이션의 **공통 속성은 A**이며, 
>  A→B, B→C라는 함수 종속성으로부터 A→C를 **추론**할 수 있다.  
>  
> 따라서 A→AC가 성립하고, 이로 인해 **무손실 분해(Lossless Decomposition)** 가 보장된다.
> 
>하지만 이 분해에서는 원래의 함수 종속성 중 하나였던 B→C를 **직접적으로 확인할 수 없기 때문에**, **함수 종속성 보존(Dependency Preservation)** 은 **되지 않는다**.

---
## **Dependency Preservation**

F<sub>i</sub>*는 **릴레이션 R<sub>i</sub>에* 속한 속성들만 포함하는 함수 종속성 F<sup>+</sup>의 부분 집합이다.
    
어떤 분해가 **의존성 보존**이라고 말하려면 다음 조건을 만족해야 한다:

$$(F_1 \cup F_2 \cup \dots \cup F_n)^+ = F^+$$

즉, **분해된 각각의 릴레이션에서의 종속성들의 합집합**으로부터  **원래의 모든 함수 종속성 F<sup>+</sup> 을 유도할 수 있어야 한다.

만약 위 조건을 만족하지 않는다면,  데이터 갱신 시 **함수 종속성 위반 여부를 확인하기 위해 조인 연산**을 수행해야 할 수 있다. 이러한 조인 연산은 **비용이 크고 비효율적**이다.
    
릴레이션 $R=(A,B,C)$, 함수 종속성 집합 $F = \{ A \rightarrow B,\ B \rightarrow C \}$, 그리고 후보 키는 $\{ A\}$라고 하자.

이 경우, 3NF는 만족하지만 $R$은 **BCNF를 만족하지 않는다.**  이행종속성이 있지만, 두 번째 종속성의 우변이 다른 종속성의 좌변에 포함되어있기 때문이다. BCNF를 만족하지 못하는 이유는 BCNF를 만족하기 위해서는 후보 키인 A를 통해서 전체 속성을 결정할 수 있어야 하는데, $B→C$가 **비후보 키 속성인 B를 결정자**로 가지기 때문이다. 

이에 따라 BCNF 분해를 수행하면 다음과 같이 된다.

- $R_1 = (A, B)$

- $R_2 = (B, C)$ 

이 분해는 위의 예시에서 봤듯이 **무손실 분해(Lossless-join decomposition)** 를 만족하며, $R_1$​과 $R_2$​ 모두 각각의 함수 종속성을 만족하므로 **BCNF에 속한다.** $A→B$ 는 R<sub>1</sub>에서 확인할 수 있고,  종속성 $B→C$는 $R_2$​에서 확인할 수 있다. 따라서 전체적으로 봤을 때 각 F의 합집합이 원래 F<sup>+</sup>을 만족하므로  **함수 종속성 보존(Dependency Preserving)** 은 보존된다. 

---
## **BCNF and Dependency Preservation**

항상 BCNF 분해는 함수 종속성 보전을 하는 것은 아니다. 예시를 보자

R = ( J, K, L )
F = { JK -> L, L -> K }

이 릴레이션은 **이행 종속성**  $JK \rightarrow L \rightarrow K$를 갖기 때문에 **3NF를 만족하지 않는 것처럼 보일 수 있다**. 하지만, 종속성 $L \rightarrow K$에서 **우변 K는 후보키 JK의 부분집합**이므로 **3NF 조건을 만족한다**.

반면, **BCNF는 더 엄격한 조건**을 요구한다. 모든 함수 종속성 좌변이 **슈퍼키**여야 한다. 여기서 $L \rightarrow K$는 좌변 L이 슈퍼키가 아니므로, **BCNF를 만족하지 않는다.**

BCNF를 만족하기 위해서 다음과 같이 분해했다.

R1 = ( L, K )
R2 = ( J, L )

이 분해는 공통 속성 $L$이 $R_1$​에서 $K$를 결정하므로 **무손실 분해(Lossless Decomposition)**가 보장된다.

하지만 원래 함수 종속성 중 하나인 $JK \rightarrow L$은  분해된 릴레이션 어디에서도 **직접적으로 확인할 수 없으므로**, **함수 종속성 보존(Dependency Preservation)** 은 만족되지 않는다.

---
## **Comparison of BCNF and 3NF**

##### **3NF 분해 (Third Normal Form Decomposition)**

어떤 릴레이션이든지 항상 **3NF**로 분해하는 것이 가능하며,  이때 다음 두 조건을 동시에 만족할 수 있다:
    
1. **무손실 분해(lossless decomposition)**
    
2. **함수 종속성 보존(dependency preserving)**

##### **BCNF 분해 (Boyce-Codd Normal Form Decomposition)**

어떤 릴레이션도 **BCNF**로 분해하는 것은 항상 가능하다. 

**무손실 분해(lossless decomposition)** 를 보장하지만, 3NF와 다르게 **함수 종속성 보존**은 **항상 보장되지는 않는다.**  즉, BCNF로 분해하면 경우에 따라 **일부 종속성을 보존하지 못할 수 있다.**

----
