
## **Recap: Basic Query Structure**


일반적인 SQL의 쿼리는 다음과 같은 형태를 가진다. 

```sql
select A1, A2, ...,An from r1, r2, ..., rm where P
```

```sql
select name
from instructor
where dept_name = 'Comp. Sci.' and salary > 80000
```

• A<sub>i</sub> : 속성 
• R<sub>i</sub> : 릴레이션 
• P : 조건

SQL 쿼리의 결과는 릴레이션이다.

---
## **Basic Steps in Query Processing**

![](../images/Pasted%20image%2020250604223917.png)

---
## **Basic Steps: Optimization**

**쿼리 최적화(Query Optimization)** 란, **같은 결과를 반환하는 여러 평가 계획(evaluation plans)** 중에서  
**비용(cost)** 이 가장 낮은 계획을 선택하는 과정을 말한다.

이때의 **비용**은 단순한 실행 시간뿐 아니라, **I/O 횟수, 중간 결과 크기, 메모리 사용량** 등을 포함할 수 있으며,  이는 **데이터베이스 카탈로그 에 저장된 통계 정보**를 기반으로 추정된다.  

> 예: 각 릴레이션에 포함된 **튜플 수**, 각 튜플의 **평균 크기**, 특정 속성의 **중복도(cardinality)** 등

---
## **Measures of Query Cost**

**쿼리 비용(cost)** 은 일반적으로 **쿼리 결과를 반환하는 데 걸리는 전체 시간**을 의미하며,  여러 요소들이 이 시간에 영향을 미친다. 대표적인 요소로는 **디스크 접근 횟수, CPU 사용량**, 그리고 분산 환경에서는 **네트워크 통신 비용** 등이 있다.

그중에서도 **디스크 접근은 일반적으로 가장 비용이 크며**,  성능을 분석하거나 최적화할 때 **핵심 요소로 간주**된다.

쿼리 수행 시 디스크 비용은 다음과 같이 추정할 수 있다:

`읽은 블록 수 × 평균 블록 읽기 비용`

`작성한 블록 수 × 평균 블록 쓰기 비용`

여기서 **블록을 쓰는 비용은 읽는 비용보다 크다.**  이는 **데이터를 성공적으로 썼는지 확인하기 위해 쓰기 이후 검증(read-after-write)** 이 필요한 경우가 많기 때문이다.

---

일부 알고리즘은 **버퍼 메모리(buffer memory)** 를 적극 활용해  **디스크 I/O를 줄일 수 있다.**

그러나 실제로 사용 가능한 버퍼 메모리 양은  **동시에 실행 중인 다른 쿼리나 운영체제 프로세스 상황에 따라 달라지며**,  이 값은 실행 시점이 되어야만 정확히 알 수 있다.

이 때문에 일반적으로는 **최악의 경우(worst-case)를 가정하여**,  **연산에 필요한 최소 메모리만 사용 가능한 상황을 기준으로 비용을 추정**한다.

또한, **필요한 데이터가 이미 버퍼에 존재하는 경우**,  해당 데이터는 **디스크에서 다시 읽을 필요 없이 바로 접근 가능**하므로 추가 I/O 비용이 발생하지 않게 된다.

---
## **Recap: I/O complexity model**

간단히 말해서, **쿼리 비용은 디스크에서 전달되는 블록의 수를 기준으로 측정한다고 보면 된다.**

> [!note] 정리
> - **M** : 메모리 크기, 즉 **메인 메모리에 적재 가능한 튜플 수**
>     
> - **B** : 블록 크기, 즉 **한 블록에 저장 가능한 튜플 수**
>     
> - **N** : 릴레이션에 존재하는 전체 튜플 수

이때 디스크 I/O 비용은 다음과 같이 근사할 수 있다:

- **Linear I/O** : $\left( \frac{N}{B} \right)$  → 릴레이션 전체를 한 번 스캔할 때 필요한 **블록 수**
    
- **Logarithmic I/O** : $O\left( \log_B N \right)O(logB​N)$ → 인덱스(B-tree 등)를 사용하여 **검색할 때 필요한 I/O 수**
    

실제로는 디스크 **탐색 비용(seek cost)**이나 **CPU 연산 비용**도 고려해야 하지만,  이론적인 분석에서는 보통 단순화를 위해 **이러한 비용은 무시**한다.  다만, **현실의 DBMS는 CPU 비용도 실제로는 함께 고려**한다.

---
## **Selection Operation**

### 1️⃣ File Scan – Linear Search (Algorithm A1)

**Algorithm A1: Linear Search**는 가장 단순한 파일 검색 방법으로,  **파일의 모든 블록을 순차적으로 스캔하며 각 레코드를 검사**하여 선택 조건을 만족하는지를 확인한다.

**I/O 비용**은 명확히 $O(N/B)$,  즉 전체 N개의 튜플을 B개씩 나눈 **블록 수만큼의 디스크 접근**이 필요하다.

이 방식은 다음과 같은 조건에 **관계없이 항상 적용 가능**하다:

- 선택 조건의 형태와 관계없이
    
- 파일 내 레코드의 정렬 여부와 무관하게
    
- 인덱스의 존재 여부와 상관없이

즉, 인덱스가 없거나 조건이 복잡해도 항상 사용할 수 있는 **기본 전략**이다.

#### 대용량 메모리가 있는 경우 (M > N)

메모리 크기 M이 전체 튜플 수 N보다 크다고 하더라도,  **레코드를 메모리에 적재하려면 여전히 모든 블록을 한 번은 디스크에서 읽어야 하므로**,  **최소한 N/B번의 디스크 I/O는 발생**한다.

즉, **메모리가 충분하다고 해도 디스크에서 데이터를 읽는 최소 비용은 피할 수 없다.**

---
### 2️⃣ Index Scan 

인덱스를 이용한 검색에서는 **selection condition이 반드시 인덱스의 search-key에 대해 주어져야** 한다.

##### **A2. Primary B+ Tree Index + Equality on Key (정확히 하나의 레코드 검색)**

- **조건**: 검색 조건이 **기본(primary) B+ 트리 인덱스의 키(key)** 에 대한 **정확한 등치 조건(equality condition)**일 때

- 예시: `WHERE id = 12345` (id가 기본 키인 경우)

- **정확히 하나의 레코드만 검색됨 (Exact match search)**

- **I/O 비용**: $O(log⁡BO(\log_B N)$ (트리 높이만큼 블록 접근)

#### **A3. Primary B+ Tree Index + Equality on Non-Key (중복 키 검색)**

- **조건**: 검색 조건이 **primary B+ 트리 인덱스의 non-key 속성**에 대한 **등치 조건**일 때

- 예시: `WHERE dept_name = 'Finance'` (중복 가능)

- 이 경우, **여러 개의 레코드가 같은 키 값을 가질 수 있음**

- T: 해당 키 값을 가지는 레코드 수라고 하면,

- **I/O 비용** : $O(\log_B N + T/B)$ → 트리 탐색 비용 + T개의 레코드를 블록 단위로 읽는 비용

#### **A4. Secondary Index + Equality on Non-Key**

보조 인덱스를 사용하는 경우, 검색 조건이 **기본(primary key)이 아닌 속성**에 대해 주어지며, 이 속성은 **보조 인덱스(secondary index)** 에 존재한다.

##### 1. Search-key가 후보 키인 경우 (즉, 유일함)

- 예시: `WHERE email = 'abc@xyz.com'` (email이 후보 키라고 가정)

- **하나의 레코드만 검색**

- **I/O 비용** : $O(\log_B N)$ → 보조 인덱스를 탐색하여 해당 레코드로 직접 접근

##### 2. Search-key가 후보 키가 아닌 경우 (즉, 중복값 존재)

- 예시: `WHERE dept_name = 'Finance'` (여러 명이 Finance 소속일 수 있음)

- **T개의 레코드가 같은 키 값을 가질 수 있고**,  이들 각각이 **서로 다른 블록에 위치**할 수 있음

- 따라서 블록을 하나씩 접근해야 하므로

- **I/O 비용** : $O(\log_B N + T)$ → 인덱스 탐색 비용 + T개의 블록을 각각 접근하는 비용


> 이 경우 비용이 상당히 비쌀 수 있다. (최악의 경우 T개의 I/O가 발생)

---
