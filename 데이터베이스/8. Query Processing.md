
## **Recap: Basic Query Structure**


일반적인 SQL의 쿼리는 다음과 같은 형태를 가진다. 

```sql
select A1, A2, ...,An from r1, r2, ..., rm where P
```

```sql
select name
from instructor
where dept_name = 'Comp. Sci.' and salary > 80000
```

• A<sub>i</sub> : 속성 
• R<sub>i</sub> : 릴레이션 
• P : 조건

SQL 쿼리의 결과는 릴레이션이다.

---
## **Basic Steps in Query Processing**

![](../images/Pasted%20image%2020250604223917.png)

---
## **Basic Steps: Optimization**

**쿼리 최적화(Query Optimization)** 란, **같은 결과를 반환하는 여러 평가 계획(evaluation plans)** 중에서  
**비용(cost)** 이 가장 낮은 계획을 선택하는 과정을 말한다.

이때의 **비용**은 단순한 실행 시간뿐 아니라, **I/O 횟수, 중간 결과 크기, 메모리 사용량** 등을 포함할 수 있으며,  이는 **데이터베이스 카탈로그 에 저장된 통계 정보**를 기반으로 추정된다.  

> 예: 각 릴레이션에 포함된 **튜플 수**, 각 튜플의 **평균 크기**, 특정 속성의 **중복도(cardinality)** 등

---
## **Measures of Query Cost**

Cost는 일반적으로 쿼리의 결과를 반환하는 전체 시간을 측정한다. 많은 요인들이 time cost 에 영향을 주는데, 디스크 접근, CPU, 심지어 네트워크 커뮤니케이션도 영향을 준다.

일반적으로 디스크 접근은 많은 비용이 든다. 그리고 또한 상대적으로 삭제하기 쉽다.

Number of blocks read × average-block-read-cost
Number of blocks written × average-block-write-cost

블록에 작성하는데 드는 비용이 블록을 읽는데 드는 비용보다 더 크다. 왜냐하면 작성을 성공적으로 잘 했는지 보장하기 위해서 다 작성된 후 다시 읽기 때문이다. 

몇몇의 알고리즘은 남는 버퍼 공간을 사용하여 디스크의 I/O를  줄일 수 있다. Amount of real memory available to buffer depends on other 
concurrent queries and OS processes, known only during execution
• We often use worst case estimates, assuming only the minimum 
amount of memory needed for the operation is available
Required data may be buffer resident already, avoiding disk I/O
