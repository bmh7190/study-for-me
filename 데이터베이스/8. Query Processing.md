
## **Recap: Basic Query Structure**


일반적인 SQL의 쿼리는 다음과 같은 형태를 가진다. 

```sql
select A1, A2, ...,An from r1, r2, ..., rm where P
```

```sql
select name
from instructor
where dept_name = 'Comp. Sci.' and salary > 80000
```

• A<sub>i</sub> : 속성 
• R<sub>i</sub> : 릴레이션 
• P : 조건

SQL 쿼리의 결과는 릴레이션이다.

---
## **Basic Steps in Query Processing**

![](../images/Pasted%20image%2020250604223917.png)

---
## **Basic Steps: Optimization**

**쿼리 최적화(Query Optimization)** 란, **같은 결과를 반환하는 여러 평가 계획(evaluation plans)** 중에서  
**비용(cost)** 이 가장 낮은 계획을 선택하는 과정을 말한다.

이때의 **비용**은 단순한 실행 시간뿐 아니라, **I/O 횟수, 중간 결과 크기, 메모리 사용량** 등을 포함할 수 있으며,  이는 **데이터베이스 카탈로그 에 저장된 통계 정보**를 기반으로 추정된다.  

> 예: 각 릴레이션에 포함된 **튜플 수**, 각 튜플의 **평균 크기**, 특정 속성의 **중복도(cardinality)** 등

---
## **Measures of Query Cost**

**쿼리 비용(cost)** 은 일반적으로 **쿼리 결과를 반환하는 데 걸리는 전체 시간**을 의미하며,  여러 요소들이 이 시간에 영향을 미친다. 대표적인 요소로는 **디스크 접근 횟수, CPU 사용량**, 그리고 분산 환경에서는 **네트워크 통신 비용** 등이 있다.

그중에서도 **디스크 접근은 일반적으로 가장 비용이 크며**,  성능을 분석하거나 최적화할 때 **핵심 요소로 간주**된다.

쿼리 수행 시 디스크 비용은 다음과 같이 추정할 수 있다:

`읽은 블록 수 × 평균 블록 읽기 비용`

`작성한 블록 수 × 평균 블록 쓰기 비용`

여기서 **블록을 쓰는 비용은 읽는 비용보다 크다.**  이는 **데이터를 성공적으로 썼는지 확인하기 위해 쓰기 이후 검증(read-after-write)** 이 필요한 경우가 많기 때문이다.

---

일부 알고리즘은 **버퍼 메모리(buffer memory)** 를 적극 활용해  **디스크 I/O를 줄일 수 있다.**

그러나 실제로 사용 가능한 버퍼 메모리 양은  **동시에 실행 중인 다른 쿼리나 운영체제 프로세스 상황에 따라 달라지며**,  이 값은 실행 시점이 되어야만 정확히 알 수 있다.

이 때문에 일반적으로는 **최악의 경우(worst-case)를 가정하여**,  **연산에 필요한 최소 메모리만 사용 가능한 상황을 기준으로 비용을 추정**한다.

또한, **필요한 데이터가 이미 버퍼에 존재하는 경우**,  해당 데이터는 **디스크에서 다시 읽을 필요 없이 바로 접근 가능**하므로 추가 I/O 비용이 발생하지 않게 된다.

---
## **Recap: I/O complexity model**

간단하게 말하면 단지 디스크에서 전달되는 블록의 수를 사용한다고 생각하면 된다. 

M : 메모리 사이즈, 메인 메모리에 들어갈 수 있는 tuple의 수라고 생각하면 된다.
B : 블록의 크기, 블록에 들어갈 수 있는 tuple의 수라고 생각하면 된다.
N : 릴레이션 안에 있는 tuple의 수

Linear I/O = O ( N / B ) ( block 개수 )
:ora